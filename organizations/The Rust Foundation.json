{"name":"The Rust Foundation","description":"A language empowering everyone","gsoc_url":"https://summerofcode.withgoogle.com/programs/2025/organizations/the-rust-foundation","ideas_url":"https://github.com/rust-lang/google-summer-of-code","logo":"https://summerofcode.withgoogle.com/media/org/the-rust-foundation/pplrhxvka7dufvsn.png","technologies":["python","rust"],"topics":["compilers","programming languages"],"projects":[{"project_name":"Extend `annotate-snippets` with features required by rustc","summary":"This project aims to enhance `rustc`'s support for `annotate-snippets`, ensuring all features are implemented, allowing for a full pass of the `rustc` test suite using this tool.","difficulty":"Medium or hard"},{"project_name":"Reproducible builds","summary":"The goal is to enhance the reproducibility of Rust builds, particularly focusing on the toolchain and binary artifacts, minimizing discrepancies that could lead to security vulnerabilities.","difficulty":"Hard"},{"project_name":"Bootstrap of rustc with `rustc_codegen_gcc`","summary":"This project seeks to resolve issues in `rustc_codegen_gcc` to allow it to compile both a `Hello, World!` program and the Rust standard library, with further ambitions for full bootstrap.","difficulty":"Medium-Large"},{"project_name":"Refactoring of `rustc_codegen_ssa` to make it more convenient for the GCC codegen","summary":"The objective is to refactor the current `rustc_codegen_ssa` structure to streamline the GCC backend, minimizing hacks and unsafe code while improving maintainability.","difficulty":"Medium"},{"project_name":"ABI/Layout handling for the automatic differentiation feature","summary":"This project aims to optimize handling of function ABI and memory layout in support of Rust's automatic differentiation capabilities, focusing on enhancing usability for the autodiff tools.","difficulty":"Medium to hard"},{"project_name":"Improving parallel frontend","summary":"The focus of this project is to enhance the parallel execution of the Rust compiler's frontend, addressing deadlocks and optimizing various stages for better performance.","difficulty":"Medium to hard"},{"project_name":"C codegen backend for `rustc`","summary":"This project aims to develop a new backend for `rustc` that can transpile Rust code into C code, facilitating better platform support and advanced optimizations by utilizing C compilers.","difficulty":"Hard"},{"project_name":"Extend testing of `std::arch` intrinsics","summary":"This project focuses on extending the testing framework for architecture-specific intrinsics in the `std::arch` module to validate their functionality across multiple architectures, starting with x86.","difficulty":"Medium"},{"project_name":"Implement merge functionality in bors","summary":"The goal of this project is to replace the outdated merging bot `homu` with a new version of `bors` that includes robust functionality for merging pull requests efficiently.","difficulty":"Medium"},{"project_name":"Improve bootstrap","summary":"This project aims to enhance the Rust compiler's bootstrap tooling, reducing technical debt, improving documentation, and increasing test coverage.","difficulty":"Medium to large"},{"project_name":"Port `std::arch` test suite to `rust-lang/rust`","summary":"The objective is to fully integrate the `stdarch` test suite into the main Rust compiler repository, ensuring comprehensive testing and smoother development processes.","difficulty":"Medium"},{"project_name":"Prototype an alternative architecture for `cargo fix`","summary":"This project explores redesigning the `cargo fix` command to run in parallel, aiming to enhance performance and user experience in correcting code issues.","difficulty":"Medium"},{"project_name":"Prototype Cargo plumbing commands","summary":"The goal is to develop 'plumbing' commands in Cargo that expose underlying functionalities for users to build custom command chains, enhancing the flexibility of Cargo.","difficulty":"Medium"},{"project_name":"Move cargo shell completions to Rust","summary":"This project aims to consolidate and improve shell auto-completion for Cargo by moving its implementation to Rust for enhanced maintainability and feature completeness.","difficulty":"Medium"},{"project_name":"Build script delegation","summary":"This project focuses on enabling build script delegation within Cargo, allowing developers to specify dependencies that should function like build scripts, thereby improving usability and safety.","difficulty":"Medium"},{"project_name":"Implement a new proc-macro server RPC API","summary":"The goal is to design a new, more efficient RPC API for the proc-macro server in `rust-analyzer`, allowing for better performance and expanded functionality in proc-macro support.","difficulty":"Medium"},{"project_name":"Modernize the libc crate","summary":"This project aims to update and release a new version of the `libc` crate, leveraging new Rust features while also cleaning up legacy code and addressing outstanding issues.","difficulty":"Medium"},{"project_name":"Add more lints to `cargo-semver-checks`","summary":"The objective is to expand the capabilities of `cargo-semver-checks` by implementing new lints that can detect breaking changes, improving the correctness of Rust package versions.","difficulty":"Medium to large"},{"project_name":"Make `cargo-semver-checks` run faster","summary":"This project seeks to optimize the performance of `cargo-semver-checks`, significantly reducing runtime while maintaining existing lint accuracy.","difficulty":"Medium to high"},{"project_name":"Enable witness generation in `cargo-semver-checks`","summary":"The goal is to implement witness generation that adds examples demonstrating breaking changes detected by `cargo-semver-checks`, enhancing the toolâ€™s usability and reliability.","difficulty":"Medium"},{"project_name":"Wild linker with test suites from other linkers","summary":"This project aims to run tests from other linkers using the Wild linker, identifying failures and diagnosing issues to improve functionality and compatibility with various linking processes.","difficulty":"Varies"}],"jina_response":"Title: GitHub - rust-lang/google-summer-of-code: Rust project ideas for Google Summer of Code\n\nURL Source: https://github.com/rust-lang/google-summer-of-code\n\nMarkdown Content:\nRust project ideas\n------------------\n\n[](https://github.com/rust-lang/google-summer-of-code#rust-project-ideas)\n\nThis page contains a list of ideas for various projects that could help improve the Rust Project and potentially also the wider Rust community.\n\nThese project ideas can be used as inspiration for various OSS contribution programs, such as [Google Summer of Code](https://summerofcode.withgoogle.com/) or [OSPP](https://summer-ospp.ac.cn/).\n\nThis document contains ideas that should still be actual and that were not yet completed. Here you can also find an archive of older projects from past GSoC events:\n\n*   Past Google Summer of Code projects\n    *   [2024](https://github.com/rust-lang/google-summer-of-code/blob/main/gsoc/past/2024.md)\n\nWe invite contributors that would like to participate in projects such as GSoC or that would just want to find a Rust project that they would like to work on to examine the project list and use it as an inspiration. Another source of inspiration can be the [Rust Project Goals](https://rust-lang.github.io/rust-project-goals/index.html), particularly the orphaned goals.\n\nIf you would like to participate in GSoC, please read [this](https://github.com/rust-lang/google-summer-of-code/blob/main/gsoc/README.md). If you would like to discuss projects ideas or anything related to them, you can do so on our [Zulip](https://rust-lang.zulipchat.com/).\n\nWe use the GSoC project size parameters for estimating the expected time complexity of the project ideas. The individual project sizes have the following expected amounts of hours:\n\n*   Small: 90 hours\n*   Medium: 175 hours\n*   Large: 350 hours\n\nIndex\n-----\n\n[](https://github.com/rust-lang/google-summer-of-code#index)\n\n*   **Rust Compiler**\n    *   [Extend annotate-snippets with features required by rustc](https://github.com/rust-lang/google-summer-of-code#Extend-annotate-snippets-with-features-required-by-rustc)\n    *   [Reproducible builds](https://github.com/rust-lang/google-summer-of-code#reproducible-builds)\n    *   [Bootstrap of rustc with rustc\\_codegen\\_gcc](https://github.com/rust-lang/google-summer-of-code#Bootstrap-of-rustc-with-rustc_codegen_gcc)\n    *   [Refactoring of rustc\\_codegen\\_ssa to make it more convenient for the GCC codegen](https://github.com/rust-lang/google-summer-of-code#Refactoring-of-rustc_codegen_ssa-to-make-it-more-convenient-for-the-GCC-codegen)\n    *   [ABI/Layout handling for the automatic differentiation feature](https://github.com/rust-lang/google-summer-of-code#abilayout-handling-for-the-automatic-differentiation-feature)\n    *   [Improving parallel frontend](https://github.com/rust-lang/google-summer-of-code#improving-parallel-frontend)\n    *   [C codegen backend for rustc](https://github.com/rust-lang/google-summer-of-code#C-codegen-backend-for-rustc)\n*   **Rust standard library**\n    *   [Extend testing of `std::arch` intrinsics](https://github.com/rust-lang/google-summer-of-code#extend-testing-of-stdarch-intrinsics)\n*   **Infrastructure**\n    *   [Implement merge functionality in bors](https://github.com/rust-lang/google-summer-of-code#implement-merge-functionality-in-bors)\n    *   [Improve bootstrap](https://github.com/rust-lang/google-summer-of-code#Improve-bootstrap)\n    *   [Port `std::arch` test suite to `rust-lang/rust`](https://github.com/rust-lang/google-summer-of-code#port-stdarch-test-suite-to-rust-langrust)\n*   **Cargo**\n    *   [Prototype an alternative architecture for `cargo fix`](https://github.com/rust-lang/google-summer-of-code#prototype-an-alternative-architecture-for-cargo-fix)\n    *   [Prototype Cargo plumbing commands](https://github.com/rust-lang/google-summer-of-code#prototype-cargo-plumbing-commands)\n    *   [Move cargo shell completions to Rust](https://github.com/rust-lang/google-summer-of-code#move-cargo-shell-completions-to-Rust)\n    *   [Build script delegation](https://github.com/rust-lang/google-summer-of-code#build-script-delegation)\n*   **rust-analyzer**\n    *   [Implement a new proc-macro server RPC API](https://github.com/rust-lang/google-summer-of-code#implement-a-new-proc-macro-server-RPC-API)\n*   **Crate ecosystem**\n    *   [Modernize the libc crate](https://github.com/rust-lang/google-summer-of-code#Modernize-the-libc-crate)\n    *   [Add more lints to `cargo-semver-checks`](https://github.com/rust-lang/google-summer-of-code#add-more-lints-to-cargo-semver-checks)\n    *   [Make `cargo-semver-checks` run faster](https://github.com/rust-lang/google-summer-of-code#make-cargo-semver-checks-run-faster)\n    *   [Enable witness generation in `cargo-semver-checks`](https://github.com/rust-lang/google-summer-of-code#enable-witness-generation-in-cargo-semver-checks)\n    *   [Wild linker with test suites from other linkers](https://github.com/rust-lang/google-summer-of-code#wild-linker-with-test-suites-from-other-linkers)\n\nProject ideas\n-------------\n\n[](https://github.com/rust-lang/google-summer-of-code#project-ideas)\n\nThe list of ideas is divided into several categories.\n\nRust Compiler\n-------------\n\n[](https://github.com/rust-lang/google-summer-of-code#rust-compiler)\n\n### Extend `annotate-snippets` with features required by rustc\n\n[](https://github.com/rust-lang/google-summer-of-code#extend-annotate-snippets-with-features-required-by-rustc)\n\n**Description**\n\n`rustc` currently has incomplete support for using [`annotate-snippets`](https://github.com/rust-lang/annotate-snippets-rs/) to emit errors, but it doesn't support all the features that `rustc`'s built-in diagnostic rendering does. The goal of this project is to execute the `rustc` test suite using `annotate-snippets`, identify missing features or bugs, fix those, and repeat until at feature-parity.\n\n**Expected result**\n\nMore of the `rustc` test suite passes with `annotate-snippets`.\n\n**Desirable skills**\n\nKnowledge of Rust.\n\n**Project size**\n\nMedium.\n\n**Difficulty**\n\nMedium or hard.\n\n**Mentor**\n\n*   David Wood ([GitHub](https://github.com/davidtwco), [Zulip](https://rust-lang.zulipchat.com/#narrow/dm/116107-davidtwco))\n\n**Zulip streams**\n\n*   [Idea discussion](https://rust-lang.zulipchat.com/#narrow/stream/421156-gsoc/topic/Idea.3A.20extend.20annotate-snippets)\n*   [Compiler team](https://rust-lang.zulipchat.com/#narrow/stream/131828-t-compiler)\n\n### Reproducible builds\n\n[](https://github.com/rust-lang/google-summer-of-code#reproducible-builds)\n\n**Description**\n\nRecent OSS attacks such as the [XZ backdoor](https://en.wikipedia.org/wiki/XZ_Utils_backdoor) have shown the importance of having reproducible builds.\n\nCurrently, the Rust toolchain distributed to Rust developers is not very reproducible. Our source code archives should be reproducible as of [this pull request](https://github.com/rust-lang/rust/pull/123246), however making the actual binary artifacts reproducible is a much more difficult effort.\n\nThe goal of this project is to investigate what exactly makes Rust builds not reproducible, and try to resolve as many such issues as possible.\n\nWhile the main motivation is to make the Rust toolchain (compiler, standard library, etc.) releases reproducible, any improvements on this front should benefit the reproducibility of all Rust programs.\n\nSee [Tracking Issue for Reproducible Build bugs and challenges](https://github.com/rust-lang/rust/issues/129080) for a non-exhaustive list of reproducibility challenges.\n\n**Expected result**\n\nRust builds are more reproducible, ideally the Rust toolchain can be compiled in a reproducible manner.\n\n**Desirable skills**\n\nKnowledge of Rust and ideally also build systems.\n\n**Project size**\n\nMedium.\n\n**Difficulty**\n\nHard.\n\n**Mentor**\n\n*   Jakub BerÃ¡nek ([GitHub](https://github.com/kobzol), [Zulip](https://rust-lang.zulipchat.com/#narrow/dm/266526-Jakub-Ber%C3%A1nek))\n\n**Related links**\n\n*   [Idea discussion](https://rust-lang.zulipchat.com/#narrow/channel/421156-gsoc/topic/Idea.3A.20reproducible.20builds)\n*   [Prior art in Go](https://go.dev/blog/rebuild)\n\n### Bootstrap of rustc with `rustc_codegen_gcc`\n\n[](https://github.com/rust-lang/google-summer-of-code#bootstrap-of-rustc-with-rustc_codegen_gcc)\n\n**Description**\n\n[`rustc_codegen_gcc`](https://github.com/rust-lang/rustc_codegen_gcc) [used to be able to compile `rustc`](https://blog.antoyo.xyz/rustc_codegen_gcc-progress-report-10) and use the resulting compiler to successfully compile a `Hello, World!` program. While it can still compile a [stage 2](https://rustc-dev-guide.rust-lang.org/building/bootstrapping/what-bootstrapping-does.html#stage-2-the-truly-current-compiler) `rustc`, the resulting compiler cannot compile the standard library anymore.\n\nThe goal of this project would be to fix in `rustc_codegen_gcc` any issue preventing the resulting compiler to compile a `Hello, World!` program and the standard library. Those issues are not known, so the participant would need to attempt to do a bootstrap and investigate the issues that arises.\n\nIf time allows, an optional additional goal could be to be able to do a full bootstrap of `rustc` with `rustc_codegen_gcc`, meaning fixing even more issues to achieve this result.\n\n**Expected result**\n\nA `rustc_codegen_gcc` that can compile a stage 2 `rustc` where the resulting compiler can compile a `Hello, World!` program using the standard library (also compiled by that resulting compiler).\n\nAn optional additional goal would be: a `rustc_codegen_gcc` that can do a full bootstrap of the Rust compiler. This means getting a stage 3 `rustc` that is identical to stage 2.\n\n**Desirable skills**\n\nGood debugging ability. Basic knowledge of:\n\n*   Intel x86-64 assembly (for debugging purposes).\n*   `rustc` internals, especially the [codegen part](https://rustc-dev-guide.rust-lang.org/backend/backend-agnostic.html).\n*   [`libgccjit`](https://gcc.gnu.org/onlinedocs/jit/) and [GCC internals](https://gcc.gnu.org/onlinedocs/gccint/).\n\n**Project size**\n\nMedium-Large depending on the chosen scope.\n\n**Difficulty**\n\nHard.\n\n**Mentor**\n\n*   Antoni Boucher ([GitHub](https://github.com/antoyo), [Zulip](https://rust-lang.zulipchat.com/#narrow/dm/404242-antoyo))\n\n**Zulip streams**\n\n*   [Idea discussion](https://rust-lang.zulipchat.com/#narrow/channel/421156-gsoc/topic/Idea.3A.20Bootstrap.20of.20rustc.20with.20.60rustc_codegen_gcc.60)\n*   [rustc\\_codegen\\_gcc](https://rust-lang.zulipchat.com/#narrow/channel/386786-rustc-codegen-gcc/)\n\n### Refactoring of `rustc_codegen_ssa` to make it more convenient for the GCC codegen\n\n[](https://github.com/rust-lang/google-summer-of-code#refactoring-of-rustc_codegen_ssa-to-make-it-more-convenient-for-the-gcc-codegen)\n\n**Description**\n\n[`rustc_codegen_gcc`](https://github.com/rust-lang/rustc_codegen_gcc) uses [`rustc_codegen_ssa`](https://rustc-dev-guide.rust-lang.org/backend/backend-agnostic.html) and implements the traits in this crate in order to have a codegen that plugs in `rustc` seamlessly. Since `rustc_codegen_ssa` was created based on `rustc_codegen_llvm`, they are somewhat similar, which sometimes makes it awkward for the GCC codegen. Indeed, some hacks were needed to be able to implement the GCC codegen with this API:\n\n*   Usage of unsafe `transmute`: for instance, [this](https://github.com/rust-lang/rustc_codegen_gcc/blob/8037b6139fea50894978509744f00484150e6816/src/context.rs#L322) or [this](https://github.com/rust-lang/rustc_codegen_gcc/blob/8037b6139fea50894978509744f00484150e6816/src/context.rs#L412). Fixing this might require separating [`Value`](https://github.com/antoyo/rust/blob/c074d8eee765cfd64e6e143d2894c85c7f3ddc1d/compiler/rustc_codegen_ssa/src/traits/backend.rs#L24) into `RValue` and `LValue` or using [`Function`](https://github.com/antoyo/rust/blob/c074d8eee765cfd64e6e143d2894c85c7f3ddc1d/compiler/rustc_codegen_ssa/src/traits/backend.rs#L26) in place of `Value` in some places to better fit the GCC API.\n*   Usage of mappings to workaround the API: for instance, [this](https://github.com/rust-lang/rustc_codegen_gcc/blob/8037b6139fea50894978509744f00484150e6816/src/context.rs#L123-L128) or [this](https://github.com/rust-lang/rustc_codegen_gcc/blob/8037b6139fea50894978509744f00484150e6816/src/context.rs#L95-L99).\n\nSome other improvement ideas include:\n\n*   Separate the aggregate operations (structs, arrays): methods like [`extract_value`](https://github.com/rust-lang/rustc_codegen_gcc/blob/8037b6139fea50894978509744f00484150e6816/src/builder.rs#L1423) are generic over structures and arrays because it's the same operation in LLVM, but it is different operations in GCC, so it might make sense to have multiple methods like `extract_field` and `extract_array_element`.\n*   Remove duplications between `rustc_codegen_gcc` and `rustc_codegen_llvm` by moving more stuff into `rustc_codegen_ssa`. For instance:\n    *   [some debuginfo code is exactly the same](https://github.com/rust-lang/rustc_codegen_gcc/blob/8037b6139fea50894978509744f00484150e6816/src/debuginfo.rs#L63)\n    *   [ABI code](https://github.com/rust-lang/rustc_codegen_gcc/blob/8037b6139fea50894978509744f00484150e6816/src/intrinsic/mod.rs#L509-L569)\n    *   [the allocator code](https://github.com/rust-lang/rustc_codegen_gcc/blob/8037b6139fea50894978509744f00484150e6816/src/allocator.rs#L16-L91)\n    *   [the dummy output type for inline assembly](https://github.com/rust-lang/rustc_codegen_gcc/blob/8037b6139fea50894978509744f00484150e6816/src/asm.rs#L704-L793)\n    *   perhaps we could add a `set_alignment` method in `rustc_codegen_ssa` that asks the backend to set the alignment and is called in `rustc_codegen_ssa` in strategic places so that we don't have to worry as much about alignment in the codegens (not sure if this is possible).\n\nThe goal of this project is to improve `rustc_codegen_gcc` by removing hacks, unnecessary unsafe code and/or code duplication with `rustc_codegen_llvm` by refactoring `rustc_codegen_ssa`. It would be important that this refactoring does not result in a performance degradation for `rustc_codegen_llvm`.\n\n**Expected result**\n\nA `rustc_codegen_gcc` that contains less hacks, unsafe code and/or code duplication with `rustc_codegen_llvm`.\n\n**Desirable skills**\n\nKnowledge of Rust and basic knowledge of `rustc` internals, especially the [codegen part](https://rustc-dev-guide.rust-lang.org/backend/backend-agnostic.html).\n\n**Project size**\n\nSmall-Medium depending on the chosen scope.\n\n**Difficulty**\n\nMedium.\n\n**Mentor**\n\n*   Antoni Boucher ([GitHub](https://github.com/antoyo), [Zulip](https://rust-lang.zulipchat.com/#narrow/dm/404242-antoyo))\n\n**Zulip streams**\n\n*   [Idea discussion](https://rust-lang.zulipchat.com/#narrow/channel/421156-gsoc/topic/Idea.3A.20Refactoring.20of.20.60rustc_codegen_ssa.60.20for.20cg_gcc)\n*   [rustc\\_codegen\\_gcc](https://rust-lang.zulipchat.com/#narrow/channel/386786-rustc-codegen-gcc/)\n\n### ABI/Layout handling for the automatic differentiation feature\n\n[](https://github.com/rust-lang/google-summer-of-code#abilayout-handling-for-the-automatic-differentiation-feature)\n\n**Description**\n\nOver the last year, support for automatic differentiation ('autodiff') was added to the Rust compiler. The autodiff tool which we are using ([Enzyme](https://enzyme.mit.edu/)) operates on LLVM-IR, which is the intermediate representation of code, used by LLVM. LLVM is the default backend of the Rust compiler. Unfortunately, two layout related problems limit its usability.\n\nA) The Rust compiler has a set of ABI optimizations which can improve performance, but make it harder for autodiff to work. An example is the function `fn foo(a: f32, b: f32) -> f32`, which the compiler might optimize to `fn foo(x: i64) -> f32`. While this is fine from an LLVM perspective, it makes it hard for Enzyme, the LLVM based autodiff tool. More information about such optimizations can be found [here](https://rust-lang.zulipchat.com/#narrow/channel/182449-t-compiler.2Fhelp/topic/.E2.9C.94.20Where.20do.20ABI.20.22changes.22.20happen.3F). If a function has a `#[rustc_autodiff]` attribute, the Rust compiler should simply not perform such optimizations. We don't want to disable these optimizations for all functions, as they are generally beneficial. Multiple examples of function headers which will get handled incorrectly at the moment are listed [here](https://github.com/EnzymeAD/rust/issues/105).\n\nB) Enzyme requires good information about the memory layout of types, both to be able to differentiate the code, and to do so efficiently. In order to help Enzyme, we want to lower more Type Information from MIR or even THIR into LLVM-IR metadata, or make better usage of existing debug info. If you are interested in this part and also have some LLVM experience, please have a look at the LLVM website for the related proposal.\n\nFor both A) and B), the online compiler explorer [here](https://enzyme.mit.edu/explorer/) can be used to trigger both types of bugs, to get a feeling for existing problems.\n\n**Expected result**\n\nThe Rust compiler should not perform ABI optimizations on functions with the `#[rustc_autodiff]` attribute. As a result, `#[autodiff(..)]` should be able to handle functions with almost arbitrary headers. If a general solution turns out tricky, it is ok to focus on the most common types like those listed in the issue above (e.g. combinations of floats, small arrays/structs/tuples, etc.). We care less about advanced types like those listed [here](https://doc.rust-lang.org/reference/special-types-and-traits.html). These changes can't have a performance impact on functions without the `#[rustc_autodiff]` attribute.\n\nNewly working testcases should be added to the rust test suite. The `rustc_autodiff` parsing in the [autodiff frontend](https://github.com/rust-lang/rust/pull/129458) might need small bugfixes if the new testcases discover additional bugs, but those can also be solved by other contributors.\n\nExamples for code that currently is not handled correctly can be discussed in the project proposal phase.\n\n**Desirable skills**\n\nIntermediate knowledge of Rust. Familiarity with ABIs is a bonus, but not required.\n\n**Project size**\n\nMedium\n\n**Difficulty**\n\nMedium to hard.\n\n**Mentor**\n\n*   Manuel Drehwald ([GitHub](https://github.com/zusez4), [Zulip](https://rust-lang.zulipchat.com/#narrow/dm/348574-Manuel-Drehwald))\n*   Oli ([GitHub](https://github.com/oli-obk), [Zulip](https://rust-lang.zulipchat.com/#narrow/dm/124288-oli))\n\n**Zulip streams**\n\n*   [Idea discussion](https://rust-lang.zulipchat.com/#narrow/channel/421156-gsoc/topic/Idea.3A.20ABI.2FLayout.20handling.20for.20automatic.20differentiation)\n*   [Automatic differentiation working group](https://rust-lang.zulipchat.com/#narrow/channel/390790-wg-autodiff)\n\n### Improving parallel frontend\n\n[](https://github.com/rust-lang/google-summer-of-code#improving-parallel-frontend)\n\n**Description**\n\nImproving compiler performance has always been a focus of the Rust community and one of the main tasks of the compiler team. [Parallelization](https://rustc-dev-guide.rust-lang.org/parallel-rustc.html) of rust compiler is an important and effective approach. Currently, the backend end (codegen part) of the compiler has been parallelized, which has brought a huge improvement in the performance of the compiler. However, there is still much room for improvement in the parallelization of the rust frontend.\n\nThe most important and valuable work in this area are two aspects:\n\nA) Diagnosing and fixing deadlock [issues](https://github.com/rust-lang/rust/issues?q=is%3Aopen+label%3AWG-compiler-parallel+deadlock) caused by the execution order of compiler queries in a multithreaded environment. [Queries](https://rustc-dev-guide.rust-lang.org/query.html) is a unique design of the Rust compiler, which is used to achieve incremental compilation process. It divides the compiler process into various parts and caches the execution results of each part. However, queries caching dependencies between multiple threads may cause deadlock. [`Work-stealing`](https://en.wikipedia.org/wiki/Work_stealing), a method used to improve parallelization performance, is the core reason.\n\nTo solve these problems, we need to find the part of the compiler process that causes deadlock through diagnosing coredumps in issues, and adjusting the execution order of this part of code so that there will be no circular dependencies on the query caches between multiple threads. This [PR](https://github.com/rust-lang/rust/pull/118488) is a good example of solving a deadlock problem.\n\nB) Improving the performance of the parallel frontend The parallel frontend has implemented parallelization in type checking, MIR borrow checking and other parts of the compiler. However, there is still a lot of room for improvement:\n\n*   HIR lowering. Modifying the array structure of `tcx.untracked.definitions` so that it can be accessed efficiently in multiple threads is likely to be the key.\n*   Macro expansion. How to deal with the order problem of name resolution during macro expansion is a difficult problem.\n*   Lexing and/or parsing.\n\nAchieving the above goals is of big significance to improving the performance of the Rust compiler.\n\nThe project could choose either one of these two areas, or try to tackle both of them together.\n\n**Expected result**\n\nParallel frontend will not cause deadlock issues. We can ensure usability through [UI testing](https://github.com/rust-lang/rust/pull/132051).\n\nThe performance of the compiler will be improved, ideally at least by a couple of percentage points.\n\n**Desirable skills**\n\nIntermediate knowledge of Rust. A basic understanding of the implementation of the compiler process (such as typeck, hir\\_lowering, macro expansion) would be ideal.\n\n**Project size**\n\nMedium to hard (depending on the chosen scope).\n\n**Difficulty**\n\nMedium to hard.\n\n**Mentor**\n\n*   Sparrow Li ([GitHub](https://github.com/SparrowLii), [Zulip](https://rust-lang.zulipchat.com/#narrow/dm/353056-Sparrow-Li))\n\n**Zulip streams**\n\n*   [Idea discussion](https://rust-lang.zulipchat.com/#narrow/channel/421156-gsoc/topic/Idea.3A.20Improving.20parallel.20frontend)\n*   [Parallel frontend working group](https://rust-lang.zulipchat.com/#narrow/channel/187679-t-compiler.2Fwg-parallel-rustc)\n*   [Parallel frontend project goal](https://rust-lang.github.io/rust-project-goals/2025h1/parallel-front-end.html)\n\n### C codegen backend for `rustc`\n\n[](https://github.com/rust-lang/google-summer-of-code#c-codegen-backend-for-rustc)\n\n**Description**\n\n`rustc` currently has three in-tree codegen backends: LLVM (the default), Cranelift, and GCC. These live at [https://github.com/rust-lang/rust/tree/master/compiler](https://github.com/rust-lang/rust/tree/master/compiler), as `rustc_codegen_*` crates.\n\nThe goal of this project is to add a new experimental `rustc_codegen_c` backend that could turn Rust's internal representations into `C` code (i.e. transpile) and optionally invoke a `C` compiler to build it. This will allow Rust to use benefits of existing `C` compilers (better platform support, optimizations) in situations where the existing backends cannot be used.\n\n**Expected result**\n\nThe minimum viable product is to turn `rustc` data structures that represent a Rust program into `C` code, and write the output to the location specified by `--out-dir`. This involves figuring out how to produce buildable `C` code from the inputs provided by `rustc_codegen_ssa::traits::CodegenBackend`.\n\nA second step is to have `rustc` invoke a `C` compiler on these produced files. This should be designed in a pluggable way, such that any `C` compiler can be dropped in.\n\n**Desirable skills**\n\nKnowledge of Rust and `C`, basic familiarity with compiler functionality.\n\n**Project size**\n\nLarge.\n\n**Difficulty**\n\nHard.\n\n**Mentor**\n\n*   Trevor Gross ([GitHub](https://github.com/tgross35), [Zulip](https://rust-lang.zulipchat.com/#narrow/dm/532317-Trevor-Gross))\n\n**Zulip streams**\n\n*   [Idea discussion](https://rust-lang.zulipchat.com/#narrow/stream/421156-gsoc/topic/Idea.3A.20C.20codegen.20backend.20for.20.60rustc.60)\n*   [Compiler team](https://rust-lang.zulipchat.com/#narrow/stream/131828-t-compiler)\n*   [Previous discussion about this topic](https://rust-lang.zulipchat.com/#narrow/stream/122651-general/topic/rustc_codegen_c)\n\nRust standard library\n---------------------\n\n[](https://github.com/rust-lang/google-summer-of-code#rust-standard-library)\n\n### Extend testing of `std::arch` intrinsics\n\n[](https://github.com/rust-lang/google-summer-of-code#extend-testing-of-stdarch-intrinsics)\n\n**Description**\n\nThe [`std::arch`](https://doc.rust-lang.org/nightly/std/arch/index.html) module in the standard library provides architecture-specific intrinsic functions, which typically directly map to a single machine instruction.\n\nThese intrinsics are based on the architecture-specific intrinsics in C, which are usually based on a vendor specification and then implemented by C compilers such as Clang or GCC.\n\nRust supports thousands of intrinsics and we need to verify that they match the behavior of the equivalent intrinsics in C. A first step towards this has been the [`intrinsic-test`](https://github.com/rust-lang/stdarch/tree/master/crates/intrinsic-test) which fuzz tests the ARM (AArch32 and AArch64) intrinsics by generating C and Rust programs which call the intrinsics with random data and then verifying that the output is the same in both programs.\n\nWhile this covers the ARM architectures, we have thousands of intrinsics for other architectures (notably x86) which are only lightly tested with manual tests. The goal of this project is to extend `intrinsic-test` to other architectures: x86, PowerPC, LoongArch, etc.\n\n**Expected result**\n\nBy the end of this project `intrinsic-test` should be able to validate the behavior of intriniscs on multiple architectures. The primary goal is to support x86 since this is the most widely used architecture, but stretch goals could include support for other architectures such as PowerPC, LoongArch, WebAssembly, etc.\n\n**Desirable skills**\n\nIntermediate knowledge of Rust and C. Knowledge of intrinsics or assembly is useful but not required.\n\n**Project size**\n\nSmall to Medium.\n\n**Difficulty**\n\nMedium.\n\n**Mentors**\n\n*   Amanieu d'Antras ([GitHub](https://github.com/Amanieu), [Zulip](https://rust-lang.zulipchat.com/#narrow/dm/143274-Amanieu-d'Antras))\n\n**Zulip streams**\n\n*   [Idea discussion](https://rust-lang.zulipchat.com/#narrow/channel/421156-gsoc/topic/Idea.3A.20Extend.20testing.20of.20.60std.3A.3Aarch.60.20intrinsics)\n*   [t-libs/stdarch](https://rust-lang.zulipchat.com/#narrow/channel/208962-t-libs.2Fstdarch)\n\nInfrastructure\n--------------\n\n[](https://github.com/rust-lang/google-summer-of-code#infrastructure)\n\n### Implement merge functionality in bors\n\n[](https://github.com/rust-lang/google-summer-of-code#implement-merge-functionality-in-bors)\n\n**Description**\n\nVarious Rust repositories under the [rust-lang](https://github.com/rust-lang) organization use a merge queue bot (bors) for testing and merging pull requests. Currently, we use a legacy implementation called [homu](https://github.com/rust-lang/homu), which is quite buggy and very difficult to maintain, so we would like to get rid of it. We have started the implementation of a new bot called simply [bors](https://github.com/rust-lang/bors), which should eventually become the primary method for merging pull requests in the [rust-lang/rust](https://github.com/rust-lang/rust) repository.\n\nThe bors bot is a GitHub app that responds to user commands and performs various operations on a GitHub repository. Primarily, it creates merge commits and reports test workflow results for them. It can currently perform so-called \"try builds\", which can be started manually by users on a given PR to check if a subset of CI passed on the PR. However, the most important functionality, actually merging pull requests into the main branch, has not been implemented yet.\n\n**Expected result**\n\nbors can be used to perform pull request merges, including \"rollups\". In an ideal case, bors will be already usable on the `rust-lang/rust` repository.\n\n**Desirable skills**\n\nIntermediate knowledge of Rust. Familiarity with GitHub APIs is a bonus.\n\n**Project size**\n\nMedium.\n\n**Difficulty**\n\nMedium.\n\n**Mentors**\n\n*   Jakub BerÃ¡nek ([GitHub](https://github.com/kobzol), [Zulip](https://rust-lang.zulipchat.com/#narrow/dm/266526-Jakub-Ber%C3%A1nek))\n\n**Zulip streams**\n\n*   [Idea discussion](https://rust-lang.zulipchat.com/#narrow/stream/421156-gsoc/topic/Idea.3A.20improve.20infrastructure.20automation.20tools)\n*   [Infra team](https://rust-lang.zulipchat.com/#narrow/stream/242791-t-infra)\n\n### Improve bootstrap\n\n[](https://github.com/rust-lang/google-summer-of-code#improve-bootstrap)\n\n**Description**\n\nThe Rust compiler it bootstrapped using a complex set of scripts and programs generally called just `bootstrap`. This tooling is constantly changing, and it has accrued a lot of technical debt. It could be improved in many areas, for example:\n\n*   Design a new testing infrastructure and write more tests.\n*   Write documentation.\n*   Remove unnecessary hacks.\n\n**Expected result**\n\nThe `bootstrap` tooling will have less technical debt, more tests, and better documentation.\n\n**Desirable skills**\n\nIntermediate knowledge of Rust. Knowledge of the Rust compiler bootstrap process is welcome, but not required.\n\n**Project size**\n\nMedium or large.\n\n**Difficulty**\n\nMedium.\n\n**Mentor**\n\n*   AlbertLarsan68 ([GitHub](https://github.com/albertlarsan68), [Zulip](https://rust-lang.zulipchat.com/#narrow/dm/510016-Albert-Larsan))\n\n**Zulip streams**\n\n*   [Idea discussion](https://rust-lang.zulipchat.com/#narrow/stream/421156-gsoc/topic/Idea.3A.20improve.20bootstrap)\n*   [Bootstreap team](https://rust-lang.zulipchat.com/#narrow/stream/326414-t-infra.2Fbootstrap)\n\n### Port `std::arch` test suite to `rust-lang/rust`\n\n[](https://github.com/rust-lang/google-summer-of-code#port-stdarch-test-suite-to-rust-langrust)\n\n**Description**\n\nThe [`std::arch`](https://doc.rust-lang.org/nightly/std/arch/index.html) module in the standard library provides architecture-specific intrinsic functions, which typically directly map to a single machine instruction.\n\nCurrently, it lives in its own [repository](https://github.com/rust-lang/stdarch) outside the main [Rust compiler repository](https://github.com/rust-lang/rust) (`rustc`). The `rustc` repository includes `stdarch` only as a submodule, and does not execute its testsuite on the compiler's CI. This sometimes causes contributor friction, because updates to the compiler can break `stdarch` (and vice versa) and it is not possible to change both the compiler and `stdarch` at once (in the same pull request).\n\n`stdarch` has a comprehensive test suite that tests the intrinsics on several hardware architectures and operating system platforms, and it also includes fuzz tests. It cannot be simply copied over to `rustc`, because that has its own (much more complex) set of CI workflows. The `stdarch` testsuite thus has to be adapted to the way workflows are executed in the compiler repository.\n\nThe ultimate goal is to inline `stdarch` into `rustc` completely, and archive the `stdarch` repository. This can be incrementally achieved by the following two steps:\n\n1.  Investigate the CI (continuous integration) test suite of `stdarch`, and port as much of it into `rustc`. This will involve implementing new testing and documentation steps for working with `stdarch` in the compiler's build system, [bootstrap](https://rustc-dev-guide.rust-lang.org/building/bootstrapping/how-bootstrap-does-it.html).\n2.  Once a sufficient portion of the test suite has been ported, `stdarch` should be changed from a submodule to either a git or [Josh](https://josh-project.github.io/josh) subtree, so that compiler contributors are able to make changes to `stdarch` when they modify the compiler. This might involve creating some automation tooling to help with performing regular synchronizations from/to `stdarch`. See [this page](https://rustc-dev-guide.rust-lang.org/external-repos.html#using-external-repositories) for more details.\n\n**Expected result**\n\nThe most important parts of the `stdarch` test suite should be running in the CI of the Rust compiler. Ideally, `stdarch` should be included as a git/Josh subtree instead of a submodule, or in the best possible scenario moved completely into `rust-lang/rust`.\n\n**Desirable skills**\n\nIntermediate knowledge of Rust. Experience with GitHub Actions or CI workflows is a benefit.\n\n**Project size**\n\nSmall to Medium.\n\n**Difficulty**\n\nMedium.\n\n**Mentors**\n\n*   Jakub BerÃ¡nek ([GitHub](https://github.com/kobzol), [Zulip](https://rust-lang.zulipchat.com/#narrow/dm/266526-Jakub-Ber%C3%A1nek))\n\n**Zulip streams**\n\n*   [Idea discussion](https://rust-lang.zulipchat.com/#narrow/channel/421156-gsoc/topic/Idea.3A.20Port.20.60std.3A.3Aarch.60.20test.20suite.20to.20.60rust-lang.2Frust.60)\n*   [t-libs/stdarch](https://rust-lang.zulipchat.com/#narrow/channel/208962-t-libs.2Fstdarch)\n\nCargo\n-----\n\n[](https://github.com/rust-lang/google-summer-of-code#cargo)\n\n### Prototype an alternative architecture for `cargo fix`\n\n[](https://github.com/rust-lang/google-summer-of-code#prototype-an-alternative-architecture-for-cargo-fix)\n\n**Description**\n\nSome compiler errors know how to fix the problem and `cargo fix` is the command for applying those fixes. Currently, `cargo fix` calls into the APIs that implement `cargo check` with `cargo` in a way that allows getting the json messages from rustc and apply them to workspace members. To avoid problems with conflicting or redundant fixes, `cargo fix` runs `rustc` for workspace members in serial. As one fix might lead to another, `cargo fix` runs `rustc` for each workspace member in a loop until a fixed point is reached. This can be very slow for large workspaces.\n\nWe want to explore an alternative architecture where `cargo fix` runs the `cargo check` command in a loop, processing the json messages, until a fixed point is reached.\n\nBenefits\n\n*   Always runs in parallel\n*   May make it easier to extend the behavior, like with an interactive mode\n\nDownsides\n\n*   Might have issues with files owned by multiple packages or even multiple build targets\n\nThis can leverage existing CLI and crate APIs of Cargo and can be developed as a third-party command.\n\nSee [cargo#13214](https://github.com/rust-lang/cargo/issues/13214) for more details.\n\n**Expected result**\n\n*   A third-party command as described above\n*   A comparison of performance across representative crates\n*   An analysis of corner the behavior with the described corner cases\n\n**Desirable skills**\n\nIntermediate knowledge of Rust.\n\n**Project size**\n\nMedium\n\n**Difficulty**\n\nMedium.\n\n**Mentor**\n\n*   Ed Page ([GitHub](https://github.com/epage), [Zulip](https://rust-lang.zulipchat.com/#narrow/dm/424212-Ed-Page))\n\n**Zulip streams**\n\n*   [Idea discussion](https://rust-lang.zulipchat.com/#narrow/channel/421156-gsoc/topic/Idea.3A.20Prototype.20an.20alternative.20architecture.20for.20.60cargo.20fix.60)\n*   [Cargo team](https://rust-lang.zulipchat.com/#narrow/stream/246057-t-cargo)\n\n### Prototype Cargo plumbing commands\n\n[](https://github.com/rust-lang/google-summer-of-code#prototype-cargo-plumbing-commands)\n\n**Description**\n\nCargo is a high-level, opinionated command. Instead of trying to directly support every use case, we want to explore exposing the building blocks of the high-level commands as \"plumbing\" commands that people can use programmatically to compose together to create custom Cargo behavior.\n\nThis can be prototyped outside of the Cargo code base, using the Cargo API.\n\nSee the [Project Goal](https://rust-lang.github.io/rust-project-goals/2025h1/cargo-plumbing.html) for more details.\n\n**Expected result**\n\nIdeal: a performant `cargo porcelain check` command that calls out to individual `cargo plumbing <name>` commands to implement its functionality.\n\nDepending on the size the particpant takes on and their experience, this may be out of reach. The priorities are:\n\n1.  A shell of `cargo porcelain check`\n2.  Individual commands until `cargo porcelain check` is functional\n3.  Performance\n\n**Desirable skills**\n\nIntermediate knowledge of Rust.\n\n**Project size**\n\nScaleable\n\n**Difficulty**\n\nMedium.\n\n**Mentor**\n\n*   Ed Page ([GitHub](https://github.com/epage), [Zulip](https://rust-lang.zulipchat.com/#narrow/dm/424212-Ed-Page))\n\n**Zulip streams**\n\n*   [Idea discussion](https://rust-lang.zulipchat.com/#narrow/channel/421156-gsoc/topic/Idea.3A.20Prototype.20Cargo.20plumbing.20commands)\n*   [Cargo team](https://rust-lang.zulipchat.com/#narrow/stream/246057-t-cargo)\n\n### Move cargo shell completions to Rust\n\n[](https://github.com/rust-lang/google-summer-of-code#move-cargo-shell-completions-to-rust)\n\n**Description**\n\nCargo maintains Bash and Zsh completions, but they are duplicated and limited in features.\n\nA previous GSoC participant added unstable support for completions in Cargo itself, so we can have a single implementation with per-shell skins ([rust-lang/cargo#6645](https://github.com/rust-lang/cargo/issues/6645)).\n\n*   [**Final project report**](https://hackmd.io/@PthRWaPvSmS_2Yu_GLbGpg/Hk-ficKpC)\n*   [GSoC project annotation](https://summerofcode.withgoogle.com/programs/2024/projects/jjnidpgn)\n*   [Project discussion on Zulip](https://rust-lang.zulipchat.com/#narrow/stream/421156-gsoc/topic/Project.3A.20Move.20cargo.20shell.20completions.20to.20Rust)\n\nThere are many more arguments that need custom completers as well as polish in the completion system itself before this can be stabilized.\n\nSee\n\n*   [Clap's tracking issue](https://github.com/clap-rs/clap/issues/3166)\n*   [Cargo's tracking issue](https://github.com/rust-lang/cargo/issues/14520)\n\n**Expected result**\n\nIdeal:\n\n*   A report to clap maintainers on the state of the unstable completions and why its ready for stabilization\n*   A report to cargo maintainers on the state of the unstable completions and why its ready for stabilization\n\n**Desirable skills**\n\nIntermediate knowledge of Rust. Shell familiarity is a bonus.\n\n**Project size**\n\nMedium.\n\n**Difficulty**\n\nMedium.\n\n**Mentor**\n\n*   [Idea discussion](https://rust-lang.zulipchat.com/#narrow/channel/421156-gsoc/topic/Idea.3A.20move.20cargo.20shell.20completions.20to.20Rust)\n*   Ed Page ([GitHub](https://github.com/epage), [Zulip](https://rust-lang.zulipchat.com/#narrow/dm/424212-Ed-Page))\n\n### Build script delegation\n\n[](https://github.com/rust-lang/google-summer-of-code#build-script-delegation)\n\n**Description**\n\nWhen developers need to extend how Cargo builds their package, they can write a [build script](https://doc.rust-lang.org/cargo/reference/build-scripts.html). This gives users quite a bit of flexibility but\n\n*   Allows running arbitrary code on the users system, requiring extra auditing\n*   Needs to be compiled and run before the relevant package can be built\n*   They are all-or-nothing, requiring users to do extra checks to avoid running expensive logic\n*   They run counter to the principles of third-party build tools that try to mimic Cargo\n\nA developer could make their build script a thin wrapper around a library (e.g. [shadow-rs](https://crates.io/crates/shadow-rs)) but a build script still exists to be audited (even if its small) and each individual wrapper build script must be compiled and linked. This is still opaque to third-party build tools.\n\nLeveraging an unstable feature, [artifact dependencies](https://doc.rust-lang.org/nightly/cargo/reference/unstable.html#artifact-dependencies), we could allow a developer to say that one or more dependencies should be run as build scripts, passing parameters to them.\n\nThis project would add unstable support for build script delegation that can then be evaluated for proposing as an RFC for approval.\n\nSee [the proposal](https://github.com/rust-lang/cargo/issues/14903#issuecomment-2523803041) for more details.\n\n**Expected result**\n\nMilestones\n\n1.  An unstable feature for multiple build scripts\n2.  An unstable feature for passing parameters to build scripts from `Cargo.toml`, built on the above\n3.  An unstable feature for build script delegation, built on the above two\n\nBonus: preparation work to stabilize a subset of artifact dependencies.\n\n**Desirable skills**\n\nIntermediate knowledge of Rust, especially experience with writing build scripts.\n\n**Project size**\n\nLarge.\n\n**Difficulty**\n\nMedium.\n\n**Mentor**\n\n*   [Idea discussion](https://rust-lang.zulipchat.com/#narrow/channel/421156-gsoc/topic/Idea.3A.20Build.20script.20delegation)\n*   Ed Page ([GitHub](https://github.com/epage), [Zulip](https://rust-lang.zulipchat.com/#narrow/dm/424212-Ed-Page))\n\nrust-analyzer\n-------------\n\n[](https://github.com/rust-lang/google-summer-of-code#rust-analyzer)\n\n### Implement a new proc-macro server RPC API\n\n[](https://github.com/rust-lang/google-summer-of-code#implement-a-new-proc-macro-server-rpc-api)\n\n**Description**\n\nToday, rust-analyzer (and RustRover) expands proc-macros by spawning a separate proc-macro server process that loads and executes the proc-macro dynamic libraries. They communicate to this process via a JSON RPC interface that has not been given much thought when it was implemented, now starting to show its limitations.\n\nThe goal is to replace this current implementation entirely in favor of a more performant format that also supports the more complicated needs of the proc-macro API, outlined in [rust-lang/rust-analyzer#19205](https://github.com/rust-lang/rust-analyzer/issues/19205).\n\n**Expected result**\n\nThere exists a new proc-macro server that is more efficient and allows for implementing the remaining proc-macro API. Ideally, it should be integrated within rust-analyzer.\n\n**Desirable skills**\n\nIntermediate knowledge of Rust.\n\n**Project size**\n\nMedium.\n\n**Difficulty**\n\nMedium.\n\n**Mentor**\n\n*   Lukas Wirth ([GitHub](https://github.com/veykril), [Zulip](https://rust-lang.zulipchat.com/#narrow/dm/300586-Lukas-Wirth))\n\n**Zulip streams**\n\n*   [Idea discussion](https://rust-lang.zulipchat.com/#narrow/channel/185405-t-compiler.2Frust-analyzer/topic/proc-macro.20server.20IPC.20format)\n*   [rust-analyzer team](https://rust-lang.zulipchat.com/#narrow/channel/185405-t-compiler.2Frust-analyzer)\n\nCrate ecosystem\n---------------\n\n[](https://github.com/rust-lang/google-summer-of-code#crate-ecosystem)\n\n### Modernize the libc crate\n\n[](https://github.com/rust-lang/google-summer-of-code#modernize-the-libc-crate)\n\n**Description**\n\nThe [libc](https://github.com/rust-lang/libc) crate is one of the oldest crates of the Rust ecosystem, long predating Rust 1.0. Additionally, it is one of the most widely used crates in the ecosystem (#4 most downloaded on crates.io). This combinations means that the current version of the libc crate (`v0.2`) is very conservative with breaking changes and remains backwards-compatible with all Rust compilers since Rust 1.13 (released in 2016).\n\nThe language has evolved a lot since Rust 1.13, and we would like to make use of these features in libc. The main one is support for `union` types to proper expose C unions.\n\nAt the same time there, is a backlog of desired breaking changes tracked in [this issue](https://github.com/rust-lang/libc/issues/3248). Some of these come from the evolution of the underlying platforms, some come from a desire to use newer language features, while others are simple mistakes that we cannot correct without breaking existing code.\n\nThe goal of this project is to prepare and release the next major version of the libc crate.\n\n**Expected result**\n\nThe libc crate is cleaned up and modernized, and released as version 0.3.\n\n**Desirable skills**\n\nIntermediate knowledge of Rust.\n\n**Project size**\n\nMedium.\n\n**Difficulty**\n\nMedium.\n\n**Mentor**\n\n*   Trevor Gross ([GitHub](https://github.com/tgross35), [Zulip](https://rust-lang.zulipchat.com/#narrow/dm/532317-Trevor-Gross))\n\n**Zulip streams**\n\n*   [Idea discussion](https://rust-lang.zulipchat.com/#narrow/stream/421156-gsoc/topic/Idea.3A.20modernize.20the.20libc.20crate)\n*   [Library team](https://rust-lang.zulipchat.com/#narrow/stream/219381-t-libs)\n\n### Add more lints to `cargo-semver-checks`\n\n[](https://github.com/rust-lang/google-summer-of-code#add-more-lints-to-cargo-semver-checks)\n\n**Description**\n\n[`cargo-semver-checks`](https://github.com/obi1kenobi/cargo-semver-checks) is a linter for semantic versioning. It ensures that Rust crates adhere to semantic versioning by looking for breaking changes in APIs.\n\nIt can currently catch ~120 different kinds of breaking changes, meaning there are hundreds of kinds of breaking changes it still cannot catch! The goal of this project is to extend its abilities, so that it can catch and prevent more breaking changes, by:\n\n*   adding more lints, which are expressed as queries over a database-like schema ([playground](https://play.predr.ag/rustdoc))\n*   extending the schema, so more Rust functionality is made available for linting\n\n**Expected result**\n\n`cargo-semver-checks` will contain new lints, together with test cases that both ensure the lint triggers when expected and does not trigger in situations where it shouldn't (AKA false-positives).\n\n**Desirable skills**\n\nIntermediate knowledge of Rust. Familiarity with databases, query engines, or query language design is welcome but not required.\n\n**Project size**\n\nMedium or large, depends on how many lints will be implemented. The more lints, the better!\n\n**Difficulty**\n\nMedium to high, depends on the choice of implemented lints or schema extensions.\n\n**Mentor**\n\n*   Predrag Gruevski ([GitHub](https://github.com/obi1kenobi/), [Zulip](https://rust-lang.zulipchat.com/#narrow/dm/474284-Predrag-Gruevski-(he-him)))\n\n**Zulip streams**\n\n*   [Idea discussion](https://rust-lang.zulipchat.com/#narrow/stream/421156-gsoc/topic/Idea.3A.20add.20more.20lints.20to.20.60cargo-semver-checks.60)\n\n**Related Links**\n\n*   [Playground where you can try querying Rust data](https://play.predr.ag/rustdoc)\n*   [GitHub issues describing not-yet-implemented lints](https://github.com/obi1kenobi/cargo-semver-checks/issues?q=is%3Aissue+is%3Aopen+label%3AE-mentor+label%3AA-lint+)\n*   [Opportunities to add new schema, enabling new lints](https://github.com/obi1kenobi/cargo-semver-checks/issues/241)\n*   [Query engine adapter](https://github.com/obi1kenobi/trustfall-rustdoc-adapter)\n\n### Make `cargo-semver-checks` run faster\n\n[](https://github.com/rust-lang/google-summer-of-code#make-cargo-semver-checks-run-faster)\n\n**Description**\n\nAs more lints get added to [`cargo-semver-checks`](https://github.com/obi1kenobi/cargo-semver-checks), its runtime grows longer. As a result, users' iteration loops and CI pipelines take longer as well, degrading the overall experience of using the tool.\n\nFigure out ways to speed up `cargo-semver-checks`, and find good ways to deploy them without degrading the maintainability of the codebase!\n\n**Expected result**\n\nThe wall-clock runtime of running `cargo-semver-checks` on a large Rust crate gets cut by 50-80%, while still running the same lints as before.\n\n**Desirable skills**\n\nInterest in and at least a bit of experience with performance engineering. Understanding of how to apply techniques like:\n\n*   profiling and benchmarking\n*   parallel programming (e.g. with `rayon`)\n*   building and applying indexes (in the database sense)\n\nStrong attention to detail. Willingness to learn quickly and perform lots of experiments, even though many of them may prove to be dead ends. Discipline and thoughtfulness when writing and testing code, to ensure that code changes are not merely _fast_ but also _maintainable_.\n\n**Project size**\n\nIdeally large, to have the biggest possible positive performance impact.\n\n**Difficulty**\n\nMedium to high. See the \"desirable skills\" section above.\n\n**Mentor**\n\n*   Predrag Gruevski ([GitHub](https://github.com/obi1kenobi/), [Zulip](https://rust-lang.zulipchat.com/#narrow/dm/474284-Predrag-Gruevski-(he-him)))\n\n**Zulip streams**\n\n*   [Idea discussion](https://rust-lang.zulipchat.com/#narrow/channel/421156-gsoc/topic/Idea.3A.20Make.20.60cargo-semver-checks.60.20run.20faster)\n\n**Related Links**\n\n*   [Playground where you can try querying Rust data](https://play.predr.ag/rustdoc)\n*   [Past optimization work: Speeding up Rust semver-checking by over 2000x](https://predr.ag/blog/speeding-up-rust-semver-checking-by-over-2000x/)\n*   [Conference talk: How Database Tricks Sped up Rust Linting Over 2000x](https://www.youtube.com/watch?v=Fqo8r4bInsk)\n*   [Query engine adapter, where many of the optimizations may be deployed](https://github.com/obi1kenobi/trustfall-rustdoc-adapter)\n\n### Enable witness generation in `cargo-semver-checks`\n\n[](https://github.com/rust-lang/google-summer-of-code#enable-witness-generation-in-cargo-semver-checks)\n\n**Description**\n\nWhen `cargo-semver-checks` reports a breaking change, it in principle has seen enough information for the breakage to be reproduced with an example program: a _witness_ program. Witness programs are valuable as they confirm that the suspected breakage did indeed happen, and is not a false-positive.\n\n**Expected result**\n\nAutomatic witness generation is something we've explored, but we've only scratched the surface at implementing it so far. The goal of this project would be to take it the rest of the way: enable `cargo-semver-checks` to (with the user's opt-in) generate witness programs for each lint, verify that they indeed demonstrate the detected breakage, and inform the user appropriately of the breakage and the manner in which it was confirmed. If a witness program _fails_ to reproduce breakage flagged by one of our lints, we've found a bug â€” the tool should then prepare a diagnostic info packet and offer to help the user open an auto-populated GitHub issue.\n\n**Stretch goal:** having implemented witness generation, run another study of SemVer compliance in the Rust ecosystem, similar to [the study we completed in 2023](https://predr.ag/blog/semver-violations-are-common-better-tooling-is-the-answer/). The new study would cover many more kinds of breaking changes, since `cargo-semver-checks` today has 2.5x times more lints than it did back then. It would also reveal any new false-positive issues, crashes, or other regressions that may have snuck into the tool in the intervening years.\n\n**Desirable skills**\n\nIntermediate knowledge of Rust. Interest in building dev tools, and empathy for user needs so we can design the best possible user experience. Familiarity with databases, query engines, or programming language design is welcome but not required.\n\n**Project size**\n\nLarge\n\n**Difficulty**\n\nMedium\n\n**Mentor**\n\n*   Predrag Gruevski ([GitHub](https://github.com/obi1kenobi/), [Zulip](https://rust-lang.zulipchat.com/#narrow/dm/474284-Predrag-Gruevski-(he-him)))\n\n**Zulip streams**\n\n*   [Idea discussion](https://rust-lang.zulipchat.com/#narrow/channel/421156-gsoc/topic/Idea.3A.20Enable.20witness.20generation.20in.20.60cargo-semver-checks.60)\n\n**Related Links**\n\n*   [Playground where you can try querying Rust data](https://play.predr.ag/rustdoc)\n*   [Use of witness programs to verify breaking change lints](https://predr.ag/blog/semver-violations-are-common-better-tooling-is-the-answer/#automated-validation-via-witnesses)\n\n### Wild linker with test suites from other linkers\n\n[](https://github.com/rust-lang/google-summer-of-code#wild-linker-with-test-suites-from-other-linkers)\n\n**Description**\n\nThe Wild linker is a project to build a very fast linker in Rust that has incremental linking and hot reload capabilities.\n\nIt currently works well enough to link itself, the Rust compiler, clang (provided you use the right compiler flags) and a few other things. However, there are various features and combinations of flags that donâ€™t yet work correctly. Furthermore, we have a pretty incomplete picture of what we donâ€™t support.\n\nThe proposed project is to run the test suite of other linkers with Wild as the linker being tested, then for each failure, determine what the problem is. Itâ€™s expected that many failures will have the same root cause.\n\n**Expected result**\n\nWrite a program, ideally in Rust, that runs the test suite of some other linker. Moldâ€™s test suite is pretty easy to run with Wild, so thatâ€™s probably a good default choice. The Rust program should emit a CSV file with one row per test, whether the test passes or fails and if it fails, an attempt to identify the cause based on errors / warnings emitted by Wild.\n\nFor tests where Wild doesnâ€™t currently emit any error or warning that is related to the cause of the test failure, attempt to make it do so. Some of the tests might fail for reasons that are hard to identify. Itâ€™s OK to just leave these as uncategorised. Where tests fail due to bugs or differences in behaviour of Wild, automatic classification likely isnâ€™t practical. A one-off classification of these would be beneficial.\n\nIf time permits, pick something achievable that seems like an important feature / bug to support / fix and implement / fix it.\n\n**Desirable skills**\n\nKnowledge of Rust. Any existing knowledge of low-level details like assembly or the ELF binary format is useful, but can potentially be learned as we go.\n\n**Project size**\n\nSmall to large depending on chosen scope.\n\n**Difficulty**\n\nSome of the work is medium. Diagnosing and / or fixing failures is often pretty hard.\n\n**Mentor**\n\n*   David Lattimore ([GitHub](https://github.com/davidlattimore), [Zulip](https://rust-lang.zulipchat.com/#narrow/dm/198560-David-Lattimore))\n\n**Zulip streams**\n\n*   [Idea discussion](https://rust-lang.zulipchat.com/#narrow/channel/421156-gsoc/topic/Idea.3A.20Wild.20linker.20with.20test.20suites.20from.20other.20linkers)\n\n**Further resources**\n\n*   [Wild linker](https://github.com/davidlattimore/wild)\n*   [Blog posts, most of which are about Wild](https://davidlattimore.github.io/)\n"}