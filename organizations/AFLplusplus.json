{"name":"AFLplusplus","description":"State of the art fuzzing for better security","gsoc_url":"https://summerofcode.withgoogle.com/programs/2025/organizations/aflplusplus","ideas_url":"https://github.com/AFLplusplus/LibAFL/issues/2992","logo":"https://summerofcode.withgoogle.com/media/org/aflplusplus/dw8yelaswljerorz-360.png","technologies":["llvm","rust","fuzzing","qemu"],"topics":["fuzzing","ci"],"projects":[{"project_name":"Tool for Automated generic/bounds simplification","summary":"Create a Rust tool to simplify and minimize generics and bounds in code, assisting developers in maintaining complex codebases.","difficulty":"medium"},{"project_name":"Adapt `qemuafl` Frontend to LibAFL QEMU","summary":"Adapt the frontend of `qemuafl` to allow fuzzers built for it to run on LibAFL QEMU, while measuring performance metrics.","difficulty":"medium"},{"project_name":"Network Emulation for LibAFL_QEMU","summary":"Implement syscall emulation for network and filesystem in LibAFL_QEMU, akin to existing emulation tools.","difficulty":"medium"},{"project_name":"Remote Worker Stage","summary":"Develop a `RemoteWorkerLauncherStage` that offloads execution tasks to remote workers, enhancing performance for slow targets.","difficulty":"easy to medium"},{"project_name":"Tool for Automated generic/bounds simplification","summary":"Develop a Rust tool that simplifies complex generics and bounds in code, assisting developers in maintenance.","difficulty":"medium"},{"project_name":"Adapt `qemuafl` Frontend to LibAFL QEMU","summary":"Adapt the frontend of qemuafl to work with LibAFL QEMU, ensuring retrocompatibility for fuzzers.","difficulty":"medium"},{"project_name":"Network Emulation for LibAFL_QEMU","summary":"Implement syscall emulation for network and filesystem in LibAFL_QEMU, similar to existing emulation tools.","difficulty":"medium"},{"project_name":"Remote Worker Stage","summary":"Introduce a RemoteWorkerLauncherStage to offload executions to remote workers for better performance on slow targets.","difficulty":"easy to medium"}],"jina_response":"Title: GsoC 2025 Project Idea List · Issue #2992 · AFLplusplus/LibAFL\n\nURL Source: https://github.com/AFLplusplus/LibAFL/issues/2992\n\nMarkdown Content:\nGSoC 2025 Project Idea List\n---------------------------\n\nHere is our proposal list for GSoC 2025.\n\nProposal 1: Tool for Automated generic/bounds simplification\n------------------------------------------------------------\n\nCreate a (general, not LibAFL-specific) rust tool to simplify/minimze bounds\n\n### Description\n\nAs commented by many users and maintainers of LibAFL, our codebase is absolutely full of complicated generics. We use these to allow for structured and statically-checked compatibility between various components provided in our codebase, and is a critical part of how LibAFL is structured.\n\nUnfortunately, these can be very difficult to maintain. Our goal is to develop a tool capable of assisting developers in this maintenance process.\n\nPlease check out issue [#2868](https://github.com/AFLplusplus/LibAFL/issues/2868) for more details.\n\n### Expected Outcomes\n\nA tool that works on any rust code, tries to minimize the used bounds, and fixes the code\n\n### Skills Expected\n\n*   Rust\n*   A good understanding of Generics and the Rust Type system\n\n### Possible Mentors\n\n*   [@addisoncrump](https://github.com/addisoncrump)\n*   [@tokatoka](https://github.com/tokatoka)\n\n### Expected size of the project\n\nThe project is expected to take either 175 or 350 hours.\n\n### Difficulty Rating\n\nThe overall difficulty of this project is expected to be **medium**.\n\nProposal 2: Adapt `qemuafl` Frontend to LibAFL QEMU\n---------------------------------------------------\n\nThe project consists of adapting the frontend of [qemuafl](https://github.com/AFLplusplus/qemuafl), the AFL++'s QEMU fork, with LibAFL QEMU.\n\n### Description\n\nThe end goal of this project would be to run fuzzers built for `qemuafl` while using LibAFL QEMU as the backend, in a retrocompatible way.  \nA draft PR [is already available](https://github.com/AFLplusplus/LibAFL/pull/1983) and can be used as a starting point by the student.  \nIdeally, the student would measure the performance (in terms of exec/s and coverage) of the new `qemuafl` adaptation with some fuzzers to evaluate how the final implementation compares with the reference.\n\n### Expected Outcomes\n\nIn short, we expect the student to make the new frontend work for most fuzzers developed for `qemuafl` while maintaining (at least) similar performance.\n\nSee [#1983](https://github.com/AFLplusplus/LibAFL/pull/1983) for an initial implementation that still lacks features.\n\nThe main tasks the student would have to perform are the following:\n\n*   Speak the AFL++ forkserver protocol (check the draft PR).\n*   Add TCG caching to the LibAFL QEMU forkserver\n*   Use LibAFL QEMU snapshots where possible\n*   Add as many env variable features as possible\n\n### Skills Expected\n\nWe expect the student to:\n\n*   have a strong background in the Rust and C languages.\n*   be familiar with fuzzing.\n*   ideally, have some experience using [AFL++](https://github.com/AFLplusplus/AFLplusplus) and / or [LibAFL](https://github.com/AFLplusplus/LibAFL).\n*   ideally, have prior experience with [the QEMU project](https://www.qemu.org/).\n\n### Possible Mentors\n\nThe possible mentors for this project are:\n\n*   [@domenukk](https://github.com/domenukk)\n*   [@rmalmain](https://github.com/rmalmain)\n\n### Expected size of the project\n\nThe project is expected to take either 175 or 350 hours.\n\n### Difficulty Rating\n\nThe overall difficulty of this project is expected to be **medium**.\n\n### Original post\n\nThis proposition is mostly an adaptation of issue [#2964](https://github.com/AFLplusplus/LibAFL/issues/2964).\n\nProposal 3: Network Emulation for LibAFL\\_QEMU\n----------------------------------------------\n\nImplement syscall emulation for filesystem and network in libafl\\_qemu.\n\n### Description\n\nThe student must implement something similar to [preeny](https://github.com/zardus/preeny) and [FitM](https://github.com/fgsect/FitM) to hook the network API and an emulator filesystem that can be snapshot-restored always hooking the syscall in libafl\\_qemu user mode\n\n### Expected Outcomes\n\nA working network emulation layer for LibAFL\\_QEMU\n\n### Required Skills\n\n*   Good understanding of Rust, C, system programming\n*   Ideally: prior knowledge in emulators and fuzzing\n\n### Difficulty Rating\n\nThe overall difficulty of this project is expected to be **medium**.\n\n### Possible mentors\n\n*   [@domenukk](https://github.com/domenukk)\n*   [@rmalmain](https://github.com/rmalmain)\n\n### Expected size of the project\n\nThe project is expected to take either 175 or 350 hours, depending on details\n\nProposal 4: Remote Worker Stage\n-------------------------------\n\nMutations and execution of a Stage is always on the machine LibAFL runs at. For very slow targets it may be beneficial to offload the actual executions to stateless worker.\n\n### Description\n\nWe could add a `RemoteWorkerLauncherStage` that builds `n` work packages, each including a next scheduled corpus entry, all metadata for this Testcase, the current feedback state, as well as additional random corpus entries for splicing.  \nThe work package should then be posted to Redis or some other queue db (very much like celery, whatever a rust alternative is).  \nAfter the execution, the results should be collected in an extra stage\n\n### Expected Outcome:\n\nThe implementation and a set of working examples, including:  \nLibAFL Workers / RemoteWorkerLauncherStage + RemoteWorkerCollectorStage\n\n### Required Skills\n\n*   Rust\n*   Prior knowledge in distributed computing and/or fuzzing are a plus\n\n### Difficulty Rating\n\neasy to medium\n\n### Possible mentors\n\n*   [@domenukk](https://github.com/domenukk)\n*   [@tokatoka](https://github.com/tokatoka)\n*   [@addisoncrump](https://github.com/addisoncrump)\n\n### Length\n\n175 hours\n"}