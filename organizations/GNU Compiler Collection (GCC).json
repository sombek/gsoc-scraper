{"name":"GNU Compiler Collection (GCC)","description":"GNU compilers","gsoc_url":"https://summerofcode.withgoogle.com/programs/2025/organizations/gnu-compiler-collection-gcc","ideas_url":"https://gcc.gnu.org/wiki/SummerOfCode","logo":"https://summerofcode.withgoogle.com/media/org/gnu-compiler-collection-gcc/kpspl59nyj0hoxlr-360.png","technologies":["c/c++","gnu make","gnu autotools"],"topics":["compilers","developer tools","toolchain","openmp","link time optimization"],"projects":[{"project_name":"GCC as a GSoC Mentoring Organization for 2025","summary":"GCC has applied to become a mentoring organization for Google Summer of Code (GSoC) in 2025, with hopes of engaging contributors in various development projects.","difficulty":"Medium"},{"project_name":"Rust Front-End Development","summary":"Involves creating a new compiler front-end for Rust, which will require skills in C/C++, navigating a large codebase, and preferably some knowledge of Rust.","difficulty":"Medium to Large"},{"project_name":"Rewrite Rust Lints for HIR","summary":"The goal is to improve lint implementations by transitioning them to operate on a new higher-level intermediate representations in the Rust front-end using a new base visitor class.","difficulty":"Medium to Large"},{"project_name":"Complete Name Resolution Pass Rewrite","summary":"Focuses on finalizing the rewrite of the name-resolution pass for handling complex imports/exports in the Rust programming language by achieving feature-parity with the old algorithm.","difficulty":"Medium"},{"project_name":"Improve Match Expressions and Pattern Matching","summary":"Aims to enhance support for specific Rust patterns in the compiler, which are essential for fulfilling certain compiler milestones and handling existing Rust code.","difficulty":"Medium to Large"},{"project_name":"Fortran - DO CONCURRENT","summary":"Develops support for 'DO CONCURRENT' loops in Fortran for parallel execution, including integration with OpenMP standards and optimizations.","difficulty":"Medium"},{"project_name":"Fortran - 2018/202x Feature Implementation","summary":"Involves implementing several features from Fortran 2018 and 202x, requiring moderate knowledge in Fortran and C/C++.","difficulty":"Medium to Hard depending on feature scope"},{"project_name":"Fortran - Run-time Argument Checking","summary":"Focuses on adding optional run-time checks for older Fortran codes prone to argument mismatches, improving reliability.","difficulty":"Medium"},{"project_name":"Enhance OpenACC Support","summary":"Aims to fill gaps in OpenACC 2.6 support within GCC by implementing critical features such as implementing runtime API routines and cache directives.","difficulty":"Medium to Hard"},{"project_name":"Static Analysis Pass Extension","summary":"Involves enhancing GCC’s experimental static analysis pass to include additional checks and support for various APIs.","difficulty":"Medium to Hard"},{"project_name":"eBPF Run Tool Implementation","summary":"Creates a run tool for GCC-generated eBPF code execution testing in the Linux kernel, facilitating better testing and debugging capabilities.","difficulty":"Medium to Hard"},{"project_name":"Simple File System for GPU Code Testing","summary":"To implement a simple in-memory file system for GPU code generation testing during the development of Nvidia and AMD offloading support.","difficulty":"Medium to Hard"}],"jina_response":"Title: SummerOfCode - GCC Wiki\n\nURL Source: https://gcc.gnu.org/wiki/SummerOfCode\n\nMarkdown Content:\n \n \nGCC Wiki \n \n   Search:       \n\nLogin \n \nSelf \n \nSummerOfCode   \n \nHomePage\nRecentChanges\nFindPage\nHelpContents\nSummerOfCode  \n \n\nImmutable Page\nComments\nInfo\nAttachments\n \n \n More Actions:  Raw Text Print View Render as Docbook Delete Cache ------------------------ Check Spelling Like Pages Local Site Map ------------------------ Rename Page Delete Page ------------------------ Subscribe User ------------------------ Remove Spam Revert to this revision Package Pages ------------------------ Load Save SlideShow        \n \n \n \nGoogle Summer Of Code \nGCC has applied to be a GSoC mentoring organization in 2025. If accepted, the primary org-admin is likely to be Martin Jambor. \nIf you would like to be a GSoC contributor with GCC, first make sure you read the Before you apply and Application sections on this page and then pick a project, possibly from the list below. After you made your selection or have a project idea of your own, please discuss it as soon as possible (way before the application) via the gcc@gcc.gnu.org mailing list (put \"GSoC\" somewhere to the subject) and feel free to raise it on IRC. If you are interested in gcc-rust topics, you can also reach out to the gcc-rust community via Zulip. \n\n\nContents\n\n Google Summer Of Code\n\n Selected Project Ideas\n Before you apply\n Legal requirements\n Application\n\n Formal application document\n Further tips and guidelines\n Other Project Ideas\n\n Link-time and interprocedural optimization improvements\n Language front-ends and run-time libraries\n New optimization passes\n Other projects and project ideas\n Improving GCC Developer Documentation\n Accepted GCC Projects\n\n 2024\n 2023\n 2022\n 2021\n 2020\n 2019\n 2018\n 2016\n 2015\n 2014\n 2013\n 2012\n 2011\n 2010\n 2009\n 2008\n 2007\n 2006 \n \nSelected Project Ideas \nWhen discussing GSoC project ideas in the community, we have found out we are especially interested in the following few. One of their main advantages, apart from their particular relevance and usefulness this year, is that we are confident we can find mentors for them. We will however also consider other projects and we will be happy to discuss your own ideas with you. Nevertheless, please do consider applying for the following: \n\n\nRust Front-End. a new compiler front-end for Rust is in development please see: https://github.com/Rust-GCC/gccrs. A number of projects are available, you can choose one of the following. Required skills include C/C++ and finding a way through a large code-base, some knowledge of Rust would of course also be highly beneficial. \n\n\nRewrite Rust lints to operate on our frontend's HIR instead of using GCC's existing infrastructure \n\nOur frontend has mutliple lint passes (mark-live, scanning for dead code, unused variables...) which are currently implemented by making use of existing GCC middle-end passes. However, this approach poses certain issues for our frontend, and we would like to instead implement these passes using our frontend's internal representation, and more specifically our HIR. \nTo facilitate writing these lints, you will first need to introduce a new base HIR visitor class which will allow you to avoid repeating yourself with boilerplate visitor pattern code. Once this is done, you will need to reimplement existing lints to work using this new base visitor class. If time permits, it would be helpful to rewrite other HIR passes to make use of the new visitor framework you will introduce. \nThis can be both a medium-sized or large project. \n\nComplete name resolution pass rewrite \n\nIn order to handle complex imports and exports in the Rust programming language, we have started a rewrite of our name-resolution pass with a new data-structure and a new algorithm for resolving uses. We are planning to get the new algorithm to a working state by Spring 2025, but this rewrite will still be missing some of the features of the old name-resolver. Your goal will be to take care of these features and help us get the name-resolution rewrite to feature-parity with our old algorithm. \nThis project should be medium-sized. \n\nImproving match expressions and pattern matching \n\nOur frontend is currently lacking support for important Rust patterns such as struct rebinding patterns (destructuring a structure instance's fields and binding them to new names) which prevents us from completing certain compiler milestones, as well as handle existing Rust code within the Rust standard library and Rust-for-Linux project. You will be tasked with improving multiple areas of the compiler in order to improve our handling of match expressions and pattern matching. \nThis project can be medium-sized or large. \n\nFortran – DO CONCURRENT – see GFortranStandards for language links (Fortran standard and what's new documents for 2018 and 202x). Project would be mentored by Tobias Burnus. Required skills include C/C++; some knowledge of Fortran helps, but is not needed. Difficulty medium, size: 175 hours (medium) \n\n\"DO CONCURRENT\" is a special way to write loops such that each iteration is independent of another (except for reductions), permitting to run it concurrently. \nGoal is to execute the loops actually in parallel, namely: \n\nHandling do-concurrent loops in the generic OpenMP code, possibly starting without MASK support and only for those annotated by '!$omp loop' \nExtending it for MASK support / or optimizing the loop count for it. \nHandling parallelization without '!$omp loop' using the command line flag -fdo-concurrent= (like: no parallelization, OpenMP loop, etc.), \"parallel\" (pthread parallelization similar to (based on?) -ftree-parallelize-loops=n). \n\nFor some experiments and results, see also https://arxiv.org/pdf/2110.10151.pdf or experiments by other compiler vendors (search the internet) \n\nAs of Feb 2025, local/local_init for Fortran loops isn't fully implemented, PR101602, this does not affect the OpenMP implementation but just scalar code, but should eventually be fixed. (Hopefully, it will be fixed by the time this project starts. If not, it could be a first task.) \n\nFortran – 2018/202x – Several Fortran 2018 and all Fortran 202x features are unimplemented. See GFortranStandards for language links (Fortran standard and what's new documents for 2018 and 202x). \n\nProject would be mentored by Tobias Burnus. Required skills include C/C++; some knowledge of Fortran helps, but is not needed. \n\nThe size and difficulty of the project depends on its agreed scope, i.e. it can be both a 175-hour (medium-sized) or a 350 hour (large) project, can be both medium difficulty or hard. \n\nEffort depends on which new feature(s) are implemented; requires some research about what's missing and about the effort. If interested, please ask via the fortran@ mailing list, https://gcc.gnu.org/lists.html \nFor instance, the \"Extracting tokens from string\", \"Interoperability with C\", and \"Trig functions changes\" documented in \"what's new in 202x\" document would be a medium sized project. \n\nFortran – run-time argument checking. – In particular older Fortran code, which does not use modules, but also code which uses implicit-size or explicit-size arrays is prone to argument mismatches. The goal of this item is to add an optional run-time test which works by storing the argument-type/size data before the call in a global variable – and check against it in the callee. (A pointer to the called function is stored alongside to permit calls from uninstrumented code to instrumented code.) This project would/could be mentored by Tobias Burnus. Required skills include C/C++; some knowledge of Fortran helps, but is not needed. Difficulty medium, size: 175 hours (medium). \n\nFortran – improved argument compile-time checking – The compiler does check for the arguments in the same file – but it could do better in some cases, i.e. checking better the interface data or updating the expected input better from the use. This project would/could be mentored by Tobias Burnus. Required skills include C/C++; some knowledge of Fortran helps, but is not needed. Difficulty medium, size: 175 hours (medium). \n\nEnhance OpenACC support. OpenACC is parallel programming model for heterogeneous HPC hardware. GCC currently supports most but not all of OpenACC 2.6. The project idea here is to fill some of the gaps, for example, implement: \n\n\nOpenACC acc_memcpy_device runtime API routine \n\nOpenACC init, shutdown, set directives \n\n\nThese complement the corresponding acc_init etc. runtime API routines, which are already implemented. \n\nMake the OpenACC cache directive actually do something \n\nIt's currently only parsed, but we're not actually using it for optimization purposes: prefetch data, move data to low-latency memory. \n\nOpenACC bind clause \n\nOpenACC device_type clause \nTo work on these items, it's definitely very helpful to have available a GNU/Linux system with an AMD or Nvidia GPU supported by GCC Offloading, but it's not strictly necessary. Mentors: Thomas Schwinge, Tobias Burnus. The size and difficulty of the project depends on the agreed number of items to be implemented, i.e. it can be both a 175-hour (medium-sized) or a 350 hour (large) project, can be both medium difficulty or hard. \n \n Notes on OpenACC init, shutdown, set directives: \n Certain functionality in OpenACC exists both in a directive variant and a runtime API routine variant. For example, OpenACC 2.6 has 2.16.3. \"Wait Directive\" (directive variant) and 3.2.11. \"acc_wait\" etc. (runtime API routine variants). In GCC, the front ends map the directive variant to gcc/omp-builtins.def:BUILT_IN_GOACC_WAIT (see git grep --cached BUILT_IN_GOACC_WAIT\\\\\\|c_finish_oacc_wait -- gcc/). This eventually gets translated to a regular function call to libgomp/oacc-async.c:GOACC_wait, which uses the same building blocks as do acc_wait etc., which are also implemented in libgomp/oacc-async.c. (libgomp is the GCC runtime library for OpenMP originally, but then also OpenACC, implementing both the user-level OpenACC \"Runtime Library Routines\" and the compiler-used GOACC_[...] etc. routines.) Similar for #pragma acc enter data create(var) vs. acc_create, and others. Some users like to use one of directive vs. runtime API routine variants over the other; generally some prefer using the directive variants instead of C/C++ #include <openacc.h> or Fortran use openacc module. Corresponding to the acc_init, acc_shutdown, acc_set_device_num/acc_set_device_type runtime API routine variants implemented in GCC, in OpenACC 2.5, \"New init, shutdown, set directives were added\", which are not yet implemented in GCC. Implementation of those is assumed to be very much similar as the OpenACC wait directive is via BUILT_IN_GOACC_WAIT, for example, so would enhance the GCC code along these lines, plus proper testsuite coverage. \n\nSimple file system for use during Nvidia and AMD GPU code generation testing. GCC supports code offloading from a host system to a device: Nvidia and AMD GPUs, via the OpenACC and OpenMP target programming models for heterogeneous HPC hardware. In order to test Nvidia PTX and AMD GCN (etc.) code generation, bare of the OpenACC/OpenMP code offloading infrastructure, we run GCC's make check in configurations where the GPU is treated similar to an embedded device: generate (single-threaded) GPU code, use a run tool to load it to the device and execute it (Nvidia, AMD), and return success status. Other than simple malloc and printf implementations, these device kernels don't have any \"access to the outside world\". In particular, they have no way to read/write files -- which a number of GCC test cases like to do, which thus currently FAIL to execute. The idea of this GSoC project is either (a) to implement a simple \"in-memory\" file system (volatile), which is either (a.1) initially empty or (a.2) initially contains files as determined by the test harness (dg-additional-files directives used in test cases), and may grow additional files that the respective test case writes, and then is able to read back, or (b) to implement an RPC mechanism from the device to the host, so that device kernels may access host files. (The latter is implemented by LLVM, for example.) Either variant is to be implemented in the run tools mentioned above, and newlib, which provides a libc for the devices. In order to execute this project, you have to have a system with a GPU that is supported with GCC code offloading (a laptop with Nvidia GPU should work, for example), and some prior experience with low-level GPU or embedded programming is highly desirable, as well as understanding of low-level file access: how are open, write, etc. typically implemented. For variant (a), how to implement a simple \"in-memory\" file system; for variant (b), how to implement an RPC mechanism between device and host? Performance is not a big concern in this context. Mentor: Thomas Schwinge. The size and difficulty of the project depends on the agreed number of items to be implemented, i.e. it can be both a 175-hour (medium-sized) or a 350 hour (large) project, can be both medium difficulty or hard. \n\nExtend the static analysis pass GCC has gained an experimental static analysis pass which performs some rudimentary checking of malloc/free and the stdio FILE stream API. There is plenty of scope for extending this pass in ways that may interest a contributor, such as \n\n\nAdd format-string support to -fanalyzer. We currently have two different implementations of warnings for format strings (e.g. printf) in GCC; gcc/c-family/c-format.cc implements -Wformat in the C/C++ frontends, doing type-checking on format strings against their arguments, and gcc/gimple-ssa-sprintf.cc implements parts of -Wformat_overflow=, -Wformat_truncation=, and -Wrestrict in the middle-end). Now that the analyzer has -Wanalyzer-out-of-bounds, it might be good to refactor and generalize this format-string parsing to share more code, and so that the analyzer can reuse it, and do similar range analysis (but with the analyzer's more precise path-sensitive interprocedural approach; see https://gcc.gnu.org/bugzilla/show_bug.cgi?id=107017) \nAdd a checker for some API or project of interest to the contributor (e.g. the Linux kernel, a POSIX API that we're not yet checking, or something else), either as a plugin, or as part of the analyzer core for e.g. POSIX. \n\nExtending the analyzer's support for C++. See https://gcc.gnu.org/bugzilla/showdependencytree.cgi?id=97110. \n\nExtend the plugin to add checking for usage of the CPython API (e.g. reference-counting); see https://gcc.gnu.org/bugzilla/show_bug.cgi?id=107646 \nThis project would be mentored by David Malcolm. Required skills include C/C++ and finding a way through a large code-base. The size of the project depends on its agreed scope, i.e. it can be both a 175-hour (medium-sized) or a 350 hour (large) project but it is probably easier to define a large one. Difficulty also depends on scope but is likely to be hard. \n One more project idea, co-mentored by Thomas Schwinge: \n\n\ne. add checks for programs using OpenACC (parallel programming model for heterogeneous HPC hardware), for example: extend the analyzer's existing malloc/free-like checks to understand OpenACC host vs. device memory, and OpenACC runtime API memory allocator and mapper routines (acc_malloc vs. acc_create vs. acc_map_data etc.; see also here). Depending on the number of checks to be implemented, this can also be both a 175-hour (medium-sized) or a 350 hour (large) project. As the suggested checks only concern host-side code, having an AMD or Nvidia GPU supported by GCC Offloading is not necessary for this project. \n\n\nwaiting for review \n\n\neBPF run tool for execution testing of GCC-generated eBPF code. eBPF is a technology for injecting code into, for example, a running Linux kernel, in a safe way. GCC contains a back end for eBPF code generation. There is a simulator for execution testing, but that one is limited in its capabilities. The idea of this GSoC project idea is to write an eBPF run tool, for use with GCC's make check (DejaGnu board file): load GCC-generated eBPF code into the Linux kernel, execute it, and return success status. With this, you may then run relevant parts of the GCC test suite, classify any issues observed, and/or address code generation bugs in the compiler. (If you happen to find any issues in the eBPF verifier or other Linux kernel technology, then you're really lucky...) Prior knowledge of eBPF specifically is not necessary; some prior knowledge of (virtual) instruction set architectures is desirable. Mentors: Jose E. Marchesi, Thomas Schwinge. The size and difficulty of the project depends on the agreed number of items to be implemented, i.e. it can be both a 175-hour (medium-sized) or a 350 hour (large) project, can be both medium difficulty or hard. \nThe expected outcome of all projects listed above is a series of patch submissions which pass review and are included in the main GCC repository, the GCC-Rust project repository (for Rust-related projects) and/or binutils (e.g. the demangler code is shared between GCC and binutils). \nUnless a project above was explicitly marked with a different difficulty, consider it to be hard. Generally speaking, GCC is a production compiler and working on one of those is always hard, especially if you are new. On the other hand, the community of GCC developers is very helpful and goes out of its way to assist newcomers with various difficulties they inevitably encounter. \nIf the list above was not exhaustive enough for you, you can have a look also at Other Project Ideas section below. \n\n \n \nBefore you apply \nApplicants for a GCC Google Summer of Code project need to have experience coding in C/C++. Furthermore, if you want to work on the actual compiler you must have at least rudimentary theoretical background in the area of compilers and compiler optimizations - at the very least you need to understand the term intermediate representation (IR), sometimes also called intermediate language (IL). It also helps if you know what static single assignment (SSA) form is and why it is useful. This may not be strictly necessary if your project aims to improve a different tool or library that is part of GCC, such as the demangler but even in these cases you need to know about the required algorithms. \nBefore you apply and even before you even reach out to us make sure that you can check out the GCC source code from its Git repository, build GCC from it and run the testsuite (this is something that would need doing very many times in the course of any project working on GCC) and look around the project a bit. \nThe following links should help you: \n\n\nHow to checkout our sources using Git is described at https://gcc.gnu.org/git.html. \n\nSteps linked from https://gcc.gnu.org/install/ show you how to configure, build and test GCC (look for --disable-bootstrap, among other things). The Installing GCC page shows an easy way to obtain the libraries required to build GCC which people often find most problematic and other advice related to building and installing GCC for the first time. \n\nRead through David Malcom's guide GCC for New Contributors. David has also presented a talk about this topic at FOSDEM'24, you can watch the recording. You can also check out Getting Started wiki page. \n\nWiki page DebuggingGCC and the manual page about Developer options are of particular interest. Read through those, compile a simple but non-trivial program with \n -O3 -S -fdump-tree-all -fdump-ipa-all -fdump-rtl-all\n\n\nand look through the generated files. Look at the the source code, especially in the gcc subdirectory and try to set a breakpoint somewhere and hit it. Then look around in gdb. \n\n\nIf you intend to work in the area of Link Time Optimization (LTO), the following two videos may help you understand the required concepts: \n\n\nBuilding openSUSE with GCC's link time optimization \n\nInterprodecural optimizations in GCC \n\nIf your selected project involves Offloading, you almost certainly want to familiarize yourself with the concept which is described on its own wiki page. You probably want to look at it also if you plan to work in the are of OpenACC or (to a lesser extent) OpenMP. \n\nIf your selected project is in the area of the static analyzer, some notes specifically about the analyzer's internals and debugging it can be seen here: \n\n\nhttps://gcc.gnu.org/onlinedocs/gccint/Analyzer-Internals.html \n\nhttps://gcc.gnu.org/onlinedocs/gccint/Debugging-the-Analyzer.html \nIf you have done all of the above, or at least most of it, and still find it all a little bit intimidating, do not despair. If you are facing any specific technical problem or if you have difficulties figuring out where to start looking for particular things, that is something the mentors and the community at large are willing to help you with. First, the mailing list you keep reading about here has an archive, it is always a good idea to check if some other GSoC applicant has not asked your question recently. If not, send an email describing your situation to the mailing list yourself. We will appreciate if in your email you will make it clear that you have read this section and briefly list the steps above you have managed to carry out successfully. \n \nLegal requirements \nAny non-trivial contributions to GCC are accepted only if their author either formally assign their copyright for them to the Free Software Foundation or if the author certifies the \"Developer Certificate of Origin\" (DCO) by adding the Signed-off-by: tag to their submission. Both processes are described in the official page on Contributing to GCC. Accepted GSoC contributors will be expected to choose one and follow it. \n \nApplication \nFirst, you need to select a project. If you have been following GCC development, you might have an idea of your own, otherwise look at the suggested projects above and try to pick one there. In the course of selecting a project or when researching it in order to write your application, do not hesitate to ask questions or request more details from the community by email to the gcc@gcc.gnu.org mailing list with the string \"GSoC\" in the email subject or on our #gcc IRC channel at irc.oftc.net. Please note that the mailing list does not accept HTML messages, you must set your email client to plain text. If you are interested in gcc-rust topics, you can also reach out to the community via Zulip. \nWhen you have a draft of your proposal ready, send it to the gcc@gcc.gnu.org mailing list as a request for comments. First, it should help you come up with a much better final proposal. Second, when evaluating applicants, we look closely at how they responded to feedback and how they incorporated it in their application document. We are unlikely to accept an application from someone who has not interacted with the community before at all. Please remember to put the string \"GSoC\" in the email subject of all messages about GSoC or a GSoC project proposal. \n \nFormal application document \nGCC does not have any application form or a mandatory application format to follow, but we strongly suggest you include the following in the formal application document that you submit to GSoC: \n\nDescribe the project and clearly define its goals. \nIf you chose a project that is not among the \"selected project ideas,\" describe why it is a worthwhile effort. \nProvide an expected time-line. We understand it is likely to change, that is not the point. Instead we want to know that you have a reasonable idea about project milestones. Moreover, org-admins will pay close attention to your plan for the first and second week of the coding period. If you intend to do general research how to \"do stuff\" only then, it likely means that you do not understand the actual technical issues and that you should do some of the research before applying. On the other hand, researching specific topics is probably fine, some semi-independent researching throughout the project is actually expected. \nBriefly introduce yourself and your skills and/or accomplishments. We would like to be sure you have the knowledge and skills to complete the project - but we will evaluate this also from how you have interacted with us in the preparation phase. \n \nFurther tips and guidelines \n\nBe honest and realistic. We prefer a smaller project with clearly defined goals to a far-reaching but vague proposal (that is likely never going to be finished by the contributor). \nApplicants that have already submitted good patches give a much better impression to reviewers and potential mentors. \n\nStarting with some small patch for the area you are interested in before the proposal submittal period can help (ask for guidance and a simple enough project): It helps you to get the code known and to decide whether you really want to do the project, it shows how the development procedure is, and helps potential mentors to judge the proposal based on actual work. Besides: Also small fixes are good and getting people known by email (or IRC) exchange is nice by itself  \n\nAnd let's stress again that you need to present your project on the gcc@gcc.gnu.org mailing list because there is likely going to be a feedback that you should incorporate. Put \"GSoC\" somewhere into the email subject. \n\n \n \nOther Project Ideas \n\n\nNote that some of the ideas found below might be fully or partially obsolete. This is another reason why it is always a good idea to discuss the project of interest on the mailing list and/or via IRC before submitting a GSoC proposal. \n \nLink-time and interprocedural optimization improvements \nLink-time optimization (LTO) is powerful infrastructure in GCC and there are many areas how to make it better, for example: \n\nImplement tree level section anchors to improve code generation at ARM/PPC. \n \nLanguage front-ends and run-time libraries \n\n\nC++23 Support in GCC and libstdc++ \n\nFortran front end (please discuss ideas on the Fortran mailing list): \n\n\nExtend OOP support (possible mentors: Janus Weil, Tobias Burnus) by improving partially-implemented features, such as: \n\n\nFinalization \nAssociate construct \n\ncoarray support for SMP and distributed memory systems (possible mentor: Tobias Burnus) \n\n\nCoarrays are a PGAS extension, which is part of Fortran 2008. \nThere has been some work on this by Thomas/Nicolas König in GIT branch devel/gfortran-caf; unclear status. \n\nFortran – shared-memory coarrays NOTE: Partial implementation available in devel/coarray_native branch, if interested, ask about remaining tasks in this area – Coarrays are a means of parallelizing code; conceptually, all memory is local memory, except for coarrays which are on multiple processes (\"images\") and remote can be directly accessed. (Internally: one-sided communication.) GCC/gfortran supports \"single\" (compiles but does not do any actual parallelization) and \"lib\" (requires a communication library). The goal of this task is to add a shared-memory implementation – such that parallel coarray programs runs out of the box without additional external libraries. This project would be mentored by Tobias Burnus. This project consists of work mostly on a run-time library written in C but also on the compiler itself written in C/C++. Hence, required skills include C/C++, knowledge about POSIX Threads; some knowledge of Fortran helps, but is not needed. \n\nPossible task: Improving the multi-image support, which uses OpenCoarray communication library \nImplement Fortran 2018 additions (TS18508) additions \nRun-time argument checking: Uninitialized variables, correctness of arguments \nImprove handling of allocatable characters \nImprove parameterized derived types (possible sponsor: Paul Thomas) \nBetter IEEE support \n\nOther Unimplemented Fortran 2003, Fortran 2008 features, TS 29113 features \nIO optimization. Currently formatted scalar IO is quite slow and uses lots of stack space. \n\nOpenMP runtime improvements: openmp \nGCC Go escape analysis: in Go, taking the address of something means that it lives on the heap--Go has no such thing as a dangling pointer. It is possible to use escape analysis to determine whether the pointer ever escapes its scope. If it does not, then the object whose address is taken can be allocated on the stack rather than the heap, which is more efficient. A particular example is calls to functions like fmt.Printf, which allocate a slice of the arguments passed in. Escape analysis can allocate that slice on the stack rather than the heap. \n\nEnhance the GimpleFrontEnd with CFG and SSA annotation reconstruction to make writing and extracting unit-tests easier. \n \nNew optimization passes \n\nImplement code motion of stores towards entry (and use this to improve code for int to float conversion on rs6000-based targets) \nImplement a prototype for early instruction selection \nPropagate interprocedural dataflow from GIMPLE to RTL \nAdd Factored Use-Def (FUD) chains to RTL \n\nLoop optimizations and automatic parallelization based on Graphite \nImplement a basic-block local scheduling pass to improve SSA name coalescing opportunities at RTL expansion time \n\nImplement a (prototype) addressing mode selection (AMS) pass as a replacement of auto-inc-dec. For more details see PR 56590. \n \nOther projects and project ideas \n\n\nMake cp-demangle non-recursive. C++ mangled names use a recursive grammar, and naturally led to a recursive demangler in libibiberty (used for __cxa_demangle and other entry points). Very long symbols and malformed inputs can cause deep recursion (even unbounded in the malformed case). Stack overflow is unpredictable and has terrible failure modes, which has led to imposing arbitrary recursion limits in the demangler. The demangler should be converted to use a bespoke heap-allocated data stack for the recursive state, and the implicit recursion removed. Resource allocation failure can be indicated via the existing failure code. The demangler is implemented in C, the project entails turning implicit recursion into an explicit ne driven by a LIFO worklist - clear understanding of what that means and good command of C is required. You will also learn about C++ mangled names. 175 hour (medium-sized) project. \n\nType Sanitizer. Both LLVM and GCC compilers do share a common sanitizer library called libsanitizer. The library has recently received support of typed-based sanitization (TySan). Goal of the task would be to investigate and prototype usage of type-based aliasing rules information provided by GCC in order to detect violations of strict aliasing rules. \n\nReplace libiberty with gnulib. See http://gcc.gnu.org/ml/gcc-patches/2012-08/msg00362.html Initial work was done in GSoC 2016 (replacelibibertywithgnulib). \n\nFinish the implementation of a stable introspection plugin API (with the possibility of extending it to cover non-introspection cases) \nModify any GCC optimization decisions externally through plugins (see MILEPOST GCC, for example). -- G. Fursin, 2014. \nSystematize learning of optimal optimization decisions for multiple benchmarks, data sets and architectures (see c-mind.org/repo, for example). -- G. Fursin, 2014. \nExtend GCC plugin framework to enable code instrumentation (insert calls to external function after individual instructions) for dynamic code analysis. We need it to extend our TM/TLS models. -- G. Fursin, 2014. \nFix -ftrapv so that it works. \nImprove the regression testing system, for example to detect places where the generated code changed (useful for refactoring). \n\nPromote C++ operator new to alloca when pointer does not escape and user allows non-conformance to C++ standard \nImprove loop unrolling heuristics and enable loop unrolling with default optimization \nAnalyze and improve inlining, loop unrolling, reassociation and predictive commoning heuristics for PowerPC architecture \nUse TARGET_EXPAND_TO_RTL_HOOK for pipelined divide on PowerPC \nSupport AIX XCOFF file format for LTO (David Edelsohn) \n\nImplement something similar to Clang's -ftime-trace feature which generates performance reports that show where the compiler spends compile time. For more information, please check the following blog post. There's also an existing bugzilla entry for this (if this becomes a GSoC project, the assignee will of course change). Required skills include C/C++ and finding a way through a large code-base. \nThere are several pages with general ideas for GCC, many of which we linked below for easy access. These ideas usually are not just one project but a group of distinct projects. \n\n\nGCC projects page \n\nIdeas for speeding up GCC \n\nImprovements to GCC on Windows \n\nPartial_Transitions \n\nImprove GCC Diagnostics \n\nGCC Improvement Projects \n\nThis category of projects deals with a range of changes, from simple to challenging. These projects are of great interest to us, because they address some long-standing architectural issues that we want to fix. \n\nOther project ideas can be found in the bug database, look for old bugs which are still open. \nOr invent your own project. We're always open to good ideas. But note that we are probably not too interested in projects to add new extensions to the C or C++ languages. We've found over time that these tend to introduce more problems than they solve. \nThanks, and we look forward to your submissions! \n \nImproving GCC Developer Documentation \nThe rules of the GSoC program do not allow projects to consist of documentation improvements only. Nevertheless, note that writing documentation may be an important part of your project or even an essential one if you introduce user-visible changes and plan your work accordingly. \n\n \n \nAccepted GCC Projects \n \n2024 \n \nProject  \nStudent  \nMentors    \n gccrs - Inline Assembly Support  \n jjasmine  \n Arthur Cohen, Pierre-Emmanuel Patry    \n Fortran – DO CONCURRENT  \n Anuj Mohite  \n Tobias Burnus, Thomas Schwinge    \n Offloading to a separate process on the same host  \n Georgii Burunsuzian  \n Thomas Schwinge, Tobias Burnus    \n Borrow-checking IR location support  \n Kushal Pal  \n Arthur Cohen, Pierre-Emmanuel Patry    \n Rustc Testsuite Adapter for GCCRS  \n Muhammad Mahad  \n Thomas Schwinge, Arthur Cohen, Pierre-Emmanuel Patry    \n Improve nothrow detection in GCC  \n Pranil Dey  \n Martin Jambor, Jan Hubicka    \n Structured Dumping of GENERIC Trees  \n Thor Preimesberger  \n Richard Biener   \n \n2023 \n \nProject  \nStudent  \nMentors    \n Improving user errors & Error Code Support for GCC Rust Frontend  \n Muhammad Mahad  \n Philip Herron and Arthur Cohen    \n Unicode Support for GCC Rust Frontend  \n Raiki Tamura  \n Philip Herron and Arthur Cohen    \n Extending gcc -fanalyzer C++ support for self-analysis  \n Benjamin Priour  \n David Malcolm    \n GCC static analyzer plugin for CPython extension modules  \n Eric Feng  \n David Malcolm    \n Bypass assembler when generating LTO object files  \n Rishi Raj  \n Martin Jambor and Jan Hubicka    \n C++: Implement compiler built-ins for the standard library traits  \n Ken Matsui  \n Patrick Palka   \n \n2022 \n \nProject  \nStudent  \nMentors    \n Support for Constant Folding in Rust Frontend  \n Faisal Abbas  \n Philip Herron    \n Extend GCCs static analyzer to support checking for POSIX file descriptor APIs  \n Immad Mir  \n David Malcolm    \n Improving Rust debugging experience by enhancing the HIR dump  \n Andrew Naguib  \n Arthur Cohen and Philip Herron    \n Bypass assembler when generating LTO object files  \n Nitin Kumar  \n Jan Hubička and Martin Jambor    \n New checkers for GCC’s static analyzer  \n Tim Lange  \n David Malcolm    \n Accelerating Fortran DOCONCURRENT  \n Wileam Phan  \n Tobias Burnus and Thomas Schwinge   \n \n2021 \n \nProject  \nStudent  \nMentors    \nExtending C++ support for static analysis pass  \n Ankur Saini  \n David Malcolm    \nCargo tool for Rust-GCC  \n Arthur Cohen  \n Philip Herron    \nStatic analysis for unreachable functions  \n Wenzhang Yang  \n Philip Herron    \n Make Cp-demangler non recursive  \n Vishnu Madhav  \n Nathan Sidwell and Martin Jambor   \n \n2020 \n \nProject  \nStudent  \nMentors    \nAutomatic Detection of Parallel Compilation Viability  \n Giuliano Belinassi  \n Richard Biener    \nGeneral Jobserver Client/Server Library  \n John Ravi  \n Martin Liška and Nathan Sidwell    \nImplementation of OMPD in GCC and libgomp  \n Tony Sim  \n Jakub Jelínek and Martin Jambor   \n \n2019 \n \nProject  \nStudent  \nMentors    \nOn vector<bool> and optimized Standard Algorithms in libstdc++  \n ThePhD  \n Thomas Rodgers, Jonathan Wakely and Ville Voutilainen    \nNew math.h and complex.h functions as built-ins  \n Tejas Joshi  \n Martin Jambor and Jan Hubička    \nCsmith fuzzer leveraging GCC C Extensions  \n Shubham Narlawar  \n Martin Liška and Andi Kleen    \nOpenMP Work Stealing Scheduling  \n Khurai Kim  \n Jakub Jelínek    \nMake C/C++ not automatically promote memory_order_consume to memory_order_acquire  \n akshatg  \n Paul E. McKenney and Ramana Radhakrishnan    \nParallelize GCC with Threads (see also ParallelGcc)  \n Giuliano Belinassi  \n Richard Biener   \n \n2018 \n \nProject  \nStudent  \nMentor    \nLTO dump tool (project page)  \n Hrishikesh Kulkarni  \n Martin Liška and Jan Hubička  \n \n2016 \n \nProject  \nStudent  \nMentor    \nReplace libiberty with gnulib (project page)  \n Ayush Goel  \n Manuel Lopez-Ibanez   \nDevelopment of GIMPLE Front End  \n Prasad Ghangal  \n Richard Biener    \nFurther work on addressing mode selection  \n erikvarga  \n Oleg Endo   \n \n2015 \n \nProject  \nStudent  \nMentor    \nC++ Library Fundamentals: shared_ptr and polymorphic memory resources  \nFan You  \nTim Shen    \nAddressing mode selection in GCC  \nErik Krisztian Varga  \nOleg Endo   \n \n2014 \n \nProject  \nStudent  \nMentor    \nCoarray support in GNU GFortran  \nAlessandro Fanfarillo  \nTobias Burnus    \nConcepts Separate Checking  \nBraden Obrzut  \nAndrew Sutton    \nIntegration of ISL code generator into Graphite  \nRoman Gareev  \nTobias Grosser    \nGenerating folding patterns from meta description  \nPrathamesh Kulkarni  \nRichard Biener    \nGCC Go escape analysis  \nRay Li  \nIan Lance Taylor   \n \n2013 \n \nProject  \nStudent  \nMentor    \nPorting the GCC go language frontend on the GNU/HURD kernel  \nFotis Koutoulakis  \nThomas Schwinge    \nOptimizing large applications with LTO  \nMartin Liška  \nJan Hubicka    \nCompleting C++11 regex  \nTim Shen  \nStephen M. Webb   \n \n2012 \n \nProject  \nStudent  \nMentor    \nContinue work on GCC generic optimisation and cleanup  \nDimitrios Apostolou  \nAndrey Belevantsev    \nImplement regular expressions to C++  \nMorgen Matvey  \nBenjamin De Kosnik    \nGimple FE : Extending the text gimple recognizer to a real front end  \nSandeep Soni  \nDiego Novillo    \nC++11 regex support in libstdc++  \nSergey Lega  \nBenjamin De Kosnik   \n \n2011 \n \nProject  \nStudent  \nMentor    \nExtend GFortran's Coarray support with MPI-based paralellization (project page)  \nDaniel Carrera  \nTobias Burnus    \nGCC Optimisation Final Report, Various Notes: (1) (2) (3)  \nDimitrios Apostolou  \nSteven Bosscher    \nIntegration of transactional memory support into a data-flow extension of OpenMP  \nIsmail KURU  \nRichard Henderson    \nDevelopement of Gimple Front End (project page)  \nKetaki  \nDiego Novillo    \nGccpy - GCC Python Front-end (project page)  \nPhilip Herron  \nIan Lance Taylor    \nCustomizable warnings with a GCC plugin (project page)  \nPiervit  \nBasile Starynkevitch    \nImplement faster OpenMP Task for libgomp  \nSho Nakatani (中谷 翔)  \nJakub Jelínek   \n \n2010 \nThe source code for finished projects can be found at Google's code hosting site and their respective SVN branches. \n \nProject  \nStudent  \nMentor    \nEFI extension of Binutils  \nYi-Hong Lu  \nH. J. Lu    \nDevelopment of GIMPLE FE  \nSandeep Soni  \nDiego Novillo    \nImprovement of general vector extension in GCC  \nArtjoms Sinkarovs  \nRichard Günther    \nPartial Implementation of Python as a GCC Front-end  \nPhilip Herron  \nIan Taylor    \nImproving the static control part detection mechanism in Graphite  \nVladimir Kargov  \nSebastian Pop    \nTraditional loop transformations in GRAPHITE  \nAnkur Deshwal  \nDavid Edelsohn    \nScopLib support for Graphite - Linking Graphite to the huge industrial and research community  \nRiyadh Baghdadi  \nSebastian Pop    \nPorting GRAPHITE to CLooG trunk  \nAndreas Simbuerger  \nTobias Grosser    \ngfortran: Polymorphism and a complete OOP implementation  \nJanus Weil  \nTobias Burnus    \nExtending Fortran 2003 and 2008 support for gfortran (esp. Co-Arrays)  \nDaniel Kraft  \nTobias Burnus   \n \n2009 \nThe source code for finished projects can be found at Google's code hosting site. \n \nProject  \nStudent  \nMentor    \nAutomatic parallelization in Graphite  \nLi Feng  \nTobias Grosser    \nEnable generic function cloning and program instrumentation in GCC to be able to create static binaries adaptable to varying program and system behavior or different architectures at run-time  \nLiang Peng  \nGrigori Fursin    \ngfortran: Procedure Pointer Components & OOP  \nJanus Weil  \nTobias Burnus    \nTraditional Loop Transformations  \npranav garg  \nSebastian Pop    \nMake the OpenCL Platform Layer API and Runtime API for the Cell Processor and CPUs  \nphil prattszeliga  \nPaolo Bonzini    \nProvide fine-grain optimization selection and tuning abilities in GCC to be able to tune default optimization heuristic of the compiler or fine optimizations for a given program on a given architecture entirely automatically using statistical and machine learning techniques from the MILEPOST project.  \nYuanjie Huang  \nGrigori Fursin   \n \n2008 \nThe source code for finished projects can be found at Google's code hosting site. \n \nProject  \nStudent  \nMentor    \nGCC Improvements on Windows  \nAaron W. LaFramboise  \nSteven Bosscher    \nImproving Dead Store Elimination  \nJakub Staszak  \nDaniel Berlin    \nExtend Fortran 2003 support for gfortran  \nDaniel Kraft  \nFrançois-Xavier Coudert    \nC++0x lambda functions for GCC  \nJohn Freeman  \nDouglas Gregor    \nImproved GIMPLE to GRAPHITE transformation  \nTobias Grosser  \nSebastian Pop    \nFinish work on propagation aliasing and array dependence information from Tree-SSA to RTL.  \nAlexander Monakov  \nDiego Novillo    \nProcedure Pointers for gfortran  \nJanus Weil  \nTobias Burnus   \n \n2007 \nThe source code for finished projects can be found at Google's code hosting site. \n \nProject  \nStudent  \nMentor    \nPropagating array data dependence information from Tree-SSA to RTL  \nAlexander Monakov  \nDaniel Berlin    \nBetter_Uninitialized_Warnings  \nManuel López-Ibáñez  \nDiego Novillo    \nSpeeding up GCC for fun and profit  \nJames Webber  \nEric Marshall Christopher    \nFortran 2003 features for GCC  \nJanus Weil  \nSteven Bosscher    \nOpen Mutliprogramming Interprocedural Analasis and Optimalizations  \nJakub Staszak  \nDaniel Berlin    \nIntegrating OpenJDK's javac bytecode compiler into gcj  \nDalibor Topic  \nMark J. Wielaard    \nNew static scheduling heuristic for GCC  \nDmitry Zhurikhin  \nVladimir Makarov    \nGCC support for Windows-compatible Structured Exception Handling (SEH) on the i386 platform  \nMichele Cicciotti  \nIan Lance Taylor   \n \n2006 \n \nProject  \nStudent  \nMentor    \nCode parallelization using polyhedral model  \nPlesco Alexandru  \nDaniel Berlin    \nEscape_analysis  \nPaul Biggar  \nDaniel Berlin    \nGarbage_collection_tuning  \nLaurynas Biveinis  \nDaniel Berlin    \njava.lang.management in Classpath  \nAndrew John Hughes  \nMark Wielaard    \nLock free C++ containers  \nPhillip Jordan  \nBenjamin Kosnik    \nWcoercion option  \nManuel López-Ibáñez  \nIan Lance Taylor   \nNone: SummerOfCode (last edited 2025-02-20 07:43:34 by TobiasBurnus) \n  \n \n\nImmutable Page\nComments\nInfo\nAttachments\n \n \n More Actions:  Raw Text Print View Render as Docbook Delete Cache ------------------------ Check Spelling Like Pages Local Site Map ------------------------ Rename Page Delete Page ------------------------ Subscribe User ------------------------ Remove Spam Revert to this revision Package Pages ------------------------ Load Save SlideShow       \n \nMoinMoin Powered\nPython Powered\nGPL licensed\nValid HTML 4.01\n"}