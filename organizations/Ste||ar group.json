{"name":"Ste||ar group","description":"Shaping a Scalable Future","gsoc_url":"https://summerofcode.withgoogle.com/programs/2025/organizations/stear-group","ideas_url":"https://github.com/STEllAR-GROUP/hpx/wiki/Google-Summer-of-Code-%28GSoC%29-2025#2025-hpx-project-ideas","logo":"https://summerofcode.withgoogle.com/media/org/stear-group/sebxbtinyakvrevb-360.png","technologies":["c++","hpc"],"topics":["library","optimization","parallel algorithms","hpx","application"],"projects":[{"project_name":"Introduction to GSoC 2025 with HPX","summary":"The HPX project is participating in Google Summer of Code (GSoC) 2025, aiming to fund at least five student projects that enhance HPX. The page provides various resources for students, including ideas for projects, proposal submissions, and community discussions.","difficulty":"N/A"},{"project_name":"Requirements for Proposal Submission","summary":"Students interested in GSoC must submit a proposal using a provided template. Active engagement with the community, proposing new ideas, and showcasing programming skills in C++ and CMake is encouraged.","difficulty":"N/A"},{"project_name":"Potential Additional Funding","summary":"Students may receive up to four weeks of additional funding from LSU if they perform well during GSoC evaluations. This funding is not guaranteed and requires additional paperwork.","difficulty":"N/A"},{"project_name":"Tips for Prospective Students","summary":"A compiled list of tips for students to help them transition into HPX development, including building HPX from source, familiarizing with documentation, and engaging with the community for project ideas and support.","difficulty":"N/A"},{"project_name":"2025 HPX Project Ideas","summary":"A collection of new and revamped project ideas for GSoC 2025 related to the HPX library, covering a variety of technical improvements and features.","difficulty":"N/A"},{"project_name":"Core HPX Projects","summary":"Projects focused on improving or extending the core functionalities of the HPX library, such as implementing algorithms, integrating with tools like Nvidia Thrust, and enhancing performance and usability.","difficulty":"Medium/Advanced"},{"project_name":"Annotate HPX with Contracts","summary":"Aiming to enhance safety by implementing contracts in HPX's public API, providing defined behaviors for function pre- and post-conditions.","difficulty":"Medium/Advanced"},{"project_name":"Integrate HPX algorithms with Nvidia CCCL (Thrust)","summary":"This project focuses on integrating Nvidia's Thrust algorithms with HPX, potentially enhancing performance through HPX's asynchronous execution capabilities.","difficulty":"Medium/Advanced"},{"project_name":"Expose HPX using C++ Modules","summary":"The goal is to make HPX accessible using C++20 Modules to improve compilation times and code organization.","difficulty":"Medium/Advanced"},{"project_name":"Implement the `make_receiver_for` optimization for HPX Senders","summary":"This project seeks to implement system optimizations for HPX’s sender/receiver interface that could significantly enhance performance and reduce object size.","difficulty":"Medium/Advanced"},{"project_name":"Implement `hpx::system_scheduler` as described in P2079","summary":"Developing a generic scheduler for OS-provided threads adapted for HPX to improve its parallelism and task management capabilities.","difficulty":"Medium/Advanced"},{"project_name":"Integrate HPX with the Tracy profiler","summary":"This project aims to integrate the Tracy profiling tool with HPX, helping developers optimize and analyze their applications effectively.","difficulty":"Medium/Advanced"},{"project_name":"Use C++26 reflection for HPX serialization","summary":"Enhancing HPX's serialization capabilities by incorporating C++26 reflection, allowing for serialization of arbitrary types.","difficulty":"Medium/Advanced"},{"project_name":"Implement parallel `hpx::uninitialized_relocate_*` algorithms","summary":"Focus on refining certain parallel algorithms for handling overlapping data ranges to improve performance and safety during relocations.","difficulty":"Medium/Advanced"},{"project_name":"Async I/O using Coroutines and S/R","summary":"Developing an efficient async I/O interface using HPX's coroutine capabilities, particularly focusing on Linux platforms and `io_uring`.","difficulty":"Easy/Medium"},{"project_name":"\"Green out\" our Continuous Integration tests","summary":"A project dedicated to fixing failing tests in the HPX CI processes to ensure that all tests pass successfully and maintain code integrity.","difficulty":"Easy/Medium"},{"project_name":"Study the performance of Halide applications running on HPX threads","summary":"Analyzing Halide applications with a focus on improving their performance when integrated with the HPX framework.","difficulty":"Medium"},{"project_name":"Bring the HPX distributed algorithms up to date","summary":"This project aims at updating and maintaining the distributed algorithms within HPX to ensure compatibility and performance.","difficulty":"Easy"},{"project_name":"Fix libCDS broken dependency","summary":"Updating and fixing the integration of the concurrent data structures library with HPX to align with the current version.","difficulty":"Easy"},{"project_name":"(Re-)Implement executor API on top of sender/receiver infrastructure","summary":"This project seeks to adapt the executor API in HPX to take advantage of the new sender/receiver standard for better task scheduling and execution.","difficulty":"Medium"},{"project_name":"Update Build System to automatically fetch HPX dependencies","summary":"Proposing improvements to the HPX build system to simplify dependency management and enhance user experience during installation.","difficulty":"Medium"},{"project_name":"Explicit Visualization of Accelerators for HPX Trace Visualization","summary":"Integrating data visualization for accelerators in HPX to improve trace analysis and representation of performance data.","difficulty":"Medium-Hard"},{"project_name":"Improved Scalability for HPX OTF2 Trace Visualization","summary":"Enhancing the scalability of HPX tracing visualization tools to handle larger files more effectively and efficiently.","difficulty":"Medium-Hard"},{"project_name":"Multiple File Load in HPX Trace Visualization","summary":"Implementing functionality to allow visualization tools within HPX to load and compare multiple trace files simultaneously.","difficulty":"Medium-Hard"},{"project_name":"Past Year Projects","summary":"An overview of previous GSoC projects that are still open for contribution, providing opportunities for further development.","difficulty":"N/A"},{"project_name":"AI Project Ideas","summary":"Developing AI methodologies to enhance applications and research in computational scenarios, including storm surge forecasting and image-to-graph conversion tasks.","difficulty":"Medium-Hard"}],"jina_response":"Title: Google Summer of Code (GSoC) 2025\n\nURL Source: https://github.com/STEllAR-GROUP/hpx/wiki/Google-Summer-of-Code-(GSoC)-2025\n\nMarkdown Content:\nIntroduction\n------------\n\n[](https://github.com/STEllAR-GROUP/hpx/wiki/Google-Summer-of-Code-(GSoC)-2025#introduction)\n\nWelcome to the Google Summer of Code (GSoC) page for the HPX project. Here you can find information about student projects, proposal submission templates, advice on writing good proposals, and links to information on getting started with HPX. [The STE||AR Group](http://stellar-group.org/ \"The STE||AR Group: Systems Technology, Emergent Parallelism, and Algorithm Research\") will apply as an organization and our goal is to have at least five funded students working on HPX related projects.\n\nRequirements\n------------\n\n[](https://github.com/STEllAR-GROUP/hpx/wiki/Google-Summer-of-Code-(GSoC)-2025#requirements)\n\nStudents must submit a proposal. A template for the proposal is available [here](https://github.com/STEllAR-GROUP/hpx/wiki/GSoC-Submission-Template). Find hints for writing a good proposal [here](https://github.com/STEllAR-GROUP/hpx/wiki/Hints-for-Successful-Proposals).\n\nWe strongly suggest that students interested in developing a proposal for HPX discuss their ideas on the [Discord](https://discord.gg/eh4HTXVuWg) channel or the mailing list to help refine the requirements and goals. Students who actively plan and discuss projects with developers are generally ranked before those that do not.\n\nWe have intentionally left the descriptions of these projects vague and open to interpretation because we expect students to develop their proposals' requirements by doing initial background research on the topic and interacting with the community. **In addition, it is important to note that the suggested projects on this page are not binding** -- if you have an interest in parallel task-based programming and have an idea for a project that would either improve HPX or demonstrate how well it applies to your problem, then feel free to suggest your idea as a project and write a proposal for it. We will be glad to help you with project goals to improve your proposal if you have ideas, so do not leave them until the last minute.\n\nWe will expect students to demonstrate that they have the required level of C++ and CMake knowledge by showing us some of their previous work (e.g., a GitHub repository), or preferably, by them making a small demonstration program using HPX that shows a simple example of something they have created themselves.\n\nPotential Additional Funding\n----------------------------\n\n[](https://github.com/STEllAR-GROUP/hpx/wiki/Google-Summer-of-Code-(GSoC)-2025#potential-additional-funding)\n\nFor students who perform at or above expectations on both GSoC evaluations, the Center of Computation and Technology (CCT) at Louisiana State University (LSU) may fund up to an additional four weeks' work on the project for no more than the GSoC rate of pay. This funding is not guaranteed and is independent of the GSoC program. Students accepted for additional funding will be paid through LSU for the additional weeks and affiliated with LSU during that time. Additional paperwork through LSU will be required.\n\nTips for Prospective Students\n-----------------------------\n\n[](https://github.com/STEllAR-GROUP/hpx/wiki/Google-Summer-of-Code-(GSoC)-2025#tips-for-prospective-students)\n\nSome of our former GSoC students that still contribute to our projects have put together the following list. All of them had to go through the same learning experience. Prospective students most probably face this challenge now, so the list provides pointwise help to get into HPX smoothly.\n\n1.  The first thing we suggest is to build HPX from the source using the CMake build system. An example guide to build HPX is [here](https://hpx-docs.stellar-group.org/latest/html/manual/building_hpx.html). Various ways of building HPX (e.g., memory allocators, OTF2 traces, CUDA support) will enable you to understand the capabilities of HPX as a runtime.\n2.  Once you're acquainted with the build system, we suggest you read our [docs/wiki](https://hpx-docs.stellar-group.org/latest/html/index.html) and try to familiarize yourself with the basic terminology (e.g., _locality_, _LCO_, _futurization_, etc.).\n3.  Next, we suggest you watch talks on [HPX](https://www.youtube.com/results?search_query=HPX+cpp) on YouTube. Doing so should give you a brief overview of the motivations and implementation design of the components within HPX.\n4.  At this point, try building and playing with the [examples](https://github.com/STEllAR-GROUP/hpx/tree/master/examples) in HPX. Furthermore, we have a [basic tutorial](https://hpx-docs.stellar-group.org/latest/html/examples.html) that takes you through the features and their usage with code examples.\n5.  Going through the examples may be an overwhelming experience, so we suggest you become familiar with our way of writing code through our [summer lecture series](https://www.diehlpk.de/blog/cpp-lectures/). (Hint: Pay attention to _Lecture #4_)\n6.  The C++ style used in HPX might not seem intuitive at first, but [this guide](https://wenke-d.github.io/CPP-for-HPX/) will help you build an intuition for why it is used.\n7.  When you're familiar with basic usage, we suggest you try writing demo HPX programs (e.g., matrix-matrix multiplication). Go through our [Issue tracker](https://github.com/STEllAR-GROUP/hpx/issues) and see if you can find an issue you would like to investigate. Working on bugs is the easiest way to dive into the code base and contribute to HPX.\n8.  Dig into our currently active [GSoC issues](https://github.com/STEllAR-GROUP/hpx/issues?q=is%3Aissue+is%3Aopen+label%3A%22project%3A+GSoC%22) and Pull Requests relevant to them. Furthermore, leave comments and discuss with the corresponding authors.\n9.  We **highly recommend** joining our channel, on [Discord](https://discord.gg/eh4HTXVuWg), where you can ask questions, discuss issues, pull requests, and your potential GSoC project. Remember, questions are the key to start contributing!\n\n2025 HPX Project Ideas\n----------------------\n\n[](https://github.com/STEllAR-GROUP/hpx/wiki/Google-Summer-of-Code-(GSoC)-2025#2025-hpx-project-ideas)\n\nThere are new projects this year, and also ones revamped from previous years (legacy) that are still of interest. These projects have mentors ready and waiting to help students.\n\nCore HPX Projects\n-----------------\n\n[](https://github.com/STEllAR-GROUP/hpx/wiki/Google-Summer-of-Code-(GSoC)-2025#core-hpx-projects)\n\nThese are projects that involve making changes/improvements/extensions to the core HPX library.\n\n*   [Annotate HPX with Contracts](https://github.com/STEllAR-GROUP/hpx/wiki/Google-Summer-of-Code-(GSoC)-2025#annotate-hpx-with-contracts)\n*   [Integrate HPX algorithms with Nvidia CCCL (Thrust)](https://github.com/STEllAR-GROUP/hpx/wiki/Google-Summer-of-Code-(GSoC)-2025#integrate-hpx-algorithms-with-nvidia-cccl-thrust)\n*   [Expose HPX using C++ Modules](https://github.com/STEllAR-GROUP/hpx/wiki/Google-Summer-of-Code-(GSoC)-2025#expose-hpx-using-c-modules)\n*   [Implement the `make_receiver_for` optimization for HPX Senders](https://github.com/STEllAR-GROUP/hpx/wiki/Google-Summer-of-Code-(GSoC)-2025#implement-the-make_receiver_for-optimization-for-hpx-senders)\n*   [Implement `hpx::system_scheduler` as described in P2079 (System Execution Context)](https://github.com/STEllAR-GROUP/hpx/wiki/Google-Summer-of-Code-(GSoC)-2025#implement-hpxsystem_scheduler-as-described-in-p2079-system-execution-context)\n*   [Integrate HPX with the Tracy profiler](https://github.com/STEllAR-GROUP/hpx/wiki/Google-Summer-of-Code-(GSoC)-2025#integrate-hpx-with-the-tracy-profiler)\n*   [Use C++26 reflection for HPX serialization](https://github.com/STEllAR-GROUP/hpx/wiki/Google-Summer-of-Code-(GSoC)-2025#use-c26-reflection-for-hpx-serialization)\n*   [Implement parallel `hpx::uninitialized_relocate_*` algorithms for overlapping ranges](https://github.com/STEllAR-GROUP/hpx/wiki/Google-Summer-of-Code-(GSoC)-2025#implement-parallel-hpxuninitialized_relocate_-algorithms-for-overlapping-ranges)\n*   [Async I/O using Coroutines and S/R](https://github.com/STEllAR-GROUP/hpx/wiki/Google-Summer-of-Code-(GSoC)-2025#async-io-using-coroutines-and-sr)\n*   [\"Green out\" our Continuous Integration tests](https://github.com/STEllAR-GROUP/hpx/wiki/Google-Summer-of-Code-(GSoC)-2025#green-out-our-continuous-integration-tests)\n*   [Port HPX to iOS and Mac (M1 architecture)](https://github.com/STEllAR-GROUP/hpx/wiki/Google-Summer-of-Code-(GSoC)-2025#port-hpx-to-ios-and-mac-m1-architecture)\n*   [Study the performance of Halide applications running on HPX threads](https://github.com/STEllAR-GROUP/hpx/wiki/Google-Summer-of-Code-(GSoC)-2025#study-the-performance-of-halide-applications-running-on-hpx-threads)\n*   [Bring the HPX distributed algorithms up to date](https://github.com/STEllAR-GROUP/hpx/wiki/Google-Summer-of-Code-(GSoC)-2025#bring-the-hpx-distributed-algorithms-up-to-date)\n*   [Fix libCDS broken dependency](https://github.com/STEllAR-GROUP/hpx/wiki/Google-Summer-of-Code-(GSoC)-2025#fix-libcds-broken-dependency)\n*   [(Re-)Implement executor API on top of sender/receiver infrastructure](https://github.com/STEllAR-GROUP/hpx/wiki/Google-Summer-of-Code-(GSoC)-2025#re-implement-executor-api-on-top-of-senderreceiver-infrastructure)\n*   [Update Build System to automatically fetch HPX dependencies when not available](https://github.com/STEllAR-GROUP/hpx/wiki/Google-Summer-of-Code-(GSoC)-2025#update-build-system-to-automatically-fetch-hpx-dependencies-when-not-available)\n*   [Explicit Visualization of Accelerators for HPX Trace Visualization](https://github.com/STEllAR-GROUP/hpx/wiki/Google-Summer-of-Code-(GSoC)-2025#explicit-visualization-of-accelerators-for-hpx-trace-visualization)\n*   [Improved Scalability for HPX OTF2 Trace Visualization](https://github.com/STEllAR-GROUP/hpx/wiki/Google-Summer-of-Code-(GSoC)-2025#improved-scalability-for-hpx-otf2-trace-visualization)\n*   [Multiple File Load in HPX Trace Visualization](https://github.com/STEllAR-GROUP/hpx/wiki/Google-Summer-of-Code-(GSoC)-2025#multiple-file-load-in-hpx-trace-visualization)\n\n### Annotate HPX with Contracts\n\n[](https://github.com/STEllAR-GROUP/hpx/wiki/Google-Summer-of-Code-(GSoC)-2025#annotate-hpx-with-contracts)\n\n*   **Abstract:** Recent standardization developments indicate that C++26 will introduce contracts [P2900](https://github.com/STEllAR-GROUP/hpx/wiki/wg21.link/p2900). Their primary use is to increase language safety by providing developers with ergonomic tools to handle false assertions. They can be used to give defined behavior to pre-condition and post-condition violations of functions. The companion proposal to contracts: [P3471](https://github.com/STEllAR-GROUP/hpx/wiki/wg21.link/p3471) introduces the notion of a hardened STL, which implements the expected conditions to standard library functions (e.g. vector.front() has a precondition that vector.empty() is false). HPX provides multiple debugging mechanisms, and a rich test suite. Annotating the HPX library functions would further safety and debugging ability.\n\n*   **Additional References:**\n    *   [Proposal P2900 (Contracts)](https://github.com/STEllAR-GROUP/hpx/wiki/wg21.link/p2900)\n    *   [Proposal P3471 (Hardened STL)](https://github.com/STEllAR-GROUP/hpx/wiki/wg21.link/p3471)\n*   **Difficulty:** Medium/Advanced\n*   **Expected result:** Annotate a significant portion of HPX's public facing API with contracts.\n*   **Knowledge Prerequisite:** C++, Git\n*   **Mentor:** Hartmut Kaiser (![Image 1: hartmut%20kaiser](https://raw.githubusercontent.com/wiki/STEllAR-GROUP/hpx/pics/hartmut%20kaiser.png)), Isidoros Tsaousis-Seiras (tsa.isidoros \\[at\\] gmail.com)\n*   **Project Size:** 350 hour (medium project)\n\n### Integrate HPX algorithms with Nvidia CCCL (Thrust)\n\n[](https://github.com/STEllAR-GROUP/hpx/wiki/Google-Summer-of-Code-(GSoC)-2025#integrate-hpx-algorithms-with-nvidia-cccl-thrust)\n\n*   **Abstract:** Nvidia provides C++ abstractions for CUDA developers in their [CUDA Core Compute Libraries (CCCL)](https://github.com/NVIDIA/cccl). Specifically, Thrust implements C++ parallel algorithms that match those in the C++ Standard. Integrating Thrust with HPX would allow calling GPU Thrust algorithms through HPX parallel algorithms API, perhaps even taking advantage of HPX facilities for asynchronous execution (e.g. futures).\n*   **Difficulty:** Medium/Advanced\n*   **Expected result:** Integrate Thrust with the HPX algorithms API\n*   **Knowledge Prerequisite:** C++, Git\n*   **Mentor:** Hartmut Kaiser (![Image 2: hartmut%20kaiser](https://raw.githubusercontent.com/wiki/STEllAR-GROUP/hpx/pics/hartmut%20kaiser.png)), Panagiotis Syskakis (pansysk75 \\[at\\] gmail.com)\n*   **Project Size:** 350 hour (large project)\n\n### Expose HPX using C++ Modules\n\n[](https://github.com/STEllAR-GROUP/hpx/wiki/Google-Summer-of-Code-(GSoC)-2025#expose-hpx-using-c-modules)\n\n*   **Abstract:** [Modules](https://en.cppreference.com/w/cpp/language/modules) were introduced in C++20 as an alternative to header files for sharing declarations and definitions across translation units. C++ Modules can improve compilation times and code isolation. There are several differences when using C++ Modules, mainly they cannot export macros, and declarations have to be explicitly exported using the `export` keyword. We are interested in exposing HPX using C++ Modules (in addition to header files).\n*   **Additional References:** Rubén Pérez on bringing C++ Modules to the Boost library: [Part 1](https://anarthal.github.io/cppblog/modules), [Part 2](https://anarthal.github.io/cppblog/modules2), [Part 3](https://anarthal.github.io/cppblog/modules3)\n*   **Difficulty:** Medium/Advanced\n*   **Expected result:** Make HPX available to users through C++ Modules\n*   **Knowledge Prerequisite:** C++, Git\n*   **Mentor:** Hartmut Kaiser (![Image 3: hartmut%20kaiser](https://raw.githubusercontent.com/wiki/STEllAR-GROUP/hpx/pics/hartmut%20kaiser.png)), Panagiotis Syskakis (pansysk75 \\[at\\] gmail.com)\n*   **Project Size:** 350 hour (large project)\n\n### Implement the `make_receiver_for` optimization for HPX Senders\n\n[](https://github.com/STEllAR-GROUP/hpx/wiki/Google-Summer-of-Code-(GSoC)-2025#implement-the-make_receiver_for-optimization-for-hpx-senders)\n\n*   **Abstract:** The Senders/Receivers ([P2300](https://github.com/STEllAR-GROUP/hpx/wiki/wg21.link/P2300)) framework is constantly evolving to become more optimized and user-friendly. One of the papers accelerating this evolution is [P3425](https://github.com/STEllAR-GROUP/hpx/wiki/wg21.link/p3425) It proposes that since chained operations have a known byte-size and are stacked contiguously in memory, we can avoid holding pointers to each of them, and we can calculate their addresses on the fly based on the offsets. This presents a massive object size reduction and also aids the compiler in optimizing the code. HPX's senders would greatly benefit from implementing the proposed interface to support this feature.\n    \n*   **Additional References:**\n    \n    *   [Proposal P2300](https://github.com/STEllAR-GROUP/hpx/wiki/wg21.link/p2300)\n    *   [Proposal P3425](https://github.com/STEllAR-GROUP/hpx/wiki/wg21.link/p3425)\n*   **Difficulty:** Medium/Advanced\n    \n*   **Expected result:** Implement the `make_receiver_for` interface for `hpx::bulk` as described in [P3425](https://github.com/STEllAR-GROUP/hpx/wiki/wg21.link/p3425).\n    \n*   **Knowledge Prerequisite:** C++, Git, Concurrency\n    \n*   **Mentor:** Hartmut Kaiser (![Image 4: hartmut%20kaiser](https://raw.githubusercontent.com/wiki/STEllAR-GROUP/hpx/pics/hartmut%20kaiser.png)), Isidoros Tsaousis-Seiras (tsa.isidoros \\[at\\] gmail.com)\n    \n*   **Project Size:** 175 hour (medium project)\n    \n\n### Implement `hpx::system_scheduler` as described in P2079 (System Execution Context)\n\n[](https://github.com/STEllAR-GROUP/hpx/wiki/Google-Summer-of-Code-(GSoC)-2025#implement-hpxsystem_scheduler-as-described-in-p2079-system-execution-context)\n\n*   **Abstract:** C++26 Has evolved to include a modern API for parallelism and task scheduling ([P2300](https://github.com/STEllAR-GROUP/hpx/wiki/wg21.link/p2300)). HPX implements the proposed interface, as well as multiple schedulers. Proposal ([P2079](https://github.com/STEllAR-GROUP/hpx/wiki/wg21.link/p2079)) proposes a generic scheduler to OS-provided threads. `hpx::system_scheduler` is the HPX analogue that maps to `hpx::threads` instead, and an excellent way to expose an HPX scheduler with a Sender/Receiver interface.\n    \n*   **Additional References:**\n    \n    *   [Proposal P2300](https://github.com/STEllAR-GROUP/hpx/wiki/wg21.link/p2300)\n    *   [Proposal P2079](https://github.com/STEllAR-GROUP/hpx/wiki/wg21.link/p2079)\n*   **Difficulty:** Medium/Advanced\n    \n*   **Expected result:** Implement `system_scheduler` as described in [P2079](https://github.com/STEllAR-GROUP/hpx/wiki/wg21.link/p2079).\n    \n*   **Knowledge Prerequisite:** C++, Git, Concurrency\n    \n*   **Mentor:** Hartmut Kaiser (![Image 5: hartmut%20kaiser](https://raw.githubusercontent.com/wiki/STEllAR-GROUP/hpx/pics/hartmut%20kaiser.png)), Isidoros Tsaousis-Seiras (tsa.isidoros \\[at\\] gmail.com)\n    \n*   **Project Size:** 350 hour (large project)\n    \n\n### Integrate HPX with the Tracy profiler\n\n[](https://github.com/STEllAR-GROUP/hpx/wiki/Google-Summer-of-Code-(GSoC)-2025#integrate-hpx-with-the-tracy-profiler)\n\n*   **Abstract:** HPX is already integrated with the [Intel VTune](https://www.intel.com/content/www/us/en/developer/tools/oneapi/vtune-profiler-download.html) and [APEX](https://uo-oaciss.github.io/apex/) profilers. Adding support for using Tracy to HPX will extend the available set of introspective and embedded profiling tools for HPX applications. The integration would include annotating key functions, mutexes, thread scheduling, etc. The work would also require implementing a CMake based build system integration to simplify using Tracy with HPX and its applications.\n*   **Additional References:**\n    *   [Tracy](https://github.com/wolfpld/tracy)\n*   **Difficulty:** Medium/Advanced\n*   **Expected result:** Integrate the Tracy profiler with HPX.\n*   **Knowledge Prerequisite:** C++, Git, CMake\n*   **Mentor:** Hartmut Kaiser (![Image 6: hartmut%20kaiser](https://raw.githubusercontent.com/wiki/STEllAR-GROUP/hpx/pics/hartmut%20kaiser.png))\n*   **Project Size:** 350 hour (large project)\n\n### Use C++26 reflection for HPX serialization\n\n[](https://github.com/STEllAR-GROUP/hpx/wiki/Google-Summer-of-Code-(GSoC)-2025#use-c26-reflection-for-hpx-serialization)\n\n*   **Abstract:** HPX has already a serialization framework that allows to turn any C++ object into a byte stream for transmission over the network. Obviously this framework can turn a byte stream back into the corresponding C++ object instance. The current implementation of serialization n the general case relies on the user providing intrusive serialization functionality to the types that have to be sent over the wire. With C++26 reflection becoming available, we should add support for serializing arbitrary type (including lambdas with captures) that relies on using these new language facilities.\n*   **Additional References:**\n    *   [C++ 26 Reflecton](http://wg21.link/P2996)\n*   **Difficulty:** Medium/Advanced\n*   **Expected result:** Arbitrary C++ types can be serialized.\n*   **Knowledge Prerequisite:** C++, Git, CMake\n*   **Mentor:** Hartmut Kaiser (![Image 7: hartmut%20kaiser](https://raw.githubusercontent.com/wiki/STEllAR-GROUP/hpx/pics/hartmut%20kaiser.png))\n*   **Project Size:** 350 hour (large project)\n\n### Implement parallel `hpx::uninitialized_relocate_*` algorithms for overlapping ranges\n\n[](https://github.com/STEllAR-GROUP/hpx/wiki/Google-Summer-of-Code-(GSoC)-2025#implement-parallel-hpxuninitialized_relocate_-algorithms-for-overlapping-ranges)\n\n*   **Abstract:** HPX [implements](https://github.com/STEllAR-GROUP/hpx/tree/master/libs/core/algorithms/include/hpx/parallel/algorithms) the full set of the [C++ standard algorithms](https://en.cppreference.com/w/cpp/algorithm). This includes algorithms that copy data (e.g. `hpx::copy` copies the elements from a source range to a destination range). Recent proposals (see additional references below) suggest the addition of a new type trait (`std::is_trivially_relocatable`) that defines a new group of types that can benefit from **trivial relocation**. When relocating an object, the **relocation** algorithms will determine if it is valid to reduce the _move-constructor_ and _destructor_ call to a single `memcpy()`. In that way, relocation improves performance and increases safety. The relocation algorithms are: A) `relocate`, `relocate_at`, to operate on single objects and B) `uninitialized_relocate`, `uninitialized_relocate_backward` to operate on ranges of elements. These were added to HPX in a GSoC 2023 Contribution. However, the parallel versions of `hpx::uninitialized_relocate` and `hpx::uninitialized_relocate_backward` cannot handle overlapping ranges properly, as the forward and backward order of the algorithms is not preserved when running in parallel. The contributor is expected to correct the parallelization of these algorithms for overlapping ranges, as well as benchmark, write tests, and evaluate their solution.\n*   **Additional References:**\n    *   [P1144 Object relocation in terms of move plus destroy](http://wg21.link/p1144)\n    *   [C++Now 2019: \"Trivially Relocatable\"](https://www.youtube.com/watch?v=SGdfPextuAU)\n    *   [GSoC 2023: Relocation Semantics in HPX](https://isidorostsa.github.io/gsoc2023/)\n    *   [Possible choice for a parallelization method](https://github.com/STEllAR-GROUP/hpx/pull/6364#discussion_r1414485678)\n*   **Difficulty:** Medium/Advanced\n*   **Expected result:** Parallel implementations of `uninitialized_relocate` and `uninitialized_relocate_backward` that work on overlapping ranges, as well as written tests and benchmarks.\n*   **Knowledge Prerequisite:** C++, Git, parallel algorithms\n*   **Mentor:** Hartmut Kaiser (![Image 8: hartmut%20kaiser](https://raw.githubusercontent.com/wiki/STEllAR-GROUP/hpx/pics/hartmut%20kaiser.png)) and Isidoros Tsaousis-Seiras (tsa.isidoros _\\[at\\]_ gmail.com)\n*   **Project Size:** 175 hour (Medium/Advanced project)\n\n### Async I/O using Coroutines and S/R\n\n[](https://github.com/STEllAR-GROUP/hpx/wiki/Google-Summer-of-Code-(GSoC)-2025#async-io-using-coroutines-and-sr)\n\n*   **Abstract:** Coroutines along with S/R make a really good use case for async I/O [Ref 1](https://db.in.tum.de/~fent/papers/coroutines.pdf?lang=en). Using the recently added HPX S/R facilities to develop an interface for a relatively faster I/O example would be the goal of this project. Additionally for Linux based platforms with [`io_uring`](https://unixism.net/loti/what_is_io_uring.html) support can have even more performance benefits.\n*   **Additional References:**\n    *   [https://github.com/L-v-M/async](https://github.com/L-v-M/async)\n    *   [https://pabloariasal.github.io/2022/11/12/couring-1/](https://pabloariasal.github.io/2022/11/12/couring-1/)\n*   **Difficulty:** Easy/Medium\n*   **Expected result:** Develop a non-trivial use case using the above described tools and HPX.\n*   **Knowledge Prerequisite:** C++, CMake\n*   **Mentor:** Hartmut Kaiser (![Image 9: hartmut%20kaiser](https://raw.githubusercontent.com/wiki/STEllAR-GROUP/hpx/pics/hartmut%20kaiser.png)) and Giannis Gonidelis (gonidelis _\\[at\\]_ hotmail.com) and [Shreyas Atre](https://github.com/SAtacker) (Discord: Shreyas)\n*   **Project Size:** 175 hour (Easy/Medium project)\n\n### \"Green out\" our Continuous Integration tests\n\n[](https://github.com/STEllAR-GROUP/hpx/wiki/Google-Summer-of-Code-(GSoC)-2025#green-out-our-continuous-integration-tests)\n\n*   **Abstract:** There are tests in our Continuous Integration (CI) that are currently failing. These are mainly under our tests.regressions, tests.segmented\\_algorithms targets, performance tests and certain new compilers tests (clang-13/14, gcc-12). One can see all the tests that are failing if they randomly select an open PR and scroll down to check the list items indicated with a red 'X'. Fixing those tests would include a wide range of bug hunting tasks and creativity from the student side in order to reproduce them locally until they figure out and fix the errors.\n*   **Difficulty:** Easy/Medium\n*   **Expected result:** All tests in our CI pass (are green).\n*   **Knowledge Prerequisite:** C++, CMake, slurm\n*   **Mentor:** Hartmut Kaiser (![Image 10: hartmut%20kaiser](https://raw.githubusercontent.com/wiki/STEllAR-GROUP/hpx/pics/hartmut%20kaiser.png)) and Giannis Gonidelis (gonidelis _\\[at\\]_ hotmail.com)\n*   **Project Size:** 175 hour (Easy/Medium project)\n\n### Port HPX to iOS and Mac (M1 architecture)\n\n[](https://github.com/STEllAR-GROUP/hpx/wiki/Google-Summer-of-Code-(GSoC)-2025#port-hpx-to-ios-and-mac-m1-architecture)\n\n### Study the performance of Halide applications running on HPX threads.\n\n[](https://github.com/STEllAR-GROUP/hpx/wiki/Google-Summer-of-Code-(GSoC)-2025#study-the-performance-of-halide-applications-running-on-hpx-threads)\n\n*   **Abstract:** [Halide](https://halide-lang.org/) is a programming language designed to facilitate developing high-performance array-based code with regular access to memory on a wide range of modern architectures. Halide also makes it possible to use custom runtimes, such as HPX, in situ of the native runtime. A preliminary [work](https://github.com/STEllAR-GROUP/phylanx_halide/) has shown promising results for the HPX runtime in code generated by Halide. The goal of this project is to investigate the effectiveness of code generated by Halide in libraries that use HPX as a backend. We are notably interested in improving the performance of level 2, and 3 BLAS operations in the [Blaze](https://bitbucket.org/blaze-lib/blaze/src/master/) math library.\n    \n*   **Difficulty:** Medium\n    \n*   **Expected result:** Comprehensive performance analysis of Halide code in Blaze and other stencil-like applications.\n    \n*   **Knowledge Prerequisite:** C++\n    \n*   **Mentor:** Hartmut Kaiser (![Image 11: hartmut%20kaiser](https://raw.githubusercontent.com/wiki/STEllAR-GROUP/hpx/pics/hartmut%20kaiser.png)) and Rod Tohid (rtohid \\[at\\] cct.lsu.edu)\n    \n*   **Project Size:** 175 hour (medium project)\n    \n\n### Bring the HPX distributed algorithms up to date\n\n[](https://github.com/STEllAR-GROUP/hpx/wiki/Google-Summer-of-Code-(GSoC)-2025#bring-the-hpx-distributed-algorithms-up-to-date)\n\n*   **Abstract:** Along with the [standard parallel algorithms](https://en.cppreference.com/w/cpp/algorithm) provided by the C++ standard, HPX extends its infrastructure by providing (some of) the corresponding distributed versions of those algorithms that run on multiple nodes and on top of that they take care of communication. The set of the implemented algorithms can be found [here](https://github.com/STEllAR-GROUP/hpx/tree/master/libs/full/segmented_algorithms/include/hpx/parallel/segmented_algorithms). Due to lack of maintainance these algorithms do not compile properly to some systems according to our latest continuous integration tests and they are considered the last missing piece for HPX to be a fully integrated and portable library. Part of this project is to investigate the reasons that the tests of these algorithms fail (either on the algorithm source code side or on the integration tests side) and \"repair\" them. Providing further implementations of the remaining algorithms could facilitate as an extension of the project for the prospective students that are interested in a long-term project. [Here](https://github.com/STEllAR-GROUP/hpx/issues/1338) you can find the corresponding ticket.\n*   **Difficulty:** Easy\n*   **Expected result:** Repair the segmented algorithms so continuous integration does not fail on them and implement the remaining segmented algorithms.\n*   **Knowledge Prerequisite:** C++, CMake, CircleCI, Jenkins\n*   **Mentor:** Hartmut Kaiser (![Image 12: hartmut%20kaiser](https://raw.githubusercontent.com/wiki/STEllAR-GROUP/hpx/pics/hartmut%20kaiser.png)) and Giannis Gonidelis (gonidelis _\\[at\\]_ hotmail.com)\n*   **Project Size:** 175 hour (medium sized)\n\n### Fix libCDS broken dependency\n\n[](https://github.com/STEllAR-GROUP/hpx/wiki/Google-Summer-of-Code-(GSoC)-2025#fix-libcds-broken-dependency)\n\n*   **Abstract:** [libCDS](https://github.com/khizmax/libcds) is a Concurrent Data Structures library which provides containers that alleviate the user from taking care of synchronization. HPX provides an [integration](https://github.com/STEllAR-GROUP/hpx/blob/99a4b007f49b60809203cac9555a960cde440ef8/CMakeLists.txt#L940-L964) with libCDS which is currently broken. We are looking for a prospective developer that will bring that libCDS up to date with the current version of HPX and provide testing and benchmarking with the contemporary results.\n*   **Difficulty:** Easy\n*   **Expected result:** libCDS current version full integration with the latest HPX.\n*   **Knowledge Prerequisite:** CMake, Data Parallelism, C++.\n*   **Mentor:** Hartmut Kaiser (![Image 13: hartmut%20kaiser](https://raw.githubusercontent.com/wiki/STEllAR-GROUP/hpx/pics/hartmut%20kaiser.png)) and Giannis Gonidelis (gonidelis _\\[at\\]_ hotmail.com)\n*   **Project Size:** 350 hour (large project)\n\n### (Re-)Implement executor API on top of sender/receiver infrastructure\n\n[](https://github.com/STEllAR-GROUP/hpx/wiki/Google-Summer-of-Code-(GSoC)-2025#re-implement-executor-api-on-top-of-senderreceiver-infrastructure)\n\n*   **Abstract:** [P2300](https://wg21.link/p2300) will most likely be accepted for C++26. Our executor API (customization points) currently dispatch to an executor interface defined by wg21.link/p0443R3. All HPX facilities related to scheduling tasks (algorithms, future, dataflow, async, etc.) rely on the executor customization points to perform their operations. Although [major steps](https://github.com/STEllAR-GROUP/hpx/pull/5758) have been taken for the integration of the executors proposal to HPX there is still many facilities that need to be implemented. The project can be correlated with the [Coroutine-like interface project](https://github.com/STEllAR-GROUP/hpx/wiki/Google-Summer-of-Code-(GSoC)-2025#coroutine-like-interface) project and the P2300 proposed [awaitables](https://github.com/STEllAR-GROUP/hpx/wiki/wg21.link/p2300).\n*   **Difficulty:** Medium\n*   **Expected result:** The result should be functioning executor customization points built upon senders/receivers.\n*   **Knowledge Prerequisite:** Parallel algorithms.\n*   **Mentor:** Hartmut Kaiser (![Image 14: hartmut%20kaiser](https://raw.githubusercontent.com/wiki/STEllAR-GROUP/hpx/pics/hartmut%20kaiser.png)) and Giannis Gonidelis (gonidelis _\\[at\\]_ hotmail.com)\n*   See [issue #5219 on HPX bug tracker](https://github.com/STEllAR-GROUP/hpx/issues/5219) and the corresponding [Pull Request](https://github.com/STEllAR-GROUP/hpx/pull/5758) that's on the works already.\n*   **Project Size:** 350 hour (large project)\n\n### Coroutine-like Interface\n\n[](https://github.com/STEllAR-GROUP/hpx/wiki/Google-Summer-of-Code-(GSoC)-2025#coroutine-like-interface)\n\n### Update Build System to automatically fetch HPX dependencies when not available\n\n[](https://github.com/STEllAR-GROUP/hpx/wiki/Google-Summer-of-Code-(GSoC)-2025#update-build-system-to-automatically-fetch-hpx-dependencies-when-not-available)\n\n*   **Abstract:** HPX currently [depends on three libraries](https://hpx-docs.stellar-group.org/branches/master/html/manual/building_hpx.html#software-and-libraries). Although our build system supports a CMake [flag](https://hpx-docs.stellar-group.org/branches/master/html/manual/building_hpx.html#cmdoption-arg-HPX_WITH_FETCH_ASIO-BOOL) to fetch and use a default Asio version, there are no analogous options for Boost and HWLOC. Adding these options would make building HPX easier and would attract more prospective users. The idea is to fetch and install these dependencies with HPX if the user does not have them installed. Further improvements and automation on the build system may be proposed. Updates to the HPX documentation wrt build changes are expected. Feel free to check on the related issues [#3440](https://github.com/STEllAR-GROUP/hpx/issues/3440), [#5728](https://github.com/STEllAR-GROUP/hpx/issues/5728).\n*   **Difficulty:** Medium\n*   **Expected result:** Provide a renewed user-friendly build system environment.\n*   **Knowledge Prerequisite:** CMake\n*   **Mentor:** Nikunj Gupta (nikunj _\\[at\\]_ illinois.edu), Hartmut Kaiser (![Image 15: hartmut%20kaiser](https://raw.githubusercontent.com/wiki/STEllAR-GROUP/hpx/pics/hartmut%20kaiser.png)), and Giannis Gonidelis (gonidelis _\\[at\\]_ hotmail.com)\n*   **Project Size:** 175 hour (medium sized)\n\n### Explicit Visualization of Accelerators for HPX Trace Visualization\n\n[](https://github.com/STEllAR-GROUP/hpx/wiki/Google-Summer-of-Code-(GSoC)-2025#explicit-visualization-of-accelerators-for-hpx-trace-visualization)\n\n*   **Abstract:** HPX traces are collected with APEX and written in as OTF2 files with extensions. These trace files are typically visualized using a Gantt chart or collection of timelines. Presently, there is no differentiation between tasks executed on an accelerator versus other hardware. This project requires (1) investigation regarding what data can be collected about accelerators through HPX and APEX, and (2) design and implementation of how accelerator data is implemented in [Traveler](https://github.com/hdc-arizona/traveler-integrated). Collection will require C++, while the Traveler alterations will also require Python (backend) and Javascript (frontend).\n*   **Difficulty:** Medium-Hard\n*   **Expected result:** Traveler trace visualization includes query support and visual indicators of data regarding accelerators.\n*   **Knowledge Prerequisite:** C++, Python, Javascript.\n*   **Mentor:** Kate Isaacs (![Image 16: kate%20isaacs](https://raw.githubusercontent.com/wiki/STEllAR-GROUP/hpx/pics/kate%20isaacs.png))\n*   **Project Size:** Could be 175 hour (medium sized) or 350 hour (large sized) depending on proposal\n\n### Improved Scalability for HPX OTF2 Trace Visualization\n\n[](https://github.com/STEllAR-GROUP/hpx/wiki/Google-Summer-of-Code-(GSoC)-2025#improved-scalability-for-hpx-otf2-trace-visualization)\n\n*   **Abstract:** HPX traces are collected with APEX and written in as OTF2 files with extensions. These trace files are typically visualized using a Gantt chart or collection of timelines in [Traveler](https://github.com/hdc-arizona/traveler-integrated). The present implementation reads the entirety of the trace file before generating the visualization using one of the older APIs to do so. However, the OTF2 interface has support for partial reading of the file and a parallel backend. This project would modify the Gantt chart backend (C++/Python) to utilize these features, thus supporting larger files. The project could also modify the front end to use WebGL (Javascript) when the number of data items is large.\n*   **Difficulty:** Medium-Hard\n*   **Expected result:** Files that require more memory than on a single machine can be run from that machine. The time from program-start to visualization is decreased due to the use of large file features.\n*   **Knowledge Prerequisite:** C++, Python, Javascript.\n*   **Mentor:** Kate Isaacs (![Image 17: kate%20isaacs](https://raw.githubusercontent.com/wiki/STEllAR-GROUP/hpx/pics/kate%20isaacs.png))\n*   **Project Size:** 175 hour (medium sized)\n\n### Multiple File Load in HPX Trace Visualization\n\n[](https://github.com/STEllAR-GROUP/hpx/wiki/Google-Summer-of-Code-(GSoC)-2025#multiple-file-load-in-hpx-trace-visualization)\n\n*   **Abstract:** HPX traces are collected with APEX and written in as OTF2 files with extensions. These trace files are typically visualized using a Gantt chart or collection of timelines. We want to load multiple of these files at the same time and align the views between the like-charts for comparison in [Traveler](https://github.com/hdc-arizona/traveler-integrated). Traveler alterations will also require Python (backend) and Javascript (frontend).\n*   **Difficulty:** Medium-Hard\n*   **Expected result:** Traveler trace visualization can open multiple files and arranges views so performance can be compared across files.\n*   **Knowledge Prerequisite:** Python, Javascript.\n*   **Mentor:** Kate Isaacs (![Image 18: kate%20isaacs](https://raw.githubusercontent.com/wiki/STEllAR-GROUP/hpx/pics/kate%20isaacs.png))\n*   **Project Size:** Could be 175 hour (medium sized)\n\nPast Year Projects\n------------------\n\n[](https://github.com/STEllAR-GROUP/hpx/wiki/Google-Summer-of-Code-(GSoC)-2025#past-year-projects)\n\nThese are projects that were worked on in previous years of Google Summer of Code, but still have not been fully resolved. Contributors interested in learning more are encouraged to reach out for further details on these projects.\n\n*   [Add Vectorization to the `par_unseq` Implementations of the Parallel Algorithms](https://github.com/STEllAR-GROUP/hpx/wiki/Google-Summer-of-Code-(GSoC)-2025#add-vectorization-to-par_unseq-implementations-of-parallel-algorithms)\n*   [Add HPX to Compiler Explorer (godbolt.org)](https://github.com/STEllAR-GROUP/hpx/wiki/Google-Summer-of-Code-(GSoC)-2025#add-hpx-to-compiler-explorer-godboltorg)\n*   [Conflict (range-based) Locks](https://github.com/STEllAR-GROUP/hpx/wiki/Google-Summer-of-Code-(GSoC)-2025#conflict-range-based-locks)\n*   [Standardize and Visualize HPX Benchmarks](https://github.com/STEllAR-GROUP/hpx/wiki/Google-Summer-of-Code-(GSoC)-2025#standardize-and-visualize-hpx-benchmarks)\n*   [Rustize HPX!](https://github.com/STEllAR-GROUP/hpx/wiki/Google-Summer-of-Code-(GSoC)-2025#rustize-hpx)\n*   [Pythonize HPX!](https://github.com/STEllAR-GROUP/hpx/wiki/Google-Summer-of-Code-(GSoC)-2025#pythonize-hpx)\n*   [Create Generic Histogram Performance Counter](https://github.com/STEllAR-GROUP/hpx/wiki/Google-Summer-of-Code-(GSoC)-2025#create-generic-histogram-performance-counter)\n\n### Add Vectorization to `par_unseq` Implementations of Parallel Algorithms\n\n[](https://github.com/STEllAR-GROUP/hpx/wiki/Google-Summer-of-Code-(GSoC)-2025#add-vectorization-to-par_unseq-implementations-of-parallel-algorithms)\n\n*   **Abstract:** Our parallel algorithms currently don't support the [`par_unseq` execution policy](http://stellar-group.github.io/hpx/docs/html/hpx.html#hpx.parallel.execution.par_unseq). This project is centered around the idea to implement this execution policy for at least some of the existing algorithms (such as `for_each` and similar).\n*   **Difficulty:** Medium/Hard\n*   **Expected result:** The result should be functioning parallel algorithms when used with the `par_unseq` execution policy. The loop body should end up being vectorized.\n*   **Knowledge Prerequisite:** Vectorization, parallel algorithms.\n*   **Mentor:** Hartmut Kaiser (![Image 19: hartmut%20kaiser](https://raw.githubusercontent.com/wiki/STEllAR-GROUP/hpx/pics/hartmut%20kaiser.png)), Srinivas Yadav (vasu.srinivasvasu.14 _\\[at\\]_ gmail.com), Nikunj Gupta (nikunj _\\[at\\]_ illinois.edu), Giannis Gonidelis (gonidelis _\\[at\\]_ hotmail.com)\n*   See [issue #2271 on HPX bug tracker](https://github.com/STEllAR-GROUP/hpx/issues/2271)\n*   **Project Size:** 350 hour (large project)\n\n### Add HPX to Compiler Explorer (godbolt.org)\n\n[](https://github.com/STEllAR-GROUP/hpx/wiki/Google-Summer-of-Code-(GSoC)-2025#add-hpx-to-compiler-explorer-godboltorg)\n\n*   **Abstract:** Compiler Explorer [https://godbolt.org/](https://godbolt.org/) is a widely popular web based application which provides easy access to multiple C++ compilers and environments allowing their users to write, test and share anything from small C++ scripts to large CMake-based projects quickly. Given its versatility we thought that it would be a convenient for HPX to have an integration with Compiler Explorer in some way. A preliminary idea is that we will maintain our own fork of Compiler Explorer (which is open source) and experiment with the HPX integration locally before making the integration public through a Pull Request to Compiler Explorer. The result could even be constrained to an environment somewhat similar to Compiler Explorer just for HPX where prospective users would experiment with quick HPX scripts before downloading, building and running the whole library.\n*   **Difficulty:** Medium/Hard\n*   **Expected result:** Develop a fork of Compiler Explorer (or application with similar basis) where HPX is integrated and available for quick testing and scripting.\n*   **Knowledge Prerequisite:** C++, CMake, Compilers, Node.js\n*   **Mentor:** Hartmut Kaiser (![Image 20: hartmut%20kaiser](https://raw.githubusercontent.com/wiki/STEllAR-GROUP/hpx/pics/hartmut%20kaiser.png)) and Giannis Gonidelis (gonidelis _\\[at\\]_ hotmail.com)\n*   **Project Size:** 175 (Medium project)\n\n### Conflict (Range-Based) Locks\n\n[](https://github.com/STEllAR-GROUP/hpx/wiki/Google-Summer-of-Code-(GSoC)-2025#conflict-range-based-locks)\n\n*   **Abstract:** Some multi-threaded algorithms may require resources that must be held using a lock, but the locking mechanism may be range-based rather than absolute. Consider a large array of `N` items where a task requires some small subset of the items to be locked while a second task requires a second range. If these tasks are placed into a DAG so that `task2` can only run once `task1` has been completed, it will be inefficient when the range of items used by task2 does not overlap the range from `task1`. When many tasks operate on the range, with randomly overlapping or non-overlapping regions, DAG-based task scheduling leads to a highly inefficient strategy. We need a range based lock that can be templated over `<items>`, and that can then be locked/unlocked on ranges (of those items) and interact with our `future<>` based scheduling so that items will become _ready_ when the range they need has no locks outstanding, and so that when a task releases a lock, any other tasks that overlap the range are in turn signaled as possibly ready. (For an example of how this is used in conventional HPC programming, look up Byte Range locks in MPI for Parallel IO to a single file). A successful implementation can be extended to multi-dimensional locking \\*2D/3D etc., ideally templated over dimensions and types).\n*   **Difficulty:** Medium/Hard\n*   **Expected result:** A test application that creates arrays of items and randomly assigns tasks to operate on regions of those items with locking and schedules the tasks to operate in a non-conflicting way.\n*   **Knowledge Prerequisite:** Thread-safe programming. Futures.\n*   **Mentor:** John Biddiscombe (![Image 21: john%20biddiscombe](https://raw.githubusercontent.com/wiki/STEllAR-GROUP/hpx/pics/john%20biddiscombe.png))\n*   **Project Size:** 350 hour (large project)\n\n### Standardize and Visualize HPX Benchmarks\n\n[](https://github.com/STEllAR-GROUP/hpx/wiki/Google-Summer-of-Code-(GSoC)-2025#standardize-and-visualize-hpx-benchmarks)\n\n*   **Abstract:** HPX, as a high-performance computing framework, includes various benchmarks to measure the performance of its algorithms and runtime system. However, these benchmarks lack a standardized format and a comprehensive visualization tool that can help in analyzing performance trends over time and across different computing environments. This project aims to standardize the benchmark formats within HPX using third party benchmarking tools (recommendations below) and develop a visualization tool that can display benchmark results in an intuitive manner. The tool will used in conjunction with CI/CD to track and display performance regressions or improvements, and provide insights into the scalability and efficiency of new components.\n*   **Additional References:**\n    *   Recommended Benchmarking Frameworks: [Google Benchmark](https://github.com/google/benchmark), [Nanobench](https://nanobench.ankerl.com/)\n    *   [Nanobench in HPX](https://github.com/STEllAR-GROUP/hpx/pull/6357)\n    *   [Google Benchmark in HPX](https://github.com/SAtacker/hpx-template)\n*   **Difficulty:** Medium/Advanced\n*   **Expected result:** 1) A unified format for HPX benchmarking using chosen benchmarking framework. 2) Automating the installation of the chosen benchmarking framework in the HPX build system. 3) A visualization tool (suggestion: a python script) to display the results.\n*   **Knowledge Prerequisite:** C++, Git, Python or plotting framework of your choice\n*   **Mentor:** Hartmut Kaiser (![Image 22: hartmut%20kaiser](https://raw.githubusercontent.com/wiki/STEllAR-GROUP/hpx/pics/hartmut%20kaiser.png)) and Isidoros Tsaousis-Seiras (tsa.isidoros _\\[at\\]_ gmail.com).\n*   **Project Size:** 350 hour (Advanced project)\n\n### Rustize HPX!\n\n[](https://github.com/STEllAR-GROUP/hpx/wiki/Google-Summer-of-Code-(GSoC)-2025#rustize-hpx)\n\n*   **Abstract:** Rust is an increasingly widely adopted language used because of it's performance and apparent safety. Providing performant HPX functionality written in C++ with Rust APIs would facilitate both safety and ease of learning HPX. The student shall design and implement Rust bindings for HPX, exposing all or parts of the HPX functionality with a Rust API.\n*   **Difficulty:** Medium\n*   **Expected result:** Demonstrate functioning bindings by implementing small example scripts for different simple use cases\n*   **Knowledge Prerequisite:** C++, Rust\n*   **Mentor:** Hartmut Kaiser (![Image 23: hartmut%20kaiser](https://raw.githubusercontent.com/wiki/STEllAR-GROUP/hpx/pics/hartmut%20kaiser.png))\n*   **Project Size:** 350 hour (large project)\n\n### Pythonize HPX!\n\n[](https://github.com/STEllAR-GROUP/hpx/wiki/Google-Summer-of-Code-(GSoC)-2025#pythonize-hpx)\n\n*   **Abstract:** Python is a widely adopted language due to its simplicity. Providing performant HPX functionality written in C++ with Pythonic APIs would facilitate both usage and ease of learning HPX. The student shall design and implement Python bindings for HPX, exposing all or parts of the HPX functionality with a 'Pythonic' API. This should be possible as Python has a much more dynamic type system than C++. Using [Boost.Python](http://www.boost.org/doc/libs/1_55_0/libs/python/doc/) and/or [Pybind11](https://pybind11.readthedocs.io/en/stable/) seem to be good choices for this.\n*   **Difficulty:** Medium\n*   **Expected result:** Demonstrate functioning bindings by implementing small example scripts for different simple use cases\n*   **Knowledge Prerequisite:** C++, Python\n*   **Mentor:** Hartmut Kaiser (![Image 24: hartmut%20kaiser](https://raw.githubusercontent.com/wiki/STEllAR-GROUP/hpx/pics/hartmut%20kaiser.png))\n*   **Project Size:** 350 hour (large project)\n\n### Create Generic Histogram Performance Counter\n\n[](https://github.com/STEllAR-GROUP/hpx/wiki/Google-Summer-of-Code-(GSoC)-2025#create-generic-histogram-performance-counter)\n\nHPX User Projects\n-----------------\n\n[](https://github.com/STEllAR-GROUP/hpx/wiki/Google-Summer-of-Code-(GSoC)-2025#hpx-user-projects)\n\nThese are projects that improve code that uses HPX. In general, the primary goal with these projects is to improve user uptake of HPX by demonstrating its use in other projects, and only minor fixes/changes/extensions should be necessary for the main HPX library itself.\n\n### Implement your favorite Computational Algorithm in HPX\n\n[](https://github.com/STEllAR-GROUP/hpx/wiki/Google-Summer-of-Code-(GSoC)-2025#implement-your-favorite-computational-algorithm-in-hpx)\n\n*   **Abstract:** This is an open project for prospective students who don't want to get their hands dirty into core HPX development. The student shall utilize HPX to implement a short independent project that will utilize HPX for performance boost. The program can implement any given problem that requires heavy computational effort from the literature. [Efficient matrix multiplication](https://en.wikipedia.org/wiki/Matrix_multiplication_algorithm#Parallel_and_distributed_algorithms), sorting, [stencil variations](https://en.wikipedia.org/wiki/Stencil_(numerical_analysis)#See_also) or any AI, Physics related problem would be a good candidate. An extensive [list of use-case examples](https://github.com/STEllAR-GROUP/hpx/tree/master/examples) is already available in our source code. The goal of this project is for the student to get acquainted with HPX development and contribute to our vast range of applications.\n*   **Difficulty:** Easy\n*   **Expected result:** Implement a standalone program that utilizes HPX for performance.\n*   **Knowledge Prerequisite:** C++\n*   **Mentor:** Hartmut Kaiser (![Image 25: hartmut%20kaiser](https://raw.githubusercontent.com/wiki/STEllAR-GROUP/hpx/pics/hartmut%20kaiser.png)) and Giannis Gonidelis (gonidelis _\\[at\\]_ hotmail.com)\n*   **Project Size:** 175 hour (medium sized)\n\n### Conduct a thorough Performance Analysis on HPX Parallel Algorithms (and optimize)\n\n[](https://github.com/STEllAR-GROUP/hpx/wiki/Google-Summer-of-Code-(GSoC)-2025#conduct-a-thorough-performance-analysis-on-hpx-parallel-algorithms-and-optimize)\n\n*   **Abstract:** HPX [implements](https://github.com/STEllAR-GROUP/hpx/tree/master/libs/core/algorithms/include/hpx/parallel/algorithms) all the C++ standard [algorithms](https://en.cppreference.com/w/cpp/algorithm) along with their [ranges](https://en.cppreference.com/w/cpp/ranges) counterparts. Conducting extensive performance analysis on the existing implementations and coming up with possible optimizations would improve the efficiency of our parallel algorithms and boost HPX performance in general. The student shall expect to work both on top of HPX by writing custom benchmarks for [weak and strong scaling](https://en.wikipedia.org/wiki/Scalability#Weak_versus_strong_scaling), evaluate the results and perform source optimizations under the hood (core development).\n*   **Difficulty:** Medium\n*   **Expected result:** Boost the performance of at least one C++ standard algorithm in HPX.\n*   **Knowledge Prerequisite:** C++\n*   **Mentor:** Giannis Gonidelis (gonidelis _\\[at\\]_ hotmail.com) and Hartmut Kaiser (![Image 26: hartmut%20kaiser](https://raw.githubusercontent.com/wiki/STEllAR-GROUP/hpx/pics/hartmut%20kaiser.png))\n*   **Project Size:** 350 hour (large project)\n\nLegacy Project Ideas\n--------------------\n\n[](https://github.com/STEllAR-GROUP/hpx/wiki/Google-Summer-of-Code-(GSoC)-2025#legacy-project-ideas)\n\nThese are project ideas from previous Summer of Code years that we are still interested in working on, but it might be harder to find a mentor willing to supervise a student. Therefore, we would expect only very self-motivated and capable students to select a project from the legacy category. We cannot guarantee that we will select a project from this list unless we are quite satisfied that the student can complete the work.\n\n*   [Implement Your Favorite Parcelport Backend](https://github.com/STEllAR-GROUP/hpx/wiki/Google-Summer-of-Code-(GSoC)-2025#implement-your-favorite-parcelport-backend)\n*   [Implement A Faster Associative Container for GIDs](https://github.com/STEllAR-GROUP/hpx/wiki/Google-Summer-of-Code-(GSoC)-2025#implement-a-faster-associative-container-for-gids)\n*   [Create A Parcelport Based on WebSockets](https://github.com/STEllAR-GROUP/hpx/wiki/Google-Summer-of-Code-(GSoC)-2025#create-a-parcelport-based-on-websockets)\n*   [All to All Communications](https://github.com/STEllAR-GROUP/hpx/wiki/Google-Summer-of-Code-(GSoC)-2025#all-to-all-communications)\n*   [Distributed Component Placement](https://github.com/STEllAR-GROUP/hpx/wiki/Google-Summer-of-Code-(GSoC)-2025#distributed-component-placement)\n*   [Port Graph500 to HPX](https://github.com/STEllAR-GROUP/hpx/wiki/Google-Summer-of-Code-(GSoC)-2025#port-graph500-to-hpx)\n*   [Port Mantevo MiniApps to HPX](https://github.com/STEllAR-GROUP/hpx/wiki/Google-Summer-of-Code-(GSoC)-2025#port-mantevo-miniapps-to-hpx)\n*   [Distributed solver and load balancing for Peridynamics using asynchronous parallelism](https://github.com/STEllAR-GROUP/hpx/wiki/Google-Summer-of-Code-(GSoC)-2025#distributed-solver-and-load-balancing-for-peridynamics-using-asynchronous-parallelism)\n*   [Bug Hunter](https://github.com/STEllAR-GROUP/hpx/wiki/Google-Summer-of-Code-(GSoC)-2025#bug-hunter)\n*   [Project Template](https://github.com/STEllAR-GROUP/hpx/wiki/Google-Summer-of-Code-(GSoC)-2025#project-template)\n\nWe are looking to fund work on a number of different kinds of proposals (for more details about concrete project ideas, see below):\n\n*   Extensions to existing library features,\n*   New distributed data structures and algorithms\n*   Multiple competing proposals for the same project\n\n### Implement Your Favorite Parcelport Backend\n\n[](https://github.com/STEllAR-GROUP/hpx/wiki/Google-Summer-of-Code-(GSoC)-2025#implement-your-favorite-parcelport-backend)\n\n*   **Abstract:** The HPX runtime system uses a module called Parcelport to deliver packages over the network. An efficient implementation of this layer is indispensable and we are searching for new backend implementations based on [CCI](https://github.com/CCI/cci), [ucx](https://github.com/openucx/ucx \"Unified Communication X\"), [libfabric](https://github.com/ofiwg/libfabric \"Open Fabric Interfaces\"), or [GASNet](https://gasnet.lbl.gov/). These mentioned abstractions over various network transport layers offer the ability to do fast, one-sided RDMA transfers. The purpose of this project is to explore one of these and implement a parcelport using it.\n*   **Difficulty:** Medium-Hard\n*   **Expected result:** A proof of concept for a chosen backend implementation with performance results\n*   **Knowledge Prerequisite:** C++, Basic understanding of Network transports\n*   **Mentor:** Thomas Heller (![Image 27: thomas%20heller](https://raw.githubusercontent.com/wiki/STEllAR-GROUP/hpx/pics/thomas%20heller.png))\n*   **Project Size:** 350 hour (large project)\n\n### Implement a Faster Associative Container for GIDs\n\n[](https://github.com/STEllAR-GROUP/hpx/wiki/Google-Summer-of-Code-(GSoC)-2025#implement-a-faster-associative-container-for-gids)\n\n*   **Abstract:** The HPX runtime system uses Active Global Address Space (AGAS) to address global objects. Objects in HPX are identified by a 128-bit unique global identifier, abbreviated as a GID. The performance of HPX relies on fast lookups of GIDs in associative containers. We have experimented with binary search trees (`std::map`) and hash maps (`std::unordered_map`). However, we believe that we can implement a search data structure based on n-ary trees, tries, or radix trees that exploit the structure of GIDs such that it allows us to have faster lookup and insertion.\n*   **Difficulty:** Medium-Hard\n*   **Expected result:** Various container approaches to choose from together with realistic benchmarks to show the performance properties\n*   **Knowledge Prerequisite:** C++, Algorithms\n*   **Mentor:** Thomas Heller (![Image 28: thomas%20heller](https://raw.githubusercontent.com/wiki/STEllAR-GROUP/hpx/pics/thomas%20heller.png))\n*   **Project Size:** 350 hour (large project)\n\n### Create A Parcelport Based on WebSockets\n\n[](https://github.com/STEllAR-GROUP/hpx/wiki/Google-Summer-of-Code-(GSoC)-2025#create-a-parcelport-based-on-websockets)\n\n### All to All Communications\n\n[](https://github.com/STEllAR-GROUP/hpx/wiki/Google-Summer-of-Code-(GSoC)-2025#all-to-all-communications)\n\n### Distributed Component Placement\n\n[](https://github.com/STEllAR-GROUP/hpx/wiki/Google-Summer-of-Code-(GSoC)-2025#distributed-component-placement)\n\n### Port Graph500 to HPX\n\n[](https://github.com/STEllAR-GROUP/hpx/wiki/Google-Summer-of-Code-(GSoC)-2025#port-graph500-to-hpx)\n\n### Port Mantevo MiniApps to HPX\n\n[](https://github.com/STEllAR-GROUP/hpx/wiki/Google-Summer-of-Code-(GSoC)-2025#port-mantevo-miniapps-to-hpx)\n\n### Distributed solver and load balancing for Peridynamics using asynchronous parallelism\n\n[](https://github.com/STEllAR-GROUP/hpx/wiki/Google-Summer-of-Code-(GSoC)-2025#distributed-solver-and-load-balancing-for-peridynamics-using-asynchronous-parallelism)\n\n*   **Abstract:** Peridynamics is a reformulation of classical continuum mechanics (e.g., linear elastodynamics). The internal force at any point in the solid results from the interaction of that point with neighboring points within some distance ϵ. Typically, ϵ is much larger than the mesh size. As a result, the computation is more intensive and introduces more substantial data dependencies when partitioning the domain for parallel implementation. This project aims to develop and implement a distributed solver for Peridynamics in an existing codebase \\[1\\]. This project will benefit from the last year's GSoC student's effort on a similar goal but for a simplified nonlocal model \\[2\\]. In \\[2\\], several challenges associated with the parallelization of nonlocal models are highlighted, and algorithms are developed to address the challenges. In this project, we will apply techniques in \\[2\\] to the Peridynamics problem; first, we will implement the distributed solver; second, we will optimize the code so that compute node does the information exchange and calculation on the free degree of freedoms (DoFs) simultaneously to minimize the wait time. Finally, if possible, we will add the load balancing algorithm \\[2\\]. Here for the given compute node, free DoFs are those DoFs that do not depend on the data owned by other compute nodes. After GSoC, we intend to write a workshop paper based on this project's efforts and possibly present it at a computer science conference.\n*   **Difficulty:** Medium-Hard\n*   **Expected result:** Extend the existing shared memory code to a distributd code\n*   **Knowledge Prerequisite:** C++\n*   **Mentor:** Patrick Diehl (![Image 29: patrick%20diehl](https://raw.githubusercontent.com/wiki/STEllAR-GROUP/hpx/pics/patrick%20diehl.png)) and Prashant K. Jha (![Image 30: prashantk%jha](https://raw.githubusercontent.com/wiki/STEllAR-GROUP/hpx/pics/Prashant.png))\n*   **Project Size:** 350 hour (large project)\n\n\\[1\\] [https://github.com/nonlocalmodels/NLMech](https://github.com/nonlocalmodels/NLMech)\n\n\\[2\\] [https://arxiv.org/abs/2102.03819](https://arxiv.org/abs/2102.03819)\n\n### Port the GAP Benchmark Suite to HPX\n\n[](https://github.com/STEllAR-GROUP/hpx/wiki/Google-Summer-of-Code-(GSoC)-2025#port-the-gap-benchmark-suite-to-hpx)\n\n*   **Abstract:**\n\nGAP \\[1\\] provides a benchmark suite for the following graph algorithms:\n\n*   **Breadth-First Search (BFS)** - direction optimizing\n*   **Single-Source Shortest Paths (SSSP)** - delta stepping\n*   **PageRank (PR)** - iterative method in pull direction, Gauss-Seidel & Jacobi\n*   **Connected Components (CC)** - Afforest & Shiloach-Vishkin\n*   **Betweenness Centrality (BC)** - Brandes\n*   **Triangle Counting (TC)** - order invariant with possible degree relabelling\n\nThis project requires modifying the existing benchmark suite to use HPX's data parallelism and asynchrony capabilities. This project serves as a stepping stone to a distributed implementation. After GSoC, we intend to write a workshop paper based on this project's efforts and possibly present it at a computer science conference.\n\n*   **Difficulty:** Easy-Medium\n*   **Expected result:** Provide an HPX implementation of the existing shared memory code\n*   **Knowledge Prerequisite:** C++\n*   **Mentor:** Chris Taylor\n\n\\[1\\] [http://gap.cs.berkeley.edu/benchmark.html](http://gap.cs.berkeley.edu/benchmark.html)\n\n\\[2\\] [https://github.com/sbeamer/gapbs](https://github.com/sbeamer/gapbs)\n\n### HPX backend for OpenMPI\n\n[](https://github.com/STEllAR-GROUP/hpx/wiki/Google-Summer-of-Code-(GSoC)-2025#hpx-backend-for-openmpi)\n\n*   **Abstract:**\n\nThis project requires modifying the existing OpenMPI implementation to include HPX support. This project will improve distributed HPX application performance. After GSoC, we intend to write a workshop paper based on this project's efforts and possibly present it at a computer science conference.\n\n*   **Difficulty:** Medium\n*   **Expected result:** HPX integration with OpenMPI\n*   **Knowledge Prerequisite:** C/C++\n*   **Mentor:** Chris Taylor\n\n### Bug Hunter\n\n[](https://github.com/STEllAR-GROUP/hpx/wiki/Google-Summer-of-Code-(GSoC)-2025#bug-hunter)\n\n*   **Abstract:** In addition to our extensive ideas list, several active tickets are listed in our [issue tracker](https://github.com/STEllAR-GROUP/hpx/issues) which are worth tackling as a separate project. Feel free to talk to us if you find something interesting. A prospective student should pick at least one ticket with medium to hard difficulty and discuss how to resolve it.\n*   **Difficulty:** Medium-Hard\n*   **Expected result:** The selected issues need to be fixed\n*   **Knowledge Prerequisite:** C++\n*   **Mentor:** Thomas Heller (![Image 31: thomas%20heller](https://raw.githubusercontent.com/wiki/STEllAR-GROUP/hpx/pics/thomas%20heller.png))\n*   **Project Size:** 175 hour (medium sized)\n\nAI Project Ideas\n----------------\n\n[](https://github.com/STEllAR-GROUP/hpx/wiki/Google-Summer-of-Code-(GSoC)-2025#ai-project-ideas)\n\nThese are project ideas that involve AI methodologies in different applications.\n\n*   [Spatio-Temporal Extrapolation with Generative AI: Advancing Storm Surge Forecast Accuracy through Bias Correction in Unmonitored Areas](https://github.com/STEllAR-GROUP/hpx/wiki/Google-Summer-of-Code-(GSoC)-2025#spatio-temporal-extrapolation-with-generative-aI-advancing-storm-surge-forecast-accuracy-through-bias-correction-in-unmonitored-areas)\n*   [Spatio-Temporal Extrapolation with GNN: Advancing Storm Surge Forecast Accuracy through Bias Correction in Unmonitored Areas](https://github.com/STEllAR-GROUP/hpx/wiki/Google-Summer-of-Code-(GSoC)-2025#spatio-temporal-extrapolation-with-GNN-advancing-storm-surge-forecast-accuracy-through-bias-correction-in-unmonitored-areas)\n*   [Transformer-based Image-to-Graph Conversion](https://github.com/STEllAR-GROUP/hpx/wiki/Google-Summer-of-Code-(GSoC)-2025#Transformer-based-Image-to-Graph-Conversion)\n\n### Spatio-Temporal Extrapolation with Generative AI: Advancing Storm Surge Forecast Accuracy through Bias Correction in Unmonitored Areas\n\n[](https://github.com/STEllAR-GROUP/hpx/wiki/Google-Summer-of-Code-(GSoC)-2025#spatio-temporal-extrapolation-with-generative-ai-advancing-storm-surge-forecast-accuracy-through-bias-correction-in-unmonitored-areas)\n\n*   **Abstract:** In 2022, severe storms and tropical cyclones represented 14 out of the 18 documented weather and/or climate related disasters reported in the U.S., leading to a dreadful cost in human lives, but also to an overall financial cost exceeding 135 billion dollars \\[1\\]. The pronounced frequency and severity of such events demonstrates the critical importance of improving storm surge forecast tools in terms of both accuracy and efficiency. In this context, recent work aims to predict the systemic error between physics-based storm surge forecast model and observed water level data were obtained from gauge stations and use it to correct the simulation results on gauge stations. However, ensuring the accuracy of water level simulations across extensive and unevenly monitored locations remains a critical challenge. Given the limitations of traditional interpolation methods and the sparse distribution of gauge stations, we propose the innovative use of Generative Artificial Intelligence (AI) to address the challenge of extrapolating bias correction values to unmonitored areas. Generative AI, through its capacity to learn and mimic the distribution of complex datasets, offers a groundbreaking approach to understanding and predicting environmental variables across spatial and temporal scales. By training on available data from gauge stations, Generative AI models can generate accurate bias correction predictions for regions beyond the gauge stations. The proposed methodology leverages the latest advancements in Generative AI, including techniques like Generative Adversarial Networks (GANs) and Variational Autoencoders (VAEs), to model the complex interdependencies within the offsets data. By incorporating spatial correlations and environmental covariates, the Generative AI framework aims to produce spatially coherent and temporally consistent bias corrections across the simulation area. A case study implementing this Generative AI approach will be conducted to validate its effectiveness in enhancing model accuracy.\n    \n*   **Difficulty:** Medium-Hard\n    \n*   **Expected result:** Implementation of generative AI AI model for Spatio-Temporal Extrapolation of offsets.\n    \n*   **Knowledge Prerequisite:** Python, Machine learning basics\n    \n*   **Mentor:** Noujoud Nader (noujoude.nader _\\[at\\]_ gmail.com) and Hartmut Kaiser (![Image 32: hartmut%20kaiser](https://raw.githubusercontent.com/wiki/STEllAR-GROUP/hpx/pics/hartmut%20kaiser.png))\n    \n*   **Project Size:** 350 hour (large project)\n    \n\n### Spatio-Temporal Extrapolation with GNN: Advancing Storm Surge Forecast Accuracy through Bias Correction in Unmonitored Areas\n\n[](https://github.com/STEllAR-GROUP/hpx/wiki/Google-Summer-of-Code-(GSoC)-2025#spatio-temporal-extrapolation-with-gnn-advancing-storm-surge-forecast-accuracy-through-bias-correction-in-unmonitored-areas)\n\n*   **Abstract:** In 2022, severe storms and tropical cyclones represented 14 out of the 18 documented weather and/or climate related disasters reported in the U.S., leading to a dreadful cost in human lives, but also to an overall financial cost exceeding 135 billion dollars \\[1\\]. The pronounced frequency and severity of such events demonstrates the critical importance of improving storm surge forecast tools in terms of both accuracy and efficiency. In this context, recent work aims to predict the systemic error between physics-based storm surge forecast model and observed water level data were obtained from gauge stations and use it to correct the simulation results on gauge stations. However, ensuring the accuracy of water level simulations across extensive and unevenly monitored locations remains a critical challenge. Given the limitations of traditional interpolation methods and the sparse distribution of gauge stations, we propose the innovative use of Graph Neural Network (GNN) to address the challenge of extrapolating bias correction values to unmonitored areas. GNNs are inherently good at capturing spatial relationships and dependencies between nodes in a graph. This can be particularly useful for modeling the influence of nearby gauge stations on unmonitored areas. In addition, GNNs can integrate various types of information, including physical properties and geographical context, which can be critical for accurate extrapolation in environmental sciences. They can easily integrate heterogeneous data, making them suitable for our complex environmental systems where offset data is affected by the presence of natural barriers and geographical features, like a lake between two gauge stations.\n    \n*   **Difficulty:** Medium-Hard\n    \n*   **Expected result:** Implementation of GNN AI model for Spatio-Temporal Extrapolation of offsets.\n    \n*   **Knowledge Prerequisite:** Python, Machine learning basics\n    \n*   **Mentor:** Noujoud Nader (noujoude.nader _\\[at\\]_ gmail.com) and Hartmut Kaiser (![Image 33: hartmut%20kaiser](https://raw.githubusercontent.com/wiki/STEllAR-GROUP/hpx/pics/hartmut%20kaiser.png))\n    \n*   **Project Size:** 350 hour (large project)\n    \n\n### Transformer-based Image-to-Graph Conversion\n\n[](https://github.com/STEllAR-GROUP/hpx/wiki/Google-Summer-of-Code-(GSoC)-2025#transformer-based-image-to-graph-conversion)\n\n*   **Abstract:** The process of reconstructing graph representations from medical images, known as Image-to-Graph conversion, is a common task, particularly evident in biomedical imaging for extracting vessel graphs. Here, we propose a novel Machine Learning (ML)-based Image-to-Graph pipeline that emphasizes edge features, which are critical for applications such as blood flow simulation. This pipeline incorporates advanced ML algorithms, including the use of the **Transformer** model, to serve dual purposes: firstly, to objectively extract vascular features from medical images without relying on subjective judgment or requiring extensive user skill; and secondly, to facilitate rigorous model validation. For our model training and validation, we will utilize 3D image datasets of healthy and diseased subjects, including those of the brain and lungs.\n    \n*   **Difficulty:** Medium-Hard\n    \n*   **Expected result:** Implementation of transformer model for image to graph conversion.\n    \n*   **Knowledge Prerequisite:** Python, Machine learning basics, tranformers\n    \n*   **Mentor:** Noujoud Nader (noujoude.nader _\\[at\\]_ gmail.com) and Hartmut Kaiser (![Image 34: hartmut%20kaiser](https://raw.githubusercontent.com/wiki/STEllAR-GROUP/hpx/pics/hartmut%20kaiser.png))\n    \n*   **Project Size:** 350 hour (large project)\n    \n\n* * *\n\n### Project: Template\n\n[](https://github.com/STEllAR-GROUP/hpx/wiki/Google-Summer-of-Code-(GSoC)-2025#project-template)\n\n*   **Abstract:**\n*   **Difficulty:**\n*   **Expected result:**\n*   **Knowledge Prerequisite:**\n*   **Mentor:**\n"}