{"name":"Checker Framework","description":"Prevent programming errors via simple verification","gsoc_url":"https://summerofcode.withgoogle.com/programs/2025/organizations/checker-framework","ideas_url":"https://rawgit.com/typetools/checker-framework/master/docs/developer/new-contributor-projects.html","logo":"https://summerofcode.withgoogle.com/media/org/checker-framework/zgooweugtqicf1jx-360.png","technologies":["java","compilers","Verification","formal methods","type systems"],"topics":["software engineering","verification","bug finding","programmer productivity","type systems"],"projects":[{"project_name":"Evaluate a Type System or a Checker Framework Feature","summary":"Investigate and assess the effectiveness of a recently-written type system or feature, potentially leading to suggestions for improvement or additional research findings.","difficulty":"Medium"},{"project_name":"Annotate a Library","summary":"Add annotations to a popular Java library to facilitate easier type-checking and to uncover any potential bugs within the library.","difficulty":"Medium"},{"project_name":"Create a New Type System","summary":"Design and implement a new type system targeted at preventing specific Java programming errors and validate its effectiveness through case studies.","difficulty":"High"},{"project_name":"Enhance the Toolset","summary":"Improve the Checker Framework's existing capabilities by enhancing error messages, integrating better parsing tools, and improving dataflow analysis.","difficulty":"Medium"},{"project_name":"Preventing Injection Vulnerabilities via Specialized Taint Analysis","summary":"Customize a taint analysis tool to effectively manage and mitigate security vulnerabilities arising from untrusted data usage in applications.","difficulty":"High"},{"project_name":"Non-Empty Checker for Precise Handling of Queue.peek() and poll()","summary":"Develop a Checker that accurately infers whether a queue is empty before operations like peek() or poll() to prevent runtime exceptions.","difficulty":"Medium"},{"project_name":"Iteration Checker to Prevent NoSuchElementException","summary":"Introduce a checker that provides compile-time guarantees about the safe use of Java Iterators and prevents `NoSuchElementException` errors.","difficulty":"High"},{"project_name":"Nullness Bug Detector","summary":"Create an accessible tool that quickly finds nullness-related bugs without requiring comprehensive annotations or rigorous checks.","difficulty":"Medium"}],"jina_response":"Title: Projects for new contributors\n\nURL Source: https://rawgit.com/typetools/checker-framework/master/docs/developer/new-contributor-projects.html\n\nMarkdown Content:\n![Image 1: Checker Framework logo](https://rawgit.com/typetools/checker-framework/master/docs/developer/CFLogo.png)Contents:\n\n*   [Introduction](https://rawgit.com/typetools/checker-framework/master/docs/developer/new-contributor-projects.html#introduction)\n    *   [How to get started: do a case study](https://rawgit.com/typetools/checker-framework/master/docs/developer/new-contributor-projects.html#get-started)\n    *   [How to get help and ask questions](https://rawgit.com/typetools/checker-framework/master/docs/developer/new-contributor-projects.html#ask-questions)\n    *   [Types of projects](https://rawgit.com/typetools/checker-framework/master/docs/developer/new-contributor-projects.html#types-of-projects)\n*   [Evaluate a type system or a Checker Framework feature](https://rawgit.com/typetools/checker-framework/master/docs/developer/new-contributor-projects.html#evaluate-type-system)\n    *   [Signature strings](https://rawgit.com/typetools/checker-framework/master/docs/developer/new-contributor-projects.html#case-study-signature)\n    *   [Preventing mixed signed/unsigned computations](https://rawgit.com/typetools/checker-framework/master/docs/developer/new-contributor-projects.html#case-study-signedness)\n    *   [Whole-program type inference](https://rawgit.com/typetools/checker-framework/master/docs/developer/new-contributor-projects.html#Whole-program_type_inference)\n    *   [Sound checking by default](https://rawgit.com/typetools/checker-framework/master/docs/developer/new-contributor-projects.html#sound-by-default)\n    *   [Comparison to other tools](https://rawgit.com/typetools/checker-framework/master/docs/developer/new-contributor-projects.html#compare-other-tools)\n    *   [Android support annotations](https://rawgit.com/typetools/checker-framework/master/docs/developer/new-contributor-projects.html#case-study-android-support)\n*   [Annotate a library](https://rawgit.com/typetools/checker-framework/master/docs/developer/new-contributor-projects.html#annotate-library)\n    *   [Choosing a library to annotate](https://rawgit.com/typetools/checker-framework/master/docs/developer/new-contributor-projects.html#choose-a-library)\n    *   [Guava library](https://rawgit.com/typetools/checker-framework/master/docs/developer/new-contributor-projects.html#case-study-nullness-guava)\n*   [Create a new type system](https://rawgit.com/typetools/checker-framework/master/docs/developer/new-contributor-projects.html#create-new-type-system)\n    *   [Ownership type system](https://rawgit.com/typetools/checker-framework/master/docs/developer/new-contributor-projects.html#ownership-type-system)\n    *   [Non-Empty Checker for precise handling of Queue.peek() and poll()](https://rawgit.com/typetools/checker-framework/master/docs/developer/new-contributor-projects.html#non-empty-checker)\n    *   [Iteration Checker to prevent `NoSuchElementException`](https://rawgit.com/typetools/checker-framework/master/docs/developer/new-contributor-projects.html#iteration-checker)\n    *   [Preventing injection vulnerabilities via specialized taint analysis](https://rawgit.com/typetools/checker-framework/master/docs/developer/new-contributor-projects.html#custom-tainting-checking)\n    *   [Warn about unsupported operations](https://rawgit.com/typetools/checker-framework/master/docs/developer/new-contributor-projects.html#track-unsupported-operations)\n    *   [Overflow checking](https://rawgit.com/typetools/checker-framework/master/docs/developer/new-contributor-projects.html#overflow)\n    *   [Index checking for mutable length data structures](https://rawgit.com/typetools/checker-framework/master/docs/developer/new-contributor-projects.html#index-checker-mutable-length)\n    *   [Nullness bug detector](https://rawgit.com/typetools/checker-framework/master/docs/developer/new-contributor-projects.html#nullness-bug-detector)\n*   [Enhance the toolset](https://rawgit.com/typetools/checker-framework/master/docs/developer/new-contributor-projects.html#cf-other)\n    *   [Indicate library methods that should be used instead](https://rawgit.com/typetools/checker-framework/master/docs/developer/new-contributor-projects.html#hint-about-annotated-library-methods)\n    *   [Improving error messages](https://rawgit.com/typetools/checker-framework/master/docs/developer/new-contributor-projects.html#index-errors)\n    *   [Replace JavaParser by javac](https://rawgit.com/typetools/checker-framework/master/docs/developer/new-contributor-projects.html#javaparser-to-javac-parse)\n    *   [Java expression parser](https://rawgit.com/typetools/checker-framework/master/docs/developer/new-contributor-projects.html#java-expression-parser)\n    *   [Dataflow enhancements](https://rawgit.com/typetools/checker-framework/master/docs/developer/new-contributor-projects.html#dataflow)\n    *   [Side effect analysis, also known as purity analysis](https://rawgit.com/typetools/checker-framework/master/docs/developer/new-contributor-projects.html#Purity_analysis)\n    *   [Javadoc support](https://rawgit.com/typetools/checker-framework/master/docs/developer/new-contributor-projects.html#javadoc)\n*   [How to apply to GSoC (relevant to GSoC students only)](https://rawgit.com/typetools/checker-framework/master/docs/developer/new-contributor-projects.html#apply)\n\nIntroduction\n------------\n\nThe [Checker Framework](https://checkerframework.org/) is an innovative programming tool that prevents bugs at development time, before they escape to production.\n\nJava's type system prevents some bugs, such as ```\nint count =\n  \"hello\";\n```. However, it does not prevent other bugs, such as null pointer dereferences, concurrency errors, disclosure of private information, incorrect internationalization, out-of-bounds indices, etc. _Pluggable type-checking_ replaces a programming language's built-in type system with a more powerful, expressive one.\n\nWe have created over 20 [new type systems](https://checkerframework.org/manual/#introduction), and other people have created [over 30 more](https://checkerframework.org/manual/#third-party-checkers). A type system is not just a bug-finding tool: it is a verification tool that gives a _guarantee_ that no errors (of certain types) exist in your program. Even though it is powerful, it is easy to use. It follows the standard typing rules that programmers already know, and it fits into their workflow.\n\nThe Checker Framework is popular: it is used daily at Amazon, Google, Meta, Oracle, Uber, on Wall Street, and in other companies from big to small. It is attractive to programmers who care about their craft and the quality of their code. The Checker Framework is the motivation for Java's type annotations feature. It has received multiple awards. With this widespread use, there is a need for people to help with the project: everything from bug fixes, to new features, to case studies, to integration with other tools. We welcome your contribution!\n\nWhy should you join this project? It's popular, so you will have an impact. It makes code more robust and secure, which is a socially important purpose. You will get to scratch your own itch by creating tools that solve problems that frustrate you. It is accessible even to junior software engineers and undergraduates. (Many undergraduate students have published scientific papers, such as [Jason Waataja](https://homes.cs.washington.edu/~mernst/pubs/determinism-icse2021-abstract.html), [Vlastimil Dort](https://homes.cs.washington.edu/~mernst/pubs/array-indexing-issta2018-abstract.html) [Gene Kim](https://homes.cs.washington.edu/~mernst/pubs/format-string-issta2014-abstract.html), [Siwakorn Srisakaokul](https://homes.cs.washington.edu/~mernst/pubs/format-string-issta2014-abstract.html), [Stephanie Dietzel](https://homes.cs.washington.edu/~mernst/pubs/verigames-ftfjp2012-abstract.html), [Nathaniel Mote](https://homes.cs.washington.edu/~mernst/pubs/verigames-ftfjp2012-abstract.html), [Brian Walker](https://homes.cs.washington.edu/~mernst/pubs/verigames-ftfjp2012-abstract.html), [Eric Spishak](https://homes.cs.washington.edu/~mernst/pubs/regex-types-ftfjp2012-abstract.html), [Jaime](https://homes.cs.washington.edu/~mernst/pubs/mutability-jase2009-abstract.html) [Quinonez](https://homes.cs.washington.edu/~mernst/pubs/infer-refimmutability-ecoop2008-abstract.html), [Matthew Papi](https://homes.cs.washington.edu/~mernst/pubs/pluggable-checkers-issta2008-abstract.html), [Mah](https://homes.cs.washington.edu/~mernst/pubs/pluggable-checkers-issta2008-abstract.html)[mood](https://homes.cs.washington.edu/~mernst/pubs/ownership-immutability-oopsla2010-abstract.html) [Ali](https://homes.cs.washington.edu/~mernst/pubs/immutability-generics-fse2007-abstract.html), and [Telmo Correa](https://homes.cs.washington.edu/~mernst/pubs/pluggable-checkers-issta2008-abstract.html); and even more have made significant contributions to the tool.) Finally, we have a lot of fun on this project!\n\n**Prerequisites:** You should be very comfortable with the Java programming language and its type system. You should know how a type system helps you and how it can hinder you. You should be willing to dive into a moderately-sized codebase. You should understand fundamental object-oriented programming concepts, such as [behavioral subtyping](https://en.wikipedia.org/wiki/Liskov_substitution_principle): subtyping theory permits argument types to change contravariantly (even though Java forbids it for reasons related to overloading), whereas return types may change [covariantly](https://en.wikipedia.org/wiki/Covariance_and_contravariance_%28computer_science%29) both in theory and in Java.\n\n**Potential projects:** Most of this document lists potential projects. The projects are grouped roughly from easiest to most challenging.\n\nHow to get started: do a case study\n-----------------------------------\n\nTo **get started**, first do a case study of using the Checker Framework: that is, run the Checker Framework on some program. If you have already done so, you can skip this section. Otherwise, a case study gives you experience in using the Checker Framework, and it may reveal bugs in either the Checker Framework or in the program it is analyzing.\n\n**Why should you start with a case study?** Before you can contribute to any project, you must understand the tool from a user point of view, including its strengths, weaknesses, and how to use it. Using the Checker Framework is the best way to learn about it and determine whether you would enjoy contributing to it.\n\n**What is the purpose of a case study?** The primary result of your case study is that you will discover bugs in the subject program, or you will verify that it has no bugs (of some particular type). If you find bugs in open-source code, and let us know when they are resolved.  \nAnother outcome of your case study is that you may discover bugs, limitations, or usability problems in the Checker Framework. Please [report them](https://checkerframework.org/manual/#reporting-bugs). We'll try to fix them, or they might give you inspiration for improvements you would like to make to the Checker Framework.\n\nYou might want to start with a small program that you wrote, then repeat the process with a larger open-source program or library.\n\n1.  [Install](https://checkerframework.org/manual/#installation) the Checker Framework.\n2.  [Review the Checker Framework documentation.](https://checkerframework.org/manual/#how-to-read-this-manual)\n3.  Choose an existing library or program to type-check. A program that is about 1000 lines long is a good size for your first use of the Checker Framework, but you could use a smaller or larger one. The library or program should be under active maintenance; don't choose one that has not had a commit in the past year. You will find the case study easier if you are already familiar with the program, or if it is written in good style.\n4.  Choose one type system, from among [those distributed with the Checker Framework](https://checkerframework.org/manual/#introduction), that is appropriate for the program.\n5.  If the program is hosted on GitHub, fork it and create a new branch for your work. (Leave the master branch of your fork unchanged from upstream.)\n6.  Annotate the program, based on its documentation.  \n    Please do _not_ make changes unrelated to annotating the program, such as inserting/removing whitespace or sorting the `import` statements. Doing so bloats the size of the diffs and makes it hard to understand the essential changes.\n7.  Change the build system so that building the annotated branch runs the type-checker.\n8.  Run the type-checker. If it issues warnings, [correct them](https://checkerframework.org/manual/#handling-warnings). This might require adding more annotations, fixing bugs in the program, or suppressing warnings. Be sure that the program's test suite continues to pass. Repeat until the type-checker passes on the program.\n    *   Don't add an `if` statement that always succeeds, just to suppress a warning. Convince yourself that both branches can execute, or else don't add the `if` statement.\n    *   If you add a `@SuppressWarnings` annotation, [write it on the smallest possible scope](https://checkerframework.org/manual/#suppresswarnings-best-practices-smallest-scope) and [explain why](https://checkerframework.org/manual/#suppresswarnings-best-practices-justification) the checker warning is a false positive and you are certain the code is safe.\n9.  Share it with us; we would be happy to give you feedback.The subject line should be descriptive (not just \"Case study\", but \"Nullness case study of Apache Commons Exec library\"). You should give us access to\n    \n    *   the original (unannotated) version of the program,\n    *   the annotated version of the program, and\n    *   the exact command that runs the type-checker from the command line.The best way to give all this information is a pointer to your GitHub fork of the library.\n\nYou can also try to fix problems that you find and submit a [pull request](https://github.com/typetools/checker-framework/pulls), but that is _not_ a requirement to get started, because not all problems are good for new contributors.\n\nHow to get help and ask questions\n---------------------------------\n\nWe are very happy to answer your questions, and we are eager to interact with you! It's OK to have questions, and your questions can lead to improvements in the documentation and the tool.\n\nBefore you ask a question, read this file and the [\"Troubleshooting\" section](https://checkerframework.org/manual/#troubleshooting) of the Checker Framework manual (including [\"How to report problems\"](https://checkerframework.org/manual/#reporting-bugs)), and also search in the [Checker Framework manual](https://checkerframework.org/manual/) for the answer. Don't send us a message that says nothing but “please guide me” or “tell me how to fix this issue from the issue tracker”.\n\nWhen you ask a question, please tell us what you have tried, tell us what went wrong or where you got stuck, and ask a concrete technical question that will help you get past your problem. If you can do that, then definitely ask your question, because we don't want you to be stuck or frustrated.\n\nWhen you send email, please use standard email etiquette, such as: avoid all-caps; use a descriptive subject line; don't put multiple different topics in a single email message; start a new thread with a new subject line when you change the topic; don't clutter discussions with irrelevant remarks; don't use screenshots (unless there is a problem with a GUI), but instead cut-and-paste the output or code into your message; if you are making a guess, clearly indicate that it is a guess and your grounds for it. Bug reports should be [complete](https://checkerframework.org/manual/#reporting-bugs) and should usually be [reported](https://checkerframework.org/manual/#reporting-bugs) to the issue tracker.\n\nTypes of projects\n-----------------\n\nHere are some possible focuses for a project:\n\n*   [Evaluate](https://rawgit.com/typetools/checker-framework/master/docs/developer/new-contributor-projects.html#evaluate-type-system) a recently-written type system, or a feature used by multiple type systems.\n*   [Annotate](https://rawgit.com/typetools/checker-framework/master/docs/developer/new-contributor-projects.html#annotate-library) a popular library, so that it is easier to type-check clients of the library.\n*   [Create](https://rawgit.com/typetools/checker-framework/master/docs/developer/new-contributor-projects.html#create-new-type-system) a new type system, to prevent some Java programming error.\n*   [Enhance](https://rawgit.com/typetools/checker-framework/master/docs/developer/new-contributor-projects.html#cf-other) a type system or the Checker Framework itself.\n\nThis document gives a few suggestions in each category.\n\nEvaluate a type system or a Checker Framework feature\n-----------------------------------------------------\n\nThese projects evaluate a recently-written type system or a feature used by multiple type systems. Using the type systems on real code is our most important source of new ideas and improvements. Many people have started out “just” doing a case study but have ended up making deep, fundamental contributions and even publishing scientific papers about their discoveries.\n\nOne possible outcome is to identify weaknesses in the type-checker so that we can improve it. Another possible outcome is to provide evidence that the type-checker is effective and convince more users to adopt it. You will probably also discover defects (bugs) in the codebase being type-checked.\n\nSignature strings\n-----------------\n\nDetermine whether the [ASM library](https://asm.ow2.io/), or some other library, properly handles signature strings.\n\nSome challenging aspects of this case study are:\n\n*   Some libraries define their own new signature string formats (!), which you need to define in the Signature String Checker.\n*   Sometimes the library's documentation is incorrect, and in other cases the string format is not defined.\n\nPreventing mixed signed/unsigned computations\n---------------------------------------------\n\nAn unsigned integer's bits are interpreted differently than a signed integer's bits. It is meaningless to add a signed and an unsigned integer — the result will be nonsense bits. The same is true of printing and of other numeric operators such as multiplication and comparison.\n\nWe have a [prototype compile-time verification tool](https://checkerframework.org/manual/#signedness-checker) that detects and prevents these errors. The goal of this project is to perform case studies to determine how often programmers make signedness errors (our initial investigation suggests that this is common!) and to improve the verification tool.\n\nThe research questions are:\n\n*   How often do programmers make signedness errors?\n*   Is it feasible to automatically detect signedness errors? What techniques are useful?\n*   What is the false positive rate of a signedness verification tool — that is, false alarms from the tool?\n*   How much effort is required from a programmer?\n\nThe methodology is:\n\n*   find open-source projects that use unsigned arithmetic\n*   run the verification tool on them\n*   for each tool warning, determine whether it is a defect in the project or a limitation of the verification tool. For example, the Signedness Checker does not currently handle boxed integers and BigInteger; these haven't yet come up in case studies but could be worthwhile enhancements. You may also need to write more annotations for libraries such as the JDK.\n*   submit bug reports against the project, or improve the verification tool\n\nA good way to find projects that use unsigned arithmetic is to find a library that supports unsigned arithmetic, then search on GitHub for projects that use that library.\n\nHere are some relevant libraries.\n\n*   In the JDK's `Integer` and `Long`, these include `compareUnsigned`, `divideUnsigned`, `parseUnsignedInt`, `remainderUnsigned`, and `toUnsignedLong`.  \n    Classes like `DataInputStream`, `ObjectInputStream`, and `RandomAccessFile` have `readUnsignedByte`.  \n    `Arrays` has `compareUnsigned`. The JDK is already annotated; search for `@Unsigned` within [https://github.com/typetools/jdk](https://github.com/typetools/jdk).\n*   In Guava, see its [unsigned support](https://github.com/google/guava/wiki/PrimitivesExplained#unsigned-support), such as [UnsignedBytes](https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/primitives/UnsignedBytes.html), [UnsignedLong](https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/primitives/UnsignedLong.html), [UnsignedLongs](https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/primitives/UnsignedLongs.html), etc. Guava is already annotated; search for `@Unsigned` within [https://github.com/typetools/guava](https://github.com/typetools/guava).\n*   The [jOOU](https://github.com/jOOQ/jOOU) library consists of support for unsigned integers.\n\nAnother possibility is to find Java projects that _could_ use an unsigned arithmetic library but do not. For example, [bc-java](https://github.com/bcgit/bc-java) defines its own unsigned libraries, and some other programs might do direct bit manipulation.\n\nWhole-program type inference\n----------------------------\n\nA type system is useful because it prevents certain errors. The downside of a type system is the effort required to write the types. Type inference is the process of writing the types for a program.\n\nThe Checker Framework includes a [whole-program inference](https://checkerframework.org/manual/#whole-program-inference) that inserts type qualifiers in the user's program. It works well on some programs, but needs more enhancements to work well on all programs.\n\nSound checking by default\n-------------------------\n\nBy default, the Checker Framework is [unsound in](https://checkerframework.org/manual/#unsound-by-default) [several](https://checkerframework.org/manual/#nullness-lint) [circumstances](https://github.com/typetools/checker-framework/issues/986). “Unsound” means that the Checker Framework may report no warning even though the program can misbehave at run time.\n\nThe reason that the Checker Framework is unsound is that we believe that enabling these checks would cause too many false positive warnings: warnings that the Checker Framework issues because it cannot prove that the code is safe (even though a human can see that the code is safe). Having too many false positive warnings would irritate users and lead them not to use the checker at all, or would force them to simply disable those checks.\n\nWe would like to do studies of these command-line options to see whether our concern is justified. Is it prohibitive to enable sound checking? Or can we think of enhancements that would let us turn on those checks that are currently disabled by default?\n\nThere is no need to annotate new code for this project. Just use existing annotated codebases, such as those that are type-checked as part of the Checker Framework's [Azure Pipeline](https://github.com/typetools/checker-framework/blob/master/azure-pipelines.yml). In other words, you can start by enabling Azure Pipelines for your fork and then changing the default behavior in a branch. The Azure Pipelines job will show you what new warnings appear.\n\nMany other tools exist for prevention of programming errors, such as Error Prone, NullAway, FindBugs, JLint, PMD, and IDEs such as Eclipse and IntelliJ. These tools are not as powerful as the Checker Framework (some are bug finders rather than verification tools, and some perform a shallower analysis), but they may be easier to use. Programmers who use these tools wonder, \"Is it worth my time to switch to using the Checker Framework?\"\n\nThe goal of this project is to perform a head-to-head comparison of as many different tools as possible. You will quantify:\n\n*   the number of annotations that need to be written\n*   the number of bugs detected\n*   the number of bugs missed\n*   the number of false positive warnings\n\nThis project will help programmers to choose among the different tools — it will show when a programmer should or should not use the Checker Framework. This project will also indicate how each tool should be improved.\n\nOne place to start would be with an old version of a program that is known to contain bugs. Or, start with the latest version of the program and re-introduce fixed bugs. (Either of these is more realistic than introducing artificial bugs into the program.) A possibility would be to use the Lookup program that has been used in previous case studies.\n\nAndroid support annotations\n---------------------------\n\nAndroid uses its own annotations that are similar to some in the Checker Framework. Examples include the [Android Studio support annotations](https://tips.seebrock3r.me/annotations-to-support-your-contracts-609ff259d5df), including `@NonNull`, `@IntRange`, `@IntDef`, and others.\n\nThe goal of this project is to implement support for these annotations. That is probably as simple as creating aliased annotations by calling method `addAliasedTypeAnnotation()` in [AnnotatedTypeFactory](https://checkerframework.org/api/org/checkerframework/framework/type/AnnotatedTypeFactory.html).\n\nThen, do a case study to show the utility (or not) of pluggable type-checking, by comparison with how Android Studio currently checks the annotations.\n\nAnnotate a library\n------------------\n\nThese projects annotate a library, so that it is easier to type-check clients of the library. Another benefit is that this may find bugs in the library. It can also give evidence for the usefulness of pluggable type-checking, or point out ways to improve the Checker Framework.\n\nWhen type-checking a method call, the Checker Framework uses the method declaration's annotations. This means that in order to type-check code that uses a library, the Checker Framework needs an annotated version of the library.\n\nThe Checker Framework comes with a few [annotated libraries](https://search.maven.org/search?q=annotatedlib). Increasing this number will make the Checker Framework even more useful, and easier to use.\n\nAfter you have [chosen a library](https://rawgit.com/typetools/checker-framework/master/docs/developer/new-contributor-projects.html#choose-a-library), fork the library's source code, adjust its [build system](https://checkerframework.org/manual/#external-tools) to run the Checker Framework, and add annotations to it until the type-checker issues no warnings.\n\nBefore you get started, be sure to read [How to get started annotating legacy code](https://checkerframework.org/manual/#get-started-with-legacy-code). More generally, read the [relevant sections of the Checker Framework manual](https://checkerframework.org/manual/#how-to-read-this-manual).\n\nChoosing a library to annotate\n------------------------------\n\nThere are several ways to **choose a library** to annotate:\n\n*   The best way to choose a library is to try to annotate a program and notice that library annotations are needed in order to type-check the program.\n*   Alternately, you can choose a [popular Java library](https://docs.google.com/spreadsheets/d/17x_jKkGquEFq7LBQhS9HGXiG7iIl2AlXoPGfB6N5_bw).\n\nWhen annotating a library, it is important to type-check both the library and at least one client that uses it. Type-checking the client will ensure that the library annotations are accurate.\n\nWhatever library you choose, you will need to deeply understand its source code. You will find it easier to work with a library that is well-designed and well-documented.\n\nYou should choose a library that is not [already annotated](https://search.maven.org/search?q=org.checkerframework.annotatedlib). There are two exceptions to this.\n\n*   A library might be annotated for one type system, but you add annotations for a different type system. One advantage of this is that the library's build system is already set up to run the Checker Framework. You can tell which type systems a library is annotated for by examining its source code.\n*   A library might be annotated, but the annotations have not been verified by running the type-checker on the library source code. You would verify that the annotations in the library are correct.\n\nGuava library\n-------------\n\nGuava is already partially annotated with nullness annotations — in part by Guava's developers, and in part by the Checker Framework team. However, Guava does not yet type-check without errors. Doing so could find more errors (the Checker Framework has found nullness and indexing errors in Guava in the past) and would be a good case study to learn the limitations of the Nullness Checker.\n\nCreate a new type system\n------------------------\n\nThe Checker Framework is shipped with [about 20 type-checkers](https://checkerframework.org/manual/#introduction). Users can [create a new checker](https://checkerframework.org/manual/#creating-a-checker) of their own. However, some users don't want to go to that trouble. They would like to have more type-checkers packaged with the Checker Framework for easy use.\n\nEach of these projects requires you to design a [new type system](https://checkerframework.org/manual/#creating-a-checker), implement it, and perform case studies to demonstrate that it is both usable and effective in finding/preventing bugs.\n\nOwnership type system\n---------------------\n\nThe [lightweight ownership mechanism](https://checkerframework.org/manual/#resource-leak-annotations) of the Resource Leak Checker is not implemented as a type system, but it should be. That would enable writing ownership annotations on generic type arguments, like ```\nList<@Owning\nSocket>\n```. It would also enable changing the Resource Leak Checker so that non-`@Owning` formal parameters do not have their [`@MustCall` annotation erased](https://checkerframework.org/manual/#resource-leak-owning-fields).\n\nWe have some notes on possible implementation strategies.\n\nNon-Empty Checker for precise handling of Queue.peek() and poll()\n-----------------------------------------------------------------\n\nThe Nullness Checker issues a false positive warning for this code:\n\nimport java.util.PriorityQueue;\nimport org.checkerframework.checker.nullness.qual.NonNull;\n\npublic class MyClass {\n    public static void usePriorityQueue(PriorityQueue<@NonNull Object\\> active) {\n        while (!(active.isEmpty())) {\n            @NonNull Object queueMinPathNode = active.peek();\n        }\n    }\n}\n\nThe Checker Framework does not determine that `active.peek()` returns a non-null value in this context.\n\nThe contract of `peek()` is that it returns a non-null value if the queue is not empty and the queue contains no null values.\n\nTo handle this code precisely, the Nullness Checker needs to know, for each queue, whether it is empty. This is analogous to how the Nullness Checker tracks whether a particular value [is a key in a map](https://checkerframework.org/manual/#map-key-checker).\n\nIt should be handled the same way: by adding a new subchecker, called the Nonempty Checker, to the Nullness Checker. Its types are:\n\n*   `@UnknownNonEmpty` — the queue might or might not be empty\n*   `@NonEmpty` — the queue is definitely non-empty\n\nThere is a start at this type-checker in branch `nonempty-checker`. It:\n\n*   defines the annotations\n*   creates the integration into the Nullness Checker\n\nHowever, it is not done. (In fact, it doesn't even compile.) For information about what needs to be done, see [issue #399](https://github.com/typetools/checker-framework/issues/399).\n\nWhen you are done, the Nullness Checker should issue only the `// ::` diagnostics from `checker/tests/nullness/IsEmptyPoll.java` — no more and no fewer. You can test that by running the Nullness Checker on the file, and when you are done you should delete the `// @skip-test` line so that the file is run as part of the Checker Framework test suite.\n\nIteration Checker to prevent `NoSuchElementException`\n-----------------------------------------------------\n\nA Java program that uses an `Iterator` can throw `NoSuchElementException` if the program calls `next()` on the `Iterator` but the `Iterator` has no more elements to iterate over. Such exceptions even occur in production code (for example, in [Eclipse's rdf4j](https://github.com/eclipse/rdf4j/issues/3090)).\n\nWe would like a compile-time guarantee that this run-time error will never happen. Our analysis will statically determine whether the `hasNext()` method would return true. The basic type system has two type qualifiers: `@HasNext` is a subtype of `@UnknownHasNext`.\n\nA variable's type is `@HasNext` if the program calls `hasNext()` and it returns true. Implementing this is easy (see the [dataflow section](https://checkerframework.org/manual/#creating-dataflow) in the [\"How to create a new checker\" chapter](https://checkerframework.org/manual/#creating-a-checker)). The analysis can also permit some calls to `next()` even if the programmer has _not_ called `hasNext()`. For example, a call to `next()` is permitted on a newly-constructed iterator that is made from a non-empty collection. (This special case could build upon the [Non-Empty Checker](https://rawgit.com/typetools/checker-framework/master/docs/developer/new-contributor-projects.html#non-empty-checker) mentioned above.) There are probably other special cases, which experimentation will reveal.\n\nParts of this are already implemented, but it needs to be enhanced. Once case studies have demonstrated its effectiveness, then it can be released to the world, and a scientific paper can be written.\n\nPreventing injection vulnerabilities via specialized taint analysis\n-------------------------------------------------------------------\n\nMany security vulnerabilities result from use of untrusted data without sanitizing it first. Examples include SQL injection, cross-site scripting, command injection, and many more. Other vulnerabilities result from leaking private data, such as credit card numbers.\n\nWe have built a generalized taint analysis that can address any of these problems. However, because it is so general, it is not very useful. A user must customize it for each particular problem.\n\nThe goal of this project is to make those customizations, and to evaluate their usefulness. A specific research question is: \"To what extent is a general taint analysis useful in eliminating a wide variety of security vulnerabilities? How much customization, if any, is needed?\"\n\nThe generalized taint analysis is the Checker Framework's a [Tainting Checker](https://checkerframework.org/manual/#tainting-checker). It requires customization to a particular domain:\n\n*   rename the `@Tainted` and `@Untainted` qualifiers to something more specific (such as `@Private` or `@PaymentDetails` or `@HtmlQuoted`), and\n*   annotate libraries.\n\nThe first part of this project is to make this customization easier to do — preferably, a user will not have to change any code in the Checker Framework (the [Subtyping Checker](https://checkerframework.org/manual/#subtyping-checker) already works this way). As part of making customization easier, a user should be able to specify multiple levels of taint — many information classification hierarchies have more than two levels. For example, the US government separates information into four categories: Unclassified, Confidential, Secret, and Top Secret.\n\nThe second part of this project is to provide several examples, and do case studies showing the utility of compile-time taint checking.\n\nPossible examples include:\n\n*   SQL injection\n*   OS command injection\n*   the `@PrivacySource` and `@PrivacySink` annotations used by the Meta [Infer static analyzer](https://fbinfer.com/).\n*   information flow\n*   many of the [CWE/SANS most dangerous software programming errors](http://cwe.mitre.org/top25/) (and the \"on the cusp\" ones too)\n\nFor some microbenchmarks, see the Juliette test suite for Java from CWE.\n\nWarn about unsupported operations\n---------------------------------\n\nIn Java, some objects do not fully implement their interface; they throw `UnsupportedOperationException` for some operations. One example is [unmodifiable collections](https://docs.oracle.com/en/java/javase/11/core/creating-immutable-lists-sets-and-maps.html). They throw the exception when a mutating operation is called, such as `add`, `addAll`, `put`, `remove`, etc.\n\nThe goal of this project is to design a compile-time verification tool to track which operations might not be supported. This tool will issue a warning whenever an `UnsupportedOperationException` might occur at run time. This helps programmers to avoid run-time exceptions (crashes) in their Java programs.\n\nThe research questions include:\n\n*   Is it is possible to build a verification tool to prevent `UnsupportedOperationException`? What design is effective?\n*   How difficult is such a tool to use, in terms of programmer effort and number of false alarms?\n*   Are potential `UnsupportedOperationException` exceptions pervasive in Java programs? Is it possible to eliminate them?\n\nThe methodology is:\n\n1.  design a static (compile-time) analysis\n2.  implement it\n3.  evaluate it on open-source projects\n4.  report bugs in the projects, and improve the tool\n\nHere is a possible design, as a pluggable type system.\n\n  @Unmodifiable\n       |\n  @Modifiable\n\nIn other words, the `@Unmodifiable` type qualifier is a supertype of `@Modifiable`. This means that a ```\n@Modifiable\n    List\n``` can be used where an `@Unmodifiable List` is expected, but not vice versa.\n\n`@Modifable` is the default, and methods such as [Arrays.asList](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/Arrays.html#asList(T...)) and [Collections.emptyList](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/Collections.html#emptyList()) must be annotated to return the less-capable supertype.\n\nOverflow checking\n-----------------\n\nOverflow is when 32-bit arithmetic differs from ideal arithmetic. For example, in Java the `int` computation 2,147,483,647 + 1 yields a negative number, -2,147,483,648. The goal of this project is to detect and prevent problems such as these.\n\nOne way to write this is as an extension of the Constant Value Checker, which already keeps track of integer ranges. It even already [checks for overflow](https://checkerframework.org/manual/#value-checker-overflow), but it never issues a warning when it discovers possible overflow. Your variant would do so.\n\nThis problem is so challenging that there has been almost no previous research on static approaches to the problem. (Two relevant papers are [IntScope: Automatically Detecting Integer Overflow Vulnerability in x86 Binary Using Symbolic Execution](https://web.cse.ohio-state.edu/~lin.3021/file/IntScope_NDSS09.pdf) and [Integer Overflow Vulnerabilities Detection in Software Binary Code](https://dl.acm.org/citation.cfm?id=3136872).) Researchers are concerned that users will have to write a lot of annotations indicating the possible ranges of variables, and that even so there will be a lot of false positive warnings due to approximations in the conservative analysis. For example, will every loop that contains `i++` cause a warning that `i` might overflow? That would not be acceptable: users would just disable the check.\n\nYou can convince yourself of the difficulty by manually analyzing programs to see how clever the analysis has to be, or manually simulating your proposed analysis on a selection of real-world code to learn its weaknesses. You might also try it on [good and bad binary search code](https://ai.googleblog.com/2006/06/extra-extra-read-all-about-it-nearly.html).\n\nOne way to make the problem tractable is to limit its scope: instead of being concerned with all possible arithmetic overflow, focus on a specific use case. As one concrete application, the [Index Checker](https://checkerframework.org/manual/#index-checker) is currently unsound in the presence of integer overflow. If an integer `i` is known to be `@Positive`, and 1 is added to it, then the Index Checker believes that its type remains `@Positive`. If `i` was already `Integer.MAX_VALUE`, then the result is negative — that is, the Index Checker's approximation to it is unsound.\n\nThis project involves removing this unsoundness by implementing a type system to track when an integer value might overflow — but this only matters for values that are used as an array index. That is, checking can be restricted to computations that involve an operand of type `@IntRange`). Implementing such an analysis would permit the Index Checker to extend its guarantees even to programs that might overflow.\n\nThis analysis is important for some indexing bugs in practice. Using the Index Checker, we found 5 bugs in Google Guava related to overflow. Google marked these as high priority and fixed them immediately. In practice, there would be a run-time exception only for an array of size approximately `Integer.MAX_INT`.\n\nYou could write an extension of the Constant Value Checker, which already keeps track of integer ranges and even [determines when overflow is possible](https://checkerframework.org/manual/#value-checker-overflow). It doesn't issue a warning, but your checker could record whether overflow was possible (this could be a two-element type system) and then issue a warning, if the value is used as an array index. Other implementation strategies may be possible.\n\nHere are some ideas for how to avoid the specific problem of issuing a warning about potential overflow for every `i++` in a loop (but maybe other approaches are possible):\n\n*   The loop checks whether `i == Integer.MAX_VALUE` before incrementing. This wide-scale, disruptive code change is not acceptable.\n*   Make the default array size (the length of an unannotated array) be `@ArrayLenRange(0, Integer.MAX_VALUE-1)` rather than `@UnknownVal`, which is equivalent to `@ArrayLenRange(0, Integer.MAX_VALUE-1)`. Now, every array construction requires the client to establish that the length is not `Integer.MAX_VALUE`. I don't have a feel for whether this would be unduly burdensome to users.\n\nIndex checking for mutable length data structures\n-------------------------------------------------\n\nThe [Index Checker](https://checkerframework.org/manual/#index-checker) is currently restricted to fixed-size data structures. A fixed-size data structure is one whose length cannot be changed once it is created, such as arrays and Strings. This limitation prevents the Index Checker from verifying indexing operations on mutable-size data structures, like Lists, that have `add` or `remove` methods. Since these kind of collections are common in practice, this is a severe limitation for the Index Checker.\n\nThe limitation is caused by the Index Checker's use of types that are dependent on the length of data structures, like `@LTLengthOf(\"data_structure\")`. If `data_structure`'s length could change, then the correctness of this type might change.\n\nA naive solution would be to invalidate these types any time a method is called on `data_structure`. Unfortunately, aliasing makes this still unsound. Even more, a great solution to this problem would keep the information in the type when a method like add or remove is called on `data_structure`. A more complete solution might involve some special annotations on List that permit the information to be persisted.\n\nAnother approach would be to run a pointer analysis before type-checking, then use that information for precise information about what lists might be changed by each call to `add` or `remove`. One possible pointer analysis would be that of [Doop](https://github.com/plast-lab/doop-mirror).\n\nThis project would involve designing and implementing a solution to this problem.\n\nNullness bug detector\n---------------------\n\nVerifying a program to be free of errors can be a daunting task. When starting out, a user may be more interested in [bug-finding](https://checkerframework.org/manual/#faq-other-tools-section) than verification. The goal of this project is to create a nullness bug detector that uses the powerful analysis of the Checker Framework and its Nullness Checker, but omits some of its more confusing or expensive features. The goal is to create a fast, easy-to-use bug detector. It would enable users to start small and advance to full verification in the future, rather than having to start out doing full verification.\n\nThis could be structured as a new NullnessLight Checker, or as a command-line argument to the current Nullness Checker. Here are some differences from the real Nullness checker:\n\n*   No initialization analysis; the checker assumes that every value is initialized.\n*   No map key analysis; assume that, at every call to `Map.get`, the given key appears in the map.\n*   No invalidation of dataflow facts. Assume all method calls are pure, so method calls do not invalidate dataflow facts. Assume there is no aliasing, so field updates do not invalidate dataflow facts.\n*   Assume that boxing of primitives is `@Pure`: it returns the same value on every call.\n*   If the Checker Framework cannot infer a type argument, assume that the type argument is `@NonNull`.\n\nEach of these behaviors should be controlled by its own command-line argument, as well as being enabled in the NullnessLight Checker.\n\nThe implementation may be relatively straightforward, since in most cases the behavior is just to disable some functionality of existing checkers.\n\nTools such as FindBugs, NullAway, NullnessLight, and the Nullness Checker form a spectrum from easy-to-use bug detectors to sound verification. NullnessLight represents a new point in the design space. It will be interesting to compare these checkers:\n\n*   How much easier is it to use? For example, how many fewer annotations need to be written?\n*   How many more fewer true positives does it report — in other words, how many more false negatives does it suffer?\n*   How many fewer false positives does it report?\n\nUber's [NullAway](https://github.com/uber/NullAway) tool is also an implementation of this idea (that is, a fast, but incomplete and unsound, nullness checker). NullAway doesn't let the user specify Java Generics: it assumes that every type parameter is `@NonNull`. Does Uber's tool provide users a good introduction to the ideas that a user can use to transition to a nullness type system later?\n\nEnhance the toolset\n-------------------\n\nIndicate library methods that should be used instead\n----------------------------------------------------\n\nSometimes, the best way to avoid a checker warning is to use an annotated library method. Consider this code:\n\n@FqBinaryName String fqBinaryName = ...;\n@ClassGetName String componentType = fqBinaryName.substring(0, fqBinaryName.indexOf('\\['));\n\nThe [Signature String Checker](https://checkerframework.org/manual/#signature-checker) issues a warning, because it does not reason about arbitrary string manipulations. The code is correct, but it is in bad style. It is confusing to perform string manipulations to convert between different string representations. It is clearer and less error-prone (the above code is buggy when `fqBinaryName` is not an array type!) to use a library method, and the checker accepts this code because the library method is appropriately annotated:\n\nimport org.plumelib.reflection.Signatures;\n...\n@ClassGetName String componentType = Signatures.getArrayElementType(fqBinaryName);\n\nHowever, users may not know about the library method. Therefore, the Checker Framework should issue a warning message, along with the error message, notifying users of the library method. For example, the Signature String Checker would heuristically mention the [`Signatures.getArrayElementType()`](http://plumelib.org/reflection-util/api/org/plumelib/reflection/Signatures.html#getArrayElementType(java.lang.String)) method when it issues an error about string manipulation where some input is a [`FqBinaryName`](https://checkerframework.org/api/org/checkerframework/checker/signature/qual/FqBinaryName.html) and the output is annotated as [`ClassGetName`](https://checkerframework.org/api/org/checkerframework/checker/signature/qual/ClassGetName.html). It would behave similarly for other library methods.\n\nImproving error messages\n------------------------\n\nCompiler writers have come to realize that clarity of error messages is as important as the speed of the executable ([1](https://www.brettbecker.com/wp-content/uploads/2016/06/Becker-Effective-2016-SIGCSE.pdf), [2](https://www.mville.edu/sites/default/files/p53-munson_1.pdf), [3](https://se.inf.ethz.ch/~meyer/publications/teaching/compiler-errors.pdf), [4](https://static.barik.net/barik/publications/icse2017/PID4655707.pdf)). This is especially true when the language or type system has rich features.\n\nThe goal of this project is to improve a compiler's error messages. Here are some distinct challenges:\n\n*   Some type errors can be more concisely or clearly expressed than the standard \"found type A, expected type B\" message.\n*   Some types are complex. The error message could explain them, or link to the manual, or give suggested fixes.\n*   Compiler messages currently show the [effective type](https://checkerframework.org/manual/#effective-qualifier), which may be different than what the user wrote due to defaulting, inference, and syntactic sugar. For example, a user-written `@IndexFor(\"a\")` annotation is syntactic sugar for `@NonNegative @LTLengthOf(\"a\")`, and those types are the ones that currently appear in error messages. It might be good to show simpler types or ones that the user wrote.\n*   Some checkers combine multiple cooperating type systems; the [Nullness Checker](https://checkerframework.org/manual/#nullness-checker) and the [Index Checker](https://checkerframework.org/manual/#index-checker) are examples. If there is a problem with a variable's lower bound type, then its upper bound type should not be shown in the error message. This will make the message shorter and more specific, and avoid distracting the user with irrelevant information.\n*   When a checker has multiple type systems, a type error or the lack of one may depend on facts from multiple type systems, and this should be expressed to the user.\n\nReplace JavaParser by javac\n---------------------------\n\nThe Checker Framework uses JavaParser to parse [a Java expressions](https://checkerframework.org/manual/#java-expressions-as-arguments). However, JavaParser is buggy and poorly maintained. The goal of this project is to replace every use of JavaParser by a use of [javac-parse](https://github.com/plume-lib/javac-parse).\n\nJava expression parser\n----------------------\n\nA number of type annotations take, as an argument, [a Java expression](https://checkerframework.org/manual/#java-expressions-as-arguments). The representation for these is as a [`JavaExpression`](https://checkerframework.org/api/org/checkerframework/dataflow/expression/JavaExpression.html). The goal of this project is to remove it.\n\nThe `JavaExpression` class represents an AST. There is no need for the Checker Framework to define its own AST when the javac AST already exists and is maintained.\n\nThe goals for the project include:\n\n*   Replace every use of [`JavaExpression`](https://checkerframework.org/api/org/checkerframework/dataflow/expression/JavaExpression.html) by a use of the javac class class [`com.sun.tools.javac.tree.JCTree.JCExpression.html`](https://www.javadoc.io/static/org.kohsuke.sorcerer/sorcerer-javac/0.11/com/sun/tools/javac/tree/JCTree.JCExpression.html).\n*   Replace every use of a subclass of `JavaExpression` (listed in the \"Direct Known Subclasses\" section of the [`JavaExpression` API documentation)](https://checkerframework.org/api/org/checkerframework/dataflow/expression/JavaExpression.html) by a use of a [subclass of `JCTree.JCExpression.html`](https://www.javadoc.io/static/org.kohsuke.sorcerer/sorcerer-javac/0.11/com/sun/tools/javac/tree/JCTree.JCExpression.html). For example, replace every use of [`MethodCall`](https://checkerframework.org/api/org/checkerframework/dataflow/expression/MethodCall.html) by [`JCTree.JCMethodInvocation`](https://www.javadoc.io/static/org.kohsuke.sorcerer/sorcerer-javac/0.11/com/sun/tools/javac/tree/JCTree.JCMethodInvocation.html).\n*   Replace the [`JavaExpressionParseUtil`](https://checkerframework.org/api/org/checkerframework/framework/util/JavaExpressionParseUtil.html) class and delete `ExpressionToReceiverVisitor`.\n\nDirect replacement of the classes is not possible, or we would have done it already. For example, `JavaExpression` contains some methods that javac lacks, such as `isUnassignableByOtherCode`. As a first step before doing the tasks listed above, you may want to convert these methods from instance methods of `JavaExpression` into static methods in `JavaExpressions`, making `JavaExpression` more like a standard AST that can be replaced by JavaParser classes. You also need to decide how to store the `type` field of `JavaExpression`, when `JavaExpression` is eliminated. An alternate design (or a partial step in the refactoring process) would be to retain the `JavaExpression` class, but make it a thin wrapper around javac classes that do most of the real work.\n\nAnother aspect of this project is fixing [the issues that are labeled \"JavaExpression\".](https://github.com/typetools/checker-framework/issues?q=is%3Aopen+is%3Aissue+label%3AJavaExpressions)\n\nDataflow enhancements\n---------------------\n\nThe Checker Framework's [dataflow framework](https://checkerframework.org/manual/#creating-dataflow) ([manual here](https://checkerframework.org/manual/checker-framework-dataflow-manual.pdf)) implements flow-sensitive type refinement (local type inference) and other features. It is used in the Checker Framework and also in [Error Prone](http://errorprone.info/), [NullAway](https://github.com/uber/NullAway), and elsewhere.\n\nThere are a number of [open issues](https://github.com/typetools/checker-framework/issues?q=is%3Aopen+is%3Aissue+label%3ADataflow) — both bugs and feature requests — related to the dataflow framework. The goal of this project is to address as many of those issues as possible, which will directly improve all the tools that use it.\n\nSide effect analysis, also known as purity analysis\n---------------------------------------------------\n\nA side effect analysis reports what side effects a procedure may perform, such as what variable values it may modify. A side effect analysis is essential to other program analyses. A program analysis technique makes estimates about the current values of expressions. When a method call occurs, the analysis has to throw away most of its estimates, because the method call might change any variable. However, if the method is known to have no side effects, then the analysis doesn't need to throw away its estimates, and the analysis is more precise. Thus, an improvement to the foundational side effect analysis can improve many other program analyses.\n\nThe goal of this project is to evaluate existing side effect analysis algorithms and implementations, in order to determine what is most effective and to improve them. The research questions include:\n\n*   What side effect analysis algorithms are most effective? What are their limitations?\n*   Can the most effective algorithms be combined to become even effective? Or can their limitations be overcome?\n*   How much does accurate side effect analysis improve other programming tasks?\n\nThe methodology is to collect existing side effect analysis tools (two examples are [Soot](https://github.com/soot-oss/soot/wiki/Using-Side-Effect-Attributes) and [Geffken](https://www.semanticscholar.org/paper/Precise-Interprocedural-Side-Effect-Analysis-Report-Geffken-Saffrich/d2bd29e20c99a10ab9d0c5ecf3acaf15606407d1?p2df)); run them on open-source projects; examine the result; and then improve them.\n\nJavadoc support\n---------------\n\nCurrently, type annotations are only displayed in Javadoc if they are explicitly written by the programmer. However, the Checker Framework provides flexible defaulting mechanisms, reducing the annotation overhead. This project will integrate the Checker Framework defaulting phase with Javadoc, showing the signatures after applying defaulting rules.\n\nThere are other type-annotation-related improvements to Javadoc that can be explored, e.g. using JavaScript to show or hide only the type annotations currently of interest.\n\nHow to apply to GSoC (relevant to GSoC students only)\n-----------------------------------------------------\n\nThis section is relevant only to Google Summer of Code Students.\n\nTo **apply**, you will submit a single PDF through the Google Summer of Code website. This PDF should contain two main parts. We suggest that you number the parts and subparts to ensure that you don't forget anything, and to ensure that we don't overlook anything when reading your application. You might find it easiest to create multiple PDFs for the different parts, then concatenate them before uploading to the website, but how you create your proposal is entirely up to you.\n\n1.  The proposal itself: what project you want to work on during the summer. You might propose to do a project listed on this webpage, or you might propose a different project.The proposal should have a descriptive title, both in the PDF and in the GSoC submission system. Don't use a title like \"Checker Proposal\" or \"Proposal for GSoC\". Don't distract from content with gratuitous graphics.\n    \n    List the tasks or subparts that are required to complete your project. This will help you discover a part that you had forgotten. We do not require a detailed timeline, because you don't yet know enough to create one.\n    \n    If you want to do a case study, say what program you will do your case study on.\n    \n    If you want to create a new type system (whether one proposed on this webpage or one of your own devising), then your proposal should include the type system's user manual. You don't have to integrate it in the Checker Framework repository (in other words, use any word processor or text editor you want to create a PDF file you will submit), but you should describe your proposed checker's [parts](https://checkerframework.org/manual/#creating-parts-of-a-checker) in precise English or simple formalisms, and you should follow the suggested [structure](https://checkerframework.org/manual/#creating-documenting-a-checker).\n    \n    If you want to do exactly what is already listed on this page, then just say that (but be specific about which one!), and it will not hurt your chances of being selected. However, show us what progress you have made so far. You might also give specific ideas about extensions, about details that are not mentioned on this webpage, about implementation strategies, and so forth.\n    \n    Never literally cut-and-paste text that was not written by you, because that would be plagiarism. If you quote from text written by someone else, give proper credit. Don't submit a proposal that is just a rearrangement of text that already appears on this page or in the Checker Framework manual, because it does not help us to assess your likelihood of being successful.\n    \n2.  Your qualifications. Please convince us that you are likely to be successful in your proposed summer project.\n    1.  A URL that points to a code sample. Don't write any new code, but provide code you wrote in the past, such as for a class assignment or a project you have worked on outside class. It does not need to have anything to do with the Checker Framework project. It should be your own personal work. The purpose is to assess your programming skills so we can assign you to an appropriate project. A common problem is to submit undocumented code; we expect every programmer to write documentation when working on the Checker Framework. Don't put a lot of different files in Google Drive and share that URL; it's better to upload a single `.zip` file or provide a GitHub URL.\n    2.  What you have done to prepare yourself for working with the Checker Framework during the summer. You may wish to structure this as a list. Examples of items in the list include:\n        *   A URL for code you have annotated as a case study. Please indicate the original unannotated code, the annotated code, and the exact command to run the type-checker from the command line. Ensure that the GSoC mentors can compile your code. (It is acceptable to use the same code, or different code, for this item and the code sample above.)You should have shared the case study as soon as you finished it or as soon as you had a question that is not answered in the [manual](https://checkerframework.org/manual/); don't wait until you submit your proposal, because that does not give us a chance to help you with feedback.\n            \n        *   URLs for bugs or pull requests that you have filed.\n        *   Information about other projects you have done, or classes you have taken, that prepare you for your proposed summer task. This is optional. If something already appears in your resume, don't repeat it here; we will see it in your resume.\n    3.  A resume. A [resume](https://en.wikipedia.org/wiki/R%C3%A9sum%C3%A9) contains a brief description of your skills and your job or project experience. It will often list classes you have taken so far and your GPA. It should not be longer than one page.\n    4.  An unofficial transcript or grade report (don't spend money for an official one).\n\nThe **best way** to impress us is by doing a thoughtful job in the case study. The case study is even more important than the proposal text, because it shows us your abilities. The case study may result in you submitting issues against the issue tracker of the program you are annotating or of the Checker Framework. Pull requests against our GitHub project are a plus but are not required: good submitted bugs are just as valuable as bug fixes! You can also make a good impression by correctly answering questions from other students on the GSoC mailing list.\n\nSome GSoC projects have a requirement to fix an issue in the issue tracker. We do not, because it is unproductive. Don't try to start fixing issues before you understand the Checker Framework from the user point of view, which will not happen until you have completed a case study on an open-source program. You may discuss your ideas with us by sending mail to [checker-framework-gsoc@googlegroups.com](https://groups.google.com/g/checker-framework-gsoc).\n\nGet feedback! Feel free to [ask questions](https://rawgit.com/typetools/checker-framework/master/docs/developer/new-contributor-projects.html#ask-questions) to make your application more competitive. We want you to succeed. Historically, students who start early and get feedback are most successful. You can submit a draft proposal via the Google Summer of Code website, and we will review it. We do _not_ receive any notification when you submit a draft proposal, so if you want feedback, please tell us that. Also, we can only see draft proposals; we cannot see final proposals until after the application deadline has passed.\n\nPlease do not violate the guidelines in the [How to get help and ask questions](https://rawgit.com/typetools/checker-framework/master/docs/developer/new-contributor-projects.html#ask-questions) section of this document. If you do so, you are disqualified you from participating in GSoC, because it shows that you do not read instructions, and you haven't thought about the problem nor tried to solve it.\n"}