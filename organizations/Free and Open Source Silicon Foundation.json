{"name":"Free and Open Source Silicon Foundation","description":"Working together for Free and Open Source Silicon","gsoc_url":"https://summerofcode.withgoogle.com/programs/2025/organizations/free-and-open-source-silicon-foundation","ideas_url":"https://fossi-foundation.org/gsoc/gsoc25-ideas","logo":"https://summerofcode.withgoogle.com/media/org/free-and-open-source-silicon-foundation/aie951otsp3xucok.png","technologies":["verilog","vhdl","risc-v","compiler"],"topics":["hardware","debug","simulation","electronic design tools"],"projects":[{"project_name":"ZynqParrot RISC-V Tracer","summary":"Integrate a RISC-V trace implementation into the ZynqParrot environment to help with performance and debugging of FPGA-based accelerator development.","difficulty":"Intermediate"},{"project_name":"Surfer memory and wide array support","summary":"Enhance the Surfer waveform viewer by adding a UI element for visualizing memory content as a table, with features to highlight changes over time.","difficulty":"Intermediate"},{"project_name":"cocotb v2 Code Migration Helper","summary":"Develop a tool to assist users and developers in migrating their code to the new cocotb v2.x release, handling breaking changes.","difficulty":"Intermediate/Advanced"},{"project_name":"Generate Counter Examples for Bounded Model Checks in CIRCT","summary":"Extend the CIRCT bounded model checking tool to produce counter-examples that aid in debugging hardware designs by providing signal traces for assertions.","difficulty":"Medium"},{"project_name":"Spike + Sim-X","summary":"Interface the Spike RISC-V simulator with Sim-X to allow functional simulation of a RISC-V CPU and a GPGPU in a shared-memory architecture.","difficulty":"Intermediate"},{"project_name":"OpenRISC Linux Feature Development","summary":"Develop and test enhancements to the Linux kernel for OpenRISC, including the cacheinfo API and tracing facilities.","difficulty":"Advanced"},{"project_name":"Generic MinimumLinuxBoot for RTL Simulations","summary":"Boot Linux in Qemu, save memory states, and continue simulations in an RTL environment; focusing on state management for OpenPiton.","difficulty":"Medium/Advanced"},{"project_name":"Using AI to Improve Open-Source IP","summary":"Refactor open-source Verilog code using AI to improve its quality and facilitate its conversion to more efficient TL-Verilog models.","difficulty":"Intermediate/Advanced"},{"project_name":"Metro-MPI++","summary":"Implement enhancements to the Metro-MPI framework to improve RTL simulation distribution and explore automatic partitioning for better performance.","difficulty":"Medium/Advanced"},{"project_name":"OpenLane Web-based Graphical User Interface","summary":"Create a web-based GUI to simplify the construction of custom flows in the OpenLane RTL-to-GDSII process for users with limited coding experience.","difficulty":"Beginner or Intermediate"},{"project_name":"LiteX SMP SoC for OpenRISC","summary":"Develop a multicore OpenRISC LiteX SoC capable of running Linux and document the process, aiding users in setting up the architecture.","difficulty":"Advanced"},{"project_name":"Improve CIRCT's Verilog Frontend","summary":"Enhance the CIRCT project’s Verilog frontend by adding missing features to support new benchmarks and improve overall parsing quality.","difficulty":"Advanced"},{"project_name":"Architectural Improvements to OpenPiton+Ariane for RISC-V Profile Compliance","summary":"Co-optimize the OpenPiton and Ariane platforms to support RISC-V profile compliance, enhancing performance for FPGA and silicon implementations.","difficulty":"Intermediate"},{"project_name":"Cohort++","summary":"Improve the OpenPiton memory hierarchy and Cohort framework interactions to enhance hardware-software communication efficiency.","difficulty":"Medium/Advanced"},{"project_name":"Seamless multi-frontend support for OpenLane","summary":"Enhance OpenLane's capability to support mixed-language frontends for RTL synthesis, improving user flexibility and functionality.","difficulty":"Intermediate"},{"project_name":"OpenRISC Benchmarking and Performance improvements","summary":"Benchmark and improve the performance of various OpenRISC cores by documenting results and optimizing memory access.","difficulty":"Advanced"},{"project_name":"OpenLane Flow Declaration GUI","summary":"Develop a user-friendly web-based GUI for OpenLane to help novice users create and manage complex flow declaration with ease.","difficulty":"Beginner to Intermediate"},{"project_name":"Adding TL-Verilog Support to Surfer","summary":"Enhance the Surfer waveform viewer to support TL-Verilog features, improving the debugging experience for hardware designers.","difficulty":"Medium/advanced"},{"project_name":"Device-Under-Test Python Typing Stub Generator for cocotb tests","summary":"Create a generator that uses existing introspection features in cocotb to produce Python typing stubs for DUT signals, aiding in test development.","difficulty":"Beginner to Intermediate"}],"jina_response":"Title: Google Summer of Code 2025 - Ideas for Projects\n\nURL Source: https://fossi-foundation.org/gsoc/gsoc25-ideas\n\nMarkdown Content:\nFOSSi Foundation is applying as an umbrella organization for Google Summer of Code 2025. That means that we give FOSSi community projects the chance to participate in the program. Below you can find a list of ideas that community mentors had, but mentees are encouraged to propose their own ideas. These projects are mostly open-ended and can be tailored to your level of experience, assuming that you have the appropriate set of required skills for the particular project idea.\n\nWhether you’re an aspiring mentee or mentor, feel free to contact us, either (for mentees) by directly contacting mentors or (for mentors) through the private GSoC-specific mailing list [gsoc@fossi-foundation.org](mailto:gsoc@fossi-foundation.org).\n\nLooking forward to meet you all!\n\n*   TOC {:toc}\n\n[ZynqParrot RISC-V Tracer](https://fossi-foundation.org/gsoc/gsoc25-ideas#zynqparrot-risc-v-tracer)\n---------------------------------------------------------------------------------------------------\n\nZynqParrot ([https://github.com/black-parrot-hdk/zynq-parrot](https://github.com/black-parrot-hdk/zynq-parrot)) is a framework for doing self-contained, FPGA-based \"hostless\" ASIC accelerator development. It is designed to be extremely general and has been used to prototype IP from individual ASIC/FPGA cores to full multicore processors. In addition, ZynqParrot has been used to bringup N=1 ASIC silicon in the lab.\n\nRISC-V provides a trace format specification ([https://github.com/riscv-non-isa/riscv-trace-spec](https://github.com/riscv-non-isa/riscv-trace-spec)) which can be used for diagnostic performance and debugging. This project will design and integrate a RISC-V Trace implementation into the ZynqParrot environment, requiring SystemVerilog implementation + testing, Block Diagram (Vivado IPI) design and well as writing C++ driver to work in both Co-Simulation and Co-Emulation.\n\n_Skill level:_ intermediate\n\n_Project length:_ medium (175 hours)\n\n_Mentors:_ [Dan Petrisko](mailto:petrisko@cs.washington.edu)\n\n_Language/Tools:_ SystemVerilog, C++, some knowledge of computer architecture. RISC-V knowledge preferred but not required. FPGA tools such as Vivado strongly encouraged but not required.\n\n### [Surfer memory and wide array support](https://fossi-foundation.org/gsoc/gsoc25-ideas#surfer-memory-and-wide-array-support)\n\nSurfer ([https://surfer-project.org](https://surfer-project.org/)) is an open source waveform viewer designed to be snappy and extensible. Waveform viewers work well for visualizing individual signals, but for large arrays or memories users are often more interested in changes to individual elements rather than the whole array.\n\nFor this, a separate UI element where memory content can be visualized as a table would be much more useful. Beyond just visualizing the content, also having the ability to highlights elements that have changed between timestamps or around the cursor would be extra useful.\n\n_Skill level:_ intermediate\n\n_Project Length:_ medium (175 hours)\n\n_Mentors:_ [Frans Skarman](mailto:frans.skarman@liu.se) [Oscar Gustafsson](mailto:oscar.gustafsson@liu.se)\n\n_Languages/Tools:_ Rust. Familiarity with hardware design is helpful to have some context of what the tool is used for is helpful, but the project itself is pure software. Some familiarity with egui is also helpful though certainly not required.\n\n### [cocotb v2 Code Migration Helper](https://fossi-foundation.org/gsoc/gsoc25-ideas#cocotb-v2-code-migration-helper)\n\nThe upcoming cocotb v2.x release will have quite some breaking changes (see [https://docs.cocotb.org/en/latest/release\\_notes.html](https://docs.cocotb.org/en/latest/release_notes.html)), so users and extension developers will have to actively migrate existing code.\n\nA code migration helper tool would be helpful, even if it is not perfect.\n\nSome links:\n\n*   [https://libcst.readthedocs.io/](https://libcst.readthedocs.io/)\n*   [https://lukeplant.me.uk/blog/posts/tools-for-rewriting-python-code/](https://lukeplant.me.uk/blog/posts/tools-for-rewriting-python-code/)\n\n_Skill level:_ Intermediate/Advanced\n\n_Duration:_ medium (175 hours)\n\n_Language/Tools:_ Python, cocotb\n\n_Mentor:_ [Kaleb Barrett](mailto:dev.ktbarrett@gmail.com)\n\n### [Generate Counter Examples for Bounded Model Checks in CIRCT](https://fossi-foundation.org/gsoc/gsoc25-ideas#generate-counter-examples-for-bounded-model-checks-in-circt)\n\nThe [CIRCT](https://github.com/llvm/circt) project has its own bounded model checking tool, circt-bmc. It takes a hardware design described in CIRCT's MLIR dialects and translates it into a program that uses the Z3 SMT solver to formally prove assertions. If it finds a way how assertions can be violated, it simply terminates with an error message. This is not very useful for a user that is trying to debug a hardware design that they have written. Instead, we would like circt-bmc to produce a counter-example, essentially a signal trace that shows and example of how the assertions can be violated. The Z3 SMT solver actually provides a counter-example as part of its checking, circt-bmc just does not use that yet.\n\nWe would love you to extend circt-bmc with a counter-example feature that produces a signal trace for violated assertions, ideally a VCD waveform as a starting point. This will require you to modify the lowering pass that translates a hardware design to Z3 solver calls: in addition to the asserts that need to be checked, you will also want to translate any named ports, wires, registers into the corresponding Z3 solver expressions. The bounded model check can then take a snapshot of all these expressions in every time step. When Z3 finds a counter-example, you can go through every time step, evaluate all the solver expression for all user-visible names, and write them to a waveform.\n\nThis may also be an excellent opportunity to introduce a waveform writing library for CIRCT. Eventually, we'd want different tools in CIRCT to be able to write various waveform formats such as VCD, FST, etc. It would be great if there is a common interface for waveform writers, and if CIRCT could then provide various implementations for different waveform formats. Tools like Arcilator, circt-bmc, and circt-lec would then use this library to produce signal traces.\n\nCIRCT is based on MLIR and LLVM, and are implemented in C++. So you'll definitely want to have some experience writing C++ code, since LLVM-based projects often follow a fairly peculiar and performance-conscious style of C++. You may also benefit from knowing a little bit about SAT and SMT solvers, and how bounded model checks can be implemented incrementally using these solvers.\n\n_Skill Level:_ Medium\n\n_Duration:_ 175 hours or 350 hours\n\n_Language/Tools:_ C++, CIRCT, MLIR, LLVM\n\n_Mentor:_ [Fabian Schuiki](mailto:fabian@schuiki.ch), [Martin Erhart](https://fossi-foundation.org/gsoc/maerhart@outlook.com), and others in the CIRCT community\n\n### [Spike + Sim-X](https://fossi-foundation.org/gsoc/gsoc25-ideas#spike-sim-x)\n\nThe project is to interface [Spike](https://github.com/riscv-software-src/riscv-isa-sim) with [Sim-X](https://github.com/vortexgpgpu/vortex/tree/master/sim/simx). Spike is a functional RISC-V ISA simulator and Sim-X is a high-level simulator for the [Vortex GPGPU](https://github.com/vortexgpgpu/vortex/).\n\nExisting work allowed us to integrate the Vortex GPGPU RTL in the OpenPiton multi-core research platform ([https://cea.hal.science/cea-04772235/document](https://cea.hal.science/cea-04772235/document)). To ease programming though, we would like to test software correctness using a high-level simulator. It would be faster than relying on RTL simulation. Interfacing Spike with Sim-X would allow us to simulate functionaly our heterogeneous CPUs+GPU shared-memory architecture, hence allowing us to ease future software development.\n\n_Skill level:_ Intermediate\n\n_Duration:_ medium (175 hours)\n\n_Language/Tools:_ C++, RISC-V GNU Cross-compiler, Vortex LLVM compiler\n\n_Mentor:_ [Davy Million](mailto:davy.million@cea.fr)\n\n### [OpenRISC Linux Feature Development](https://fossi-foundation.org/gsoc/gsoc25-ideas#openrisc-linux-feature-development)\n\nThe OpenRISC Linux kernel support is under constant development but there are certain Linux facilities that are not yet used or available on the OpenRISC platform.\n\nThis project will have the student developing, testing and sending patches up to the Linux kernel. This includes:\n\n*   Use the cacheinfo API for reporting CPU details in OpenRISC Linux.\n*   Add [tracing facilities](https://docs.kernel.org/trace/index.html) to OpenRISC Linux including: jump\\_label, ftrace, kprobes, eBPF etc.\n\n_Skill level:_ Advanced\n\n_Project Length:_ large\n\n_Language/Tools:_ Linux, C, Assembly, OpenRISC architecture\n\n_Mentor:_ [Stafford Horne](mailto:shorne@gmail.com)\n\n### [Generic MinimumLinuxBoot for RTL Simulations](https://fossi-foundation.org/gsoc/gsoc25-ideas#generic-minimumlinuxboot-for-rtl-simulations)\n\nThis project consists of booting Linux in Qemu, save the memory state, thencontinue the simulation in an RTL Simulation of OpenPiton. The first part of the project consists of understanding what states need to be saved, probably a combination of the TLB and MMU states as an starting point could be enough. Then, this state needs to be saved in a file format that the checkpoint mechanism of Verilator understand or create a synthetic benchmark that makes the proper MMU configuration. The second part of the project is adding the necessary support in OpenPiton Simulation infrastructure to continue the simulation and being able to launch some applications.\n\nOpenPiton uses different languages like Verilog, Python, Perl, and C. Verilator C++. Additionally, some background in hardware design is useful.\n\n_Skill Level:_ Medium/Advanced\n\n_Duration:_ 350 hours\n\n_Language/Tools:_ Verilog, C++, SystemVerilog\n\n_Mentors:_ [Guillem López Paradís](mailto:guillem.lopez@bsc.es) and [Jonathan Balkind](mailto:jbalkind@ucsb.edu)\n\n### [Using AI to Improve Open-Source IP](https://fossi-foundation.org/gsoc/gsoc25-ideas#using-ai-to-improve-open-source-ip)\n\nWhat if we could instantly improve all the existing open-source Verilog by reducing its size, improving its maintainability, making it more configurable, identifying bugs, and creating visualization for it? How could you possibly do all those things over one summer as a student? Well, you can't. But you could help to make significant strides in that direction.\n\nTransaction-Level Verilog (TL-Verilog) models are smaller, cleaner, and less bug-prone than their Verilog counterparts. But there's not much TL-Verilog in the wild yet. If you ask ChatGPT to convert your code today, you won't be happy with the results. But with careful coaching, AI models can be trained for the job.\n\nSince LLMs understand Verilog better than TL-Verilog, we do as much as possible with the Verilog to prepare it for conversion to TL-Verilog. An initial flow has been put in place for this. A Python program iterates through a recipe of prompts, each performing an incremental refactoring step. After each step, formal equivalence verification (FEV) is used to ensure functional correctness. Human intervention is possible and is currently needed at almost every step.\n\nYour project will be to use and enhance this flow to refactor an open-source Verilog project like SERV. In the process, you'll contribute to the automation, and your work will become training data to improve future LLMs for this task.\n\n_Skill level:_ Intermediate/Advanced\n\n_Duration:_ 350 hours\n\n_Language/Tools:_ Verilog, Python, TL-Verilog\n\n_Repo:_ [https://github.com/stevehoover/conversion-to-TLV](https://github.com/stevehoover/conversion-to-TLV)\n\n_Mentor:_ [Steve Hoover](mailto:steve.hoover@redwoodeda.com)\n\n### [Metro-MPI++](https://fossi-foundation.org/gsoc/gsoc25-ideas#metro-mpi)\n\n[Metro-MPI](https://github.com/metro-mpi/metro-mpi) is a generic methodology to distribute RTL simulation and unlock SoCs’ inherent parallelism. We partition well-defined blocks within designs into isolated simulation processes that communicate via MPI message passing. Metro-MPI works particularly well with replicated blocks of comparable size, such as manycores with NoCs. [Verilator](https://www.veripool.org/verilator/) is an open-source Verilog simulator and linting tool that translates Verilog HDL code into optimized C++ or SystemC code, allowing for fast, cycle-accurate simulation of digital circuits.\n\nAutomatic partitions with Metro-MPI We want to add the automatic support of metro-MPI inside other tools, like Verilator or Essent. The idea would be to detect the top modules that are suitable to be interfaced with metro-MPI. An automatic partition algorithm would be ideal although we can start with a user-guided approach like pragmas. The project will be divided into two big milestones: the initial task is to use the methodology from Metro-MPI to speed up the simulation (e.g. using messages with MPI to communicate between partitions); the second task would be to influence the partitions of the design to ease the usage of MPI between them.\n\nMetro-MPI @FPGA  \nWe would like to explore the same methodology that Metro-MPI introduces but to connect multiple FPGAs with MPI.\n\nWe are also open to other improvements on metro-MPI:\n\n*   Explore the support of OpenMP instead of openMPI\n*   Explore making the simulations faster with statistical analysis: predict values that will take the MPI messages on a certain simulation, making checkpoints and rolling back in case of predicting wrong.\n*   Improve current Verilator support from v4 to v5.\n*   Scale Simulations up to 10K cores (currently we support up to 1024 cores)\n\nMetro-MPI uses Verilog and C++. Additionally, some background in hardware design is useful.\n\n_Skill Level:_ Medium/Advanced\n\n_Duration:_ 350 hours\n\n_Language/Tools:_ C++, MPI, SystemVerilog\n\n_Mentors:_ [Guillem López Paradís](mailto:guillem.lopez@bsc.es) and [Jonathan Balkind](mailto:jbalkind@ucsb.edu)\n\n### [OpenLane Web-based Graphical User Interface](https://fossi-foundation.org/gsoc/gsoc25-ideas#openlane-web-based-graphical-user-interface)\n\n_Details:_ OpenLane is the premier open source RTL-to-GDSII flow. Versions 2.0 or higher's modular architecture allows for constructing complex flows using nodes called \"steps,\" Users who are adept in Python can create many such complex flows, including flows that are parallel. A web-based GUI of some kind (based on a library such as ReactFlow [https://reactflow.dev](https://reactflow.dev/)) would greatly enhance the ability of novice users to create custom OpenLane-based flows with ease.\n\n_Skill level:_ Beginner or Intermediate\n\n_Duration:_ 175 hrs.\n\n_Language/Tools:_: TypeScript (React), Python\n\n_Mentor:_ [Mohamed Gaber](mailto:donn@efabless.com), [Mohamed Shalan](mailto:mshalan@efabless.com)\n\n### [LiteX SMP SoC for OpenRISC](https://fossi-foundation.org/gsoc/gsoc25-ideas#litex-smp-soc-for-openrisc)\n\nThe [LiteX](https://github.com/enjoy-digital/litex) project makes creating FPGA-based SoCs easy. LiteX supports creating SoCs containing OpenRISC CPU cores. Up until now however, there have been no LiteX SoCs that support running OpenRISC multicore/SMP Linux. The [linux-on-litex-vexrisc](https://github.com/litex-hub/linux-on-litex-vexriscv) project provides a good example of how to develop and document getting Linux up and running on a LiteX SoC; including multicore.\n\nUsing `linux-on-litex-vexrisc` as an example, this project will have the student creating a project to help people get up and running with OpenRISC. The final goal shall be to have a documented multicore OpenRISC LiteX SoC running Linux SMP.\n\n_Skill level:_ Advanced\n\n_Project Length:_ large\n\n_Language/Tools:_ Verilog, LiteX, Linux, Python, OpenRISC architecture\n\n_Mentor:_ [Stafford Horne](mailto:shorne@gmail.com)\n\n### [Improve CIRCT's Verilog Frontend](https://fossi-foundation.org/gsoc/gsoc25-ideas#improve-circts-verilog-frontend)\n\nThe [CIRCT](https://github.com/llvm/circt) project uses the [Slang](https://github.com/MikePopoloski/slang) frontend to parse the SystemVerilog hardware description language. The [sv-tests](https://chipsalliance.github.io/sv-tests-results/) project runs many SystemVerilog frontends on a benchmark suite of input files to test their quality. We would love you to use the sv-tests results as a starting point to find key missing features that you can add to `circt-verilog` and fix failing tests. Tests often fail for similar reasons, and fixing small things can cause large numbers of tests to start passing.\n\nSystemVerilog is a complicated language and CIRCT builds a deep stack of intermediate representations using MLIR to process it. The Slang frontend produces an Abstract Syntax Tree which the ImportVerilog pass converts into the Moore dialect, the first IR level in circt-verilog. Various optimizations are already performed at this level. Then the MooreToCore conversion pass lowers the Moore dialect to the HW, Comb, Seq, and LLHD dialects for further processing. Finally, several optimization passed implemented on the LLHD dialect analyze the hardware design and detect common structures. If you want to sink your teeth into compiler and IR design, this is the perfect project for you!\n\nSlang and CIRCT are based on MLIR and LLVM, and are implemented in C++. So you'll definitely want to have some experience writing C++ code, since LLVM-based projects often follow a fairly peculiar and performance-conscious style of C++.\n\n_Skill Level:_ Advanced\n\n_Duration:_ 175 hours or 350 hours\n\n_Language/Tools:_ C++, CIRCT, MLIR, LLVM\n\n_Mentor:_ [Fabian Schuiki](mailto:fabian@schuiki.ch), [Martin Erhart](https://fossi-foundation.org/gsoc/maerhart@outlook.com), and others in the CIRCT community\n\n### [Architectural Improvements to OpenPiton+Ariane for RISC-V Profile Compliance](https://fossi-foundation.org/gsoc/gsoc25-ideas#architectural-improvements-to-openpitonariane-for-risc-v-profile-compliance)\n\n[OpenPiton+Ariane](https://openpiton-blog.princeton.edu/2018/11/announcing-openpiton-with-ariane/) is a permissively-licensed RISC-V manycore processor, built as a collaboration between the [PULP Platform](https://www.pulp-platform.org/) from ETH Zürich and the [OpenPiton Platform](http://www.openpiton.org/) from Princeton University. We would like to co-optimise OpenPiton and Ariane/CVA6 in their combined platform, to improve performance of the processor both in FPGA emulation systems and for eventual silicon chips. We are particularly interested in moving the platform toward RISC-V RVA23 profile compliance and so developing any new extension support needed for this purpose would be a great GSoC opportunity!\n\n_Skill level:_ Intermediate\n\n_Duration:_ 175 or 350 hours\n\n_Language/Tools:_ Verilog, SystemVerilog, RISC-V\n\n_Mentor:_ [Jonathan Balkind](mailto:jbalkind@ucsb.edu), [Nils Wistoff](mailto:nwistoff@iis.ee.ethz.ch)\n\n### [Cohort++](https://fossi-foundation.org/gsoc/gsoc25-ideas#cohort)\n\n[Cohort](https://jbalkind.github.io/docs/asplosc23main-p494-p-b2f0eacb1a-63706-final.pdf) is a framework designed to integrate hardware accelerators into software systems while maximizing efficiency seamlessly. It introduces Software-Oriented Acceleration (SOA), a paradigm that simplifies and optimizes interactions between software and hardware accelerators. By leveraging existing software abstractions—such as shared-memory queues—Cohort enables a streamlined, high-performance communication channel between software components and accelerators.\n\nThis project consists of improving the performance of OpenPiton memory hierarchy to better suit Cohort. For example, there is prior work on supporting wider NoCs, and cachelines in OpenPiton; we changing the Cohort engine's interaction with the coherence protocol; multiple MMU outstanding requests for higher performance.\n\nWe have other ideas to work more on Cohort software support and we are also open to new proposals. Some examples:\n\n*   Support for other data structures instead of only queues\n*   Connect the openMP and/or openMPI runtime library to use Cohort queues\n*   Add the support for [PRGA](https://dl.acm.org/doi/pdf/10.1145/3431920.3439294) to be used with Cohort\n\n_Skill Level:_ Medium/Advanced\n\n_Duration:_ 350 hours\n\n_Language/Tools:_ C++, SystemVerilog\n\n_Mentors:_ [Guillem López Paradís](mailto:guillem.lopez@bsc.es) , [Davy Million](mailto:davy.million@cea.fr) and [Jonathan Balkind](mailto:jbalkind@ucsb.edu)\n\n### [Seamless multi-frontend support for OpenLane](https://fossi-foundation.org/gsoc/gsoc25-ideas#seamless-multi-frontend-support-for-openlane)\n\n_Details:_ OpenLane is the premier open source RTL-to-GDSII flow. Versions 2.0+ currently support handling multiple frontends for compilation:\n\n*   Yosys Default - Verilog\n*   Synlig - SystemVerilog\n*   GHDL - VHDL (x86-64-only)\n\nHowever, in the cases of VHDL and Verilog specifically– there is no way to mix and match Verilog and VHDL in one design, for example, which is common when reusing IPs.\n\nThis task proposes a retool to OpenLane synthesis to, instead of having two different flows (`Classic` and `VHDLClassic`), have one flow accepting a heterogeneous list of files, which can then be inspected to determine the proper frontend to be used.\n\nThe project may involve enhancements to one or more of the C++-based Yosys frontends, as well as the addition of more frontends for languages such as Chisel and Amaranth.\n\n_Skill level:_ Intermediate\n\n_Duration:_ 175 hrs.\n\n_Language/Tools:_ Python, Verilog, C++, Nix\n\n_Mentor:_ [Kareem Farid](mailto:kareem.farid@efabless.com), [Mohamed Shalan](mailto:mshalan@efabless.com)\n\n### [OpenRISC Benchmarking and Performance improvements](https://fossi-foundation.org/gsoc/gsoc25-ideas#openrisc-benchmarking-and-performance-improvements)\n\nThe [OpenRISC](https://openrisc.io/) CPU architecture has multiple CPU implementations including the mor1kx and marocchino. Recent testing has shown that memory access on the marocchino is slightly slower compared to the mor1kx.\n\nThis project will have the student:\n\n*   Continue from where the 2024 GSoC student left off.\n*   Use tools like the [Embench](https://www.embench.org/news.html) modern benchmark suite to measure OpenRISC processor and compiler toolchain performance.\n*   Document the OpenRISC performance at [Embench IoT results](https://github.com/embench/embench-iot-results) to be able to compare OpenRISC vs other popular CPUs.\n*   Track down and improve OpenRISC CPU performance by finding and fixing deficiencies in the verilog designed cores.\n\n_Skill level:_ Advanced\n\n_Project Length:_ large\n\n_Language/Tools:_ Verilog, Shell scripting, C, Assembly, Python\n\n_Mentor:_ [Stafford Horne](mailto:shorne@gmail.com)\n\n### [OpenLane Flow Declaration GUI](https://fossi-foundation.org/gsoc/gsoc25-ideas#openlane-flow-declaration-gui)\n\n_Details:_ OpenLane is the premier open source RTL-to-GDSII flow. Versions 2.0 or higher's modular architecture allows for constructing complex flows using nodes called \"steps.\"\n\nUsers who are adept in Python can create many such complex flows, including flows that may run multiple steps in parallel, but those who are not may face difficulty doing so.\n\nA web-based GUI of some kind (based on a library such as ReactFlow [https://reactflow.dev](https://reactflow.dev/)) would greatly enhance the ability of novice users to create custom OpenLane-based flows with ease.\n\n_Skill level:_ Beginner to Intermediate\n\n_Duration:_ 175 hrs.\n\n_Language/Tools:_: TypeScript (React), Python\n\n_Mentor:_ [Mohamed Gaber](mailto:donn@efabless.com), [Mohamed Shalan](mailto:mshalan@efabless.com)\n\n### [Adding TL-Verilog Support to Surfer](https://fossi-foundation.org/gsoc/gsoc25-ideas#adding-tl-verilog-support-to-surfer)\n\n_Details:_ Surfer is a modern open-source waveform viewer that evolved alongside the Spade HDL. It has gained broader popularity beyond the Spade ecosystem, and adding support for other emerging HDL capabilities will benefit the community.\n\nTL-Verilog models have higher-level knowledge that can be reflected in a waveform viewer to enhance the debugging experience. Most notably, TL-Verilog signals can be \"invalid\". Invalidity is, in some respects, similar to dont-care state. One distinction is that validity is compatible with two-state simulators, like Verilator.\n\nThis project will focus on two main features to enhance TL-Verilog waveforms in Surfer:\n\n1.  Displaying TL-Verilog-style signal and hierarchy names in TL-Verilog standard colors.\n2.  Reflecting validity on signal values.\n\nThese two features can currently be seen in the Makerchip IDE's waveform viewer.\n\n_Skill level:_ Medium/advanced\n\n_Language/Tools:_ Rust\n\n_Duration:_ 350 hrs\n\n_Repo:_ [https://gitlab.com/surfer-project/surfer](https://gitlab.com/surfer-project/surfer)\n\n_Mentors:_ [Frans Skarman](mailto:frans.skarman@protonmail.com) (creator of Surfer and Spade), [Oscar Gustafsson](mailto:oscar.gustafsson@liu.se), [Steve Hoover](mailto:steve.hoover@redwoodeda.com) (creator of TL-Verilog & Makerchip)\n\n### [Device-Under-Test Python Typing Stub Generator for cocotb tests](https://fossi-foundation.org/gsoc/gsoc25-ideas#device-under-test-python-typing-stub-generator-for-cocotb-tests)\n\ncocotb tests manipulate the signals of the Device-Under-Test (DUT) to verify the design, but what was the name of that signal I needed to wiggle???\n\nIf we had a Python typing stub for the DUT, we could get the [Pylance VS Code extension](https://marketplace.visualstudio.com/items?itemName=ms-python.vscode-pylance) to help us by listing the signals in the DUT in an autocomplete pop-up; we could use Python static type checkers like [mypy](https://www.mypy-lang.org/) to ensure we didn't fat-finger the name of some module; or use generated typing stubs to create _abstract bus definitions_ that users could \"mock out\" when needed.\n\ncocotb has existing DUT introspection capabilities that could be leveraged to generate Python typing stubs. However, existing features may not be enough, and additional features may need to be added, in addition to the generator itself. Perhaps even, this code could be set up for future use by a language server, like [slang](https://sv-lang.com/), to generate even more informative typing stubs.\n\nSee more information [here](https://github.com/cocotb/cocotb/issues/4504).\n\n_Skill level:_ Beginner to Intermediate\n\n_Duration:_ medium (175 hours)\n\n_Language/Tools:_ Python, cocotb\n\n_Mentor:_ [Kaleb Barrett](mailto:dev.ktbarrett@gmail.com)\n"}