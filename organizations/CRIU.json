{"name":"CRIU","description":"Chekpoint/Restore for Linux tasks and containers","gsoc_url":"https://summerofcode.withgoogle.com/programs/2025/organizations/criu","ideas_url":"https://criu.org/Google_Summer_of_Code_Ideas","logo":"https://summerofcode.withgoogle.com/media/org/criu/ypjxpancpwtdf698-360.png","technologies":["c","python","linux","go"],"topics":["cloud","containers","Checkpoint/Restore"],"projects":[{"project_name":"Add support for memory compression","summary":"Implement compression for memory page files in CRIU without modifying the Linux kernel, improving performance and efficiency during checkpointing.","difficulty":"intermediate"},{"project_name":"Use eBPF to lock and unlock the network","summary":"Replace iptables-restore commands with eBPF rules for better network locking during process checkpointing, circumventing known issues with external dependencies.","difficulty":"intermediate"},{"project_name":"Files on detached mounts","summary":"Facilitate the restoration of open file descriptors from detached mounts in CRIU, addressing challenges in correctly resolving mount identifiers after restores.","difficulty":"intermediate"},{"project_name":"Checkpointing of POSIX message queues","summary":"Implement checkpoint/restore functionality for POSIX message queues, enabling message retrieval from a queue without removal, thus preserving inter-process communication integrity.","difficulty":"intermediate"},{"project_name":"Add support for arm64 Guarded Control Stack (GCS)","summary":"Enhance CRIU's capability to checkpoint/restore applications using the arm64 GCS feature, bolstering security against certain types of attacks without kernel modifications.","difficulty":"expert"},{"project_name":"Coordinated checkpointing of distributed applications","summary":"Develop a synchronization mechanism for checkpointing distributed applications in Kubernetes, improving reliability during process pause and resume operations.","difficulty":"intermediate"},{"project_name":"Optimize logging engine","summary":"Improve the logging performance in CRIU by potentially transitioning to binary logging, reducing the overhead caused by excessive logging during operations.","difficulty":"intermediate"},{"project_name":"IOUring support","summary":"Integrate support for the io_uring asynchronous I/O framework into CRIU, enhancing its I/O capabilities and performance.","difficulty":"expert"},{"project_name":"Add support for SPFS","summary":"Port NFS and FUSE support through the Stub-Proxy File System (SPFS) to mainline CRIU, allowing for efficient checkpoint and restore of filesystem states.","difficulty":"expert"},{"project_name":"Anonymise image files","summary":"Develop functionality in CRIT to remove sensitive data from CRIU images, ensuring more secure sharing of images during troubleshooting or reporting.","difficulty":"beginner"},{"project_name":"Add support for checkpoint/restore of CORK-ed UDP socket","summary":"Extend CRIU to handle CORK-ed UDP sockets correctly by enabling state preservation and restoration of the write queue, addressing current bugs in its treatment.","difficulty":"intermediate"}],"jina_response":"Title: Google Summer of Code Ideas\n\nURL Source: https://criu.org/Google_Summer_of_Code_Ideas\n\nMarkdown Content:\nGoogle Summer of Code (GSoC) is a global program that offers post-secondary students an opportunity to be paid for contributing to an open source project over a three month period.\n\nThis page contains project ideas for upcoming Google Summer of Code.\n\nContacts\\[[edit](https://criu.org/index.php?title=Google_Summer_of_Code_Ideas&action=edit&section=1 \"Edit section: Contacts\")\\]\n-------------------------------------------------------------------------------------------------------------------------------\n\nPlease contact the respective mentor for the idea you are interested in. For general questions feel free to send an email to the [mailing list](mailto:criu@lists.linux.dev) or write in [gitter](https://gitter.im/save-restore/criu).\n\nProject ideas\\[[edit](https://criu.org/index.php?title=Google_Summer_of_Code_Ideas&action=edit&section=2 \"Edit section: Project ideas\")\\]\n-----------------------------------------------------------------------------------------------------------------------------------------\n\n### Add support for memory compression\\[[edit](https://criu.org/index.php?title=Google_Summer_of_Code_Ideas&action=edit&section=3 \"Edit section: Add support for memory compression\")\\]\n\n**Summary:** Support compression for page images\n\nWe would like to support memory page files compression in CRIU using one of the fastest algorithms (it's matter of discussion which one to choose!).\n\nThis task does not require any Linux kernel modifications and scope is limited to CRIU itself. At the same time it's complex enough as we need to touch memory dump/restore codepath in CRIU and also handle many corner cases like page-server and stuff.\n\n**Details:**\n\n*   Skill level: intermediate\n*   Language: C\n*   Expected size: 350 hours\n*   Suggested by: Andrei Vagin <avagin@gmail.com\\>\n*   Mentors: Radostin Stoyanov <rstoyanov@fedoraproject.org\\>, Alexander Mikhalitsyn <alexander@mihalicyn.com\\>, Andrei Vagin <avagin@gmail.com\\>\n\n### Use eBPF to lock and unlock the network\\[[edit](https://criu.org/index.php?title=Google_Summer_of_Code_Ideas&action=edit&section=4 \"Edit section: Use eBPF to lock and unlock the network\")\\]\n\n**Summary:** Use eBPF instead of external iptables-restore tool for network lock and unlock.\n\nDuring checkpointing and restoring CRIU locks the network to make sure no network packets are accepted by the network stack during the time the process is checkpointed. Currently CRIU calls out to iptables-restore to create and delete the corresponding iptables rules. Another approach which avoids calling out to the external binary iptables-restore would be to directly inject eBPF rules. There have been reports from users that iptables-restore fails in some way and eBPF could avoid this external dependency.\n\n**Links:**\n\n*   [https://www.criu.org/TCP\\_connection#Checkpoint\\_and\\_restore\\_TCP\\_connection](https://www.criu.org/TCP_connection#Checkpoint_and_restore_TCP_connection)\n*   [https://github.com/systemd/systemd/blob/master/src/core/bpf-firewall.c](https://github.com/systemd/systemd/blob/master/src/core/bpf-firewall.c)\n*   [https://blog.zeyady.com/2021-08-16/gsoc-criu](https://blog.zeyady.com/2021-08-16/gsoc-criu)\n\n**Details:**\n\n*   Skill level: intermediate\n*   Language: C\n*   Expected size: 350 hours\n*   Mentors: Radostin Stoyanov <rstoyanov@fedoraproject.org\\>, Prajwal S N <prajwalnadig21@gmail.com\\>\n*   Suggested by: Adrian Reber <areber@redhat.com\\>\n\n### Files on detached mounts\\[[edit](https://criu.org/index.php?title=Google_Summer_of_Code_Ideas&action=edit&section=5 \"Edit section: Files on detached mounts\")\\]\n\n**Summary:** Initial support of open files on \"detached\" mounts\n\nWhen criu dumps a process with an open fd on a file, it gets the mount identifier (mnt\\_id) via /proc/<pid\\>/fdinfo/<fd\\>, so that criu knows from which exact mount the file was initially opened. This way criu can restore this fd by opening the same exact file from topologically the same mount in restored mount tree.\n\nRestoring fd from the right mount can be important in different cases, for instance if the process would later want to resolve paths relative to the fd, and obviously resolving from the same file on different mount can lead to different resolved paths, or if the process wants to check path to the file via /proc/<pid\\>/fd/<fd\\>.\n\nBut we have a problem finding on which mount we need to reopen the file at restore if we only know mnt\\_id but can't find this mnt\\_id in /proc/<pid\\>/mountinfo.\n\nMountinfo file shows the mount tree topology of current mntns: parent - child relations, sharing group information, mountpoint and fs root information. And if we don't see mnt\\_id in it we don't know anything about this mount.\n\nThis can happen in two cases\n\n*   1) external mount or file - if file was opened from e.g. host it's mount would not be visible in container mountinfo\n*   2) mount was lazily unmounted\n\nIn case of 1) we have criu options to help criu handle external dependencies.\n\nIn case of 2) or no options provided criu can't resolve mnt\\_id in mountinfo and criu fails.\n\n**Solution:** We can handle 2) with: resolving major/minor via fstat, using name\\_to\\_handle\\_at and open\\_by\\_handle\\_at to open same file on any other available mount from same superblock (same major/minor) in container. Now we have fd2 of the same file as fd, but on existing mount we can dump it as usual instead, and mark it as \"detached\" in image, now criu on restore knows where to find this file, but instead of just opening fd2 from actually restored mount, we create a temporary bindmount which is lazy unmounted just after open making the file appear as a file on detached mount.\n\nKnown problems with this approach:\n\n*   Stat on btrfs gives wrong major/minor\n*   file handles does not work everywhere\n*   file handles can return fd2 on deleted file or on other hardlink, this needs special handling.\n\nAdditionally (optional part): We can export real major/minor in fdinfo (kernel). We can think of new kernel interface to get mount's major/minor and root (shift from fsroot) for detached mounts, if we have it we don't need file handle hack to find file on other mount (see fsinfo or getvalues kernel patches in LKML, can we add this info there?).\n\n**Details:**\n\n*   Skill level: intermediate\n*   Language: C\n*   Expected size: 350 hours\n*   Mentor: Pavel Tikhomirov <ptikhomirov@virtuozzo.com\\>\n*   Suggested by: Pavel Tikhomirov <ptikhomirov@virtuozzo.com\\>\n\n### Checkpointing of POSIX message queues\\[[edit](https://criu.org/index.php?title=Google_Summer_of_Code_Ideas&action=edit&section=6 \"Edit section: Checkpointing of POSIX message queues\")\\]\n\n**Summary:** Add support for checkpoint/restore of POSIX message queues\n\nPOSIX message queues are a widely used inter-process communication mechanism. Message queues are implemented as files on a virtual filesystem (mqueue), where a file descriptor (message queue descriptor) is used to perform operations such as sending or receiving messages. To support checkpoint/restore of POSIX message queues, we need a kernel interface (similar to [MSG\\_PEEK](https://github.com/checkpoint-restore/criu/commit/8ce9e947051e43430eb2ff06b96dddeba467b4fd)) that would enable the retrieval of messages from a queue without removing them. This project aims to implement such an interface that allows retrieving all messages and their priorities from a POSIX message queue.\n\n**Links:**\n\n*   [https://github.com/checkpoint-restore/criu/issues/2285](https://github.com/checkpoint-restore/criu/issues/2285)\n*   [https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/ipc/mqueue.c](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/ipc/mqueue.c)\n*   [https://www.man7.org/tlpi/download/TLPI-52-POSIX\\_Message\\_Queues.pdf](https://www.man7.org/tlpi/download/TLPI-52-POSIX_Message_Queues.pdf)\n\n**Details:**\n\n*   Skill level: intermediate\n*   Language: C\n*   Expected size: 350 hours\n*   Mentors: Radostin Stoyanov <rstoyanov@fedoraproject.org\\>, Pavel Tikhomirov <ptikhomirov@virtuozzo.com\\>, Prajwal S N <prajwalnadig21@gmail.com\\>\n*   Suggested by: Pavel Tikhomirov <ptikhomirov@virtuozzo.com\\>\n\n### Add support for arm64 Guarded Control Stack (GCS)\\[[edit](https://criu.org/index.php?title=Google_Summer_of_Code_Ideas&action=edit&section=7 \"Edit section: Add support for arm64 Guarded Control Stack (GCS)\")\\]\n\n**Summary:** Support arm64 Guarded Control Stack (GCS)\n\nThe arm64 Guarded Control Stack (GCS) feature provides support for hardware protected stacks of return addresses, intended to provide hardening against return oriented programming (ROP) attacks and to make it easier to gather call stacks for applications such as profiling (taken from \\[1\\]). We would like to support arm64 Guarded Control Stack (GCS) in CRIU, which means that CRIU should be able to Checkpoint/Restore applications using GCS.\n\nThis task should not require any Linux kernel modifications but will require a lot of effort to understand Linux kernel and glibc support patches. We have a good example of support for x86 shadow stack \\[4\\] thanks to Mike.\n\n**Links:**\n\n*   \\[1\\] kernel support [https://lore.kernel.org/all/20241001-arm64-gcs-v13-0-222b78d87eee@kernel.org](https://lore.kernel.org/all/20241001-arm64-gcs-v13-0-222b78d87eee@kernel.org)\n*   \\[2\\] libc support [https://inbox.sourceware.org/libc-alpha/20250117174119.3254972-1-yury.khrustalev@arm.com](https://inbox.sourceware.org/libc-alpha/20250117174119.3254972-1-yury.khrustalev@arm.com)\n*   \\[3\\] libc tests [https://inbox.sourceware.org/libc-alpha/20250210114538.1723249-1-yury.khrustalev@arm.com](https://inbox.sourceware.org/libc-alpha/20250210114538.1723249-1-yury.khrustalev@arm.com)\n*   \\[4\\] x86 support (a great reference!) [https://github.com/checkpoint-restore/criu/pull/2306](https://github.com/checkpoint-restore/criu/pull/2306)\n\n**Details:**\n\n*   Skill level: expert (a lot of moving parts: Linux kernel / libc / CRIU)\n*   Language: C\n*   Expected size: 350 hours\n*   Suggested by: Mike Rapoport <rppt@kernel.org\\>\n*   Mentors: Mike Rapoport <rppt@kernel.org\\>, Andrei Vagin <avagin@gmail.com\\>, Alexander Mikhalitsyn <alexander@mihalicyn.com\\>\n\n### Coordinated checkpointing of distributed applications\\[[edit](https://criu.org/index.php?title=Google_Summer_of_Code_Ideas&action=edit&section=8 \"Edit section: Coordinated checkpointing of distributed applications\")\\]\n\n**Summary:** Enable coordinated container checkpointing with Kubernetes.\n\nCheckpointing support has been recently introduced in Kubernetes, where the smallest deployable unit is a Pod (a group of containers). Kubernetes is often used to deploy applications that are distributed across multiple nodes. However, checkpointing such distributed applications requires a coordination mechanism to synchronize the checkpoint and restore operations. To address this challenge, we have developed a new tool called `criu-coordinator` that relies on the action-script functionality of CRIU to enable synchronization in distributed environments. This project aims to extend this tool to enable seamless integration with the checkpointing functionality of Kubernetes.\n\n**Links:**\n\n*   [https://github.com/checkpoint-restore/criu-coordinator](https://github.com/checkpoint-restore/criu-coordinator)\n*   [https://lpc.events/event/18/contributions/1803/](https://lpc.events/event/18/contributions/1803/)\n*   [https://sched.co/1YeT4](https://sched.co/1YeT4)\n*   [https://kubernetes.io/blog/2022/12/05/forensic-container-checkpointing-alpha/](https://kubernetes.io/blog/2022/12/05/forensic-container-checkpointing-alpha/)\n\n**Details:**\n\n*   Skill level: intermediate\n*   Language: Rust / Go / C\n*   Expected size: 350 hours\n*   Mentors: Radostin Stoyanov <rstoyanov@fedoraproject.org\\>, Prajwal S N <prajwalnadig21@gmail.com\\>\n*   Suggested by: Radostin Stoyanov <rstoyanov@fedoraproject.org\\>\n\nSuspended project ideas\\[[edit](https://criu.org/index.php?title=Google_Summer_of_Code_Ideas&action=edit&section=9 \"Edit section: Suspended project ideas\")\\]\n-------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nListed here are tasks that seem suitable for GSoC, but currently do not have anybody to mentor it.\n\n### Optimize logging engine\\[[edit](https://criu.org/index.php?title=Google_Summer_of_Code_Ideas&action=edit&section=10 \"Edit section: Optimize logging engine\")\\]\n\n**Summary:** CRIU puts a lots of logs when doing its job. Logging is done with simple fprintf function. They are typically useless, but _if_ some operation fails -- the logs are the only way to find what was the reason for failure.\n\nAt the same time the printf family of functions is known to take some time to work -- they need to scan the format string forÂ %-s and then convert the arguments into strings. If comparing criu dump with and without logs the time difference is notable (15%-20%), so speeding the logs up will help improve criu performance.\n\nOne of the solutions to the problem might be binary logging. The problem with binary logs is the amount of efforts to convert existing logs to binary form. Preferably, the switch to binary logging either keeps existing log() calls intact, either has some automatics to convert them.\n\nThe option to keep log() calls intact might be in pre-compilation pass of the sources. In this pass each `log(fmt, ...)` call gets translated into a call to a binary log function that saves `fmt` identifier copies all the args _as is_ into the log file. The binary log decode utility, required in this case, should then find the fmt string by its ID in the log file and print the resulting message.\n\n**Links:**\n\n*   [Better logging](https://criu.org/Better_logging \"Better logging\")\n\n**Details:**\n\n*   Skill level: intermediate\n*   Language: C, though decoder/preprocessor can be in any language\n*   Expected size: 350 hours\n*   Suggested by: Andrei Vagin\n*   Mentors: Alexander Mikhalitsyn <alexander@mihalicyn.com\\>\n\n### IOUring support\\[[edit](https://criu.org/index.php?title=Google_Summer_of_Code_Ideas&action=edit&section=11 \"Edit section: IOUring support\")\\]\n\nThe io\\_uring Asynchronous I/O (AIO) framework is a new Linux I/O interface, first introduced in upstream Linux kernel version 5.1 (March 2019). It provides a low-latency and feature-rich interface for applications that require AIO functionality.\n\n**Links:**\n\n*   [https://blogs.oracle.com/linux/an-introduction-to-the-io\\_uring-asynchronous-io-framework](https://blogs.oracle.com/linux/an-introduction-to-the-io_uring-asynchronous-io-framework)\n*   [https://github.com/axboe/liburing](https://github.com/axboe/liburing)\n\n**Details:**\n\n*   Skill level: expert (+linux kernel)\n*   Expected size: 350 hours\n\n### Add support for SPFS\\[[edit](https://criu.org/index.php?title=Google_Summer_of_Code_Ideas&action=edit&section=12 \"Edit section: Add support for SPFS\")\\]\n\n**Summary:** The SPFS is a special filesystem that allows checkpoint and restore of such things as NFS and FUSE\n\nNFS support is already implemented in Virtuozzo CRIU, but it's very beneficial to port it to mainline CRIU. The importaint part of it is the need to implement the integration of Stub-Proxy File System (SPFS) with LXC/yet\\_another\\_containers\\_environment.\n\n**Links**\n\n*   [https://github.com/checkpoint-restore/criu/issues/60](https://github.com/checkpoint-restore/criu/issues/60)\n*   [https://github.com/checkpoint-restore/criu/issues/53](https://github.com/checkpoint-restore/criu/issues/53)\n*   [https://github.com/skinsbursky/spfs](https://github.com/skinsbursky/spfs)\n*   [https://patchwork.criu.org/series/137/](https://patchwork.criu.org/series/137/)\n\n**Details:**\n\n*   Skill level: expert\n*   Language: C\n*   Mentor: Alexander Mikhalitsyn <alexander@mihalicyn.com\\>\n*   Suggested by: Alexander Mikhalitsyn <alexander@mihalicyn.com\\>\n\n### Anonymise image files\\[[edit](https://criu.org/index.php?title=Google_Summer_of_Code_Ideas&action=edit&section=13 \"Edit section: Anonymise image files\")\\]\n\n**Summary:** Teach [CRIT](https://criu.org/CRIT \"CRIT\") to remove sensitive information from images\n\nWhen reporting a BUG it may be not acceptable for the reporter to send us raw images, as they may contain sensitive data. Need to teach CRIT to \"anonymise\" images for publication.\n\nList of data to shred:\n\n*   Memory contents. For the sake of investigation, all the memory contents can be just removed. Only the sizes of pages\\*.img files are enough.\n*   Paths to files. Here we should keep the paths relations to each other. The simplest way seem to be replacing file names with \"random\" (or sequential) strings, BUT (!) keeping an eye on making this mapping be 1:1. Note, that file paths may also sit in sk-unix.img.\n*   Registers.\n*   Process names. (But relations should be kept).\n*   Contents of streams, i.e. pipe/fifo data, sk-queue, tcp-stream, tty data.\n*   Ghost files.\n*   Tarballs with tmpfs-s.\n*   IP addresses in sk-inet-s, ip tool dumps and net\\*.img.\n\n**Links:**\n\n*   [Anonymize image files](https://criu.org/Anonymize_image_files \"Anonymize image files\")\n*   [https://github.com/checkpoint-restore/criu/issues/360](https://github.com/checkpoint-restore/criu/issues/360)\n*   [CRIT](https://criu.org/CRIT \"CRIT\"), [Images](https://criu.org/Images \"Images\")\n*   External links to mailing lists or web sites\n\n**Details:**\n\n*   Skill level: beginner\n*   Language: Python\n\n### Add support for checkpoint/restore of CORK-ed UDP socket\\[[edit](https://criu.org/index.php?title=Google_Summer_of_Code_Ideas&action=edit&section=14 \"Edit section: Add support for checkpoint/restore of CORK-ed UDP socket\")\\]\n\n**Summary:** Support C/R of corked UDP socket\n\nThere's UDP\\_CORK option for sockets. As man page says:\n\n    If this option is enabled, then all data output on this socket\n    is accumulated into a single datagram that is transmitted when\n    the option is disabled.  This option should not be used in\n    code intended to be portable.\n\nCurrently criu refuses to dump this case, so it's effectively a bug. Supporting this will need extending the kernel API to allow criu read back the write queue of the socket (see [how it's done](https://criu.org/TCP_connection \"TCP connection\") for TCP sockets, for example). Then the queue is written into the image and is restored into the socket (with the CORK bit set too).\n\n**Links:**\n\n*   [https://github.com/checkpoint-restore/criu/issues/409](https://github.com/checkpoint-restore/criu/issues/409)\n*   [https://github.com/criupatchwork/criu/commit/a532312](https://github.com/criupatchwork/criu/commit/a532312)\n*   [Sockets](https://criu.org/Sockets \"Sockets\"), [TCP connection](https://criu.org/TCP_connection \"TCP connection\")\n*   \\[[UDP cork explained](https://groups.google.com/forum/#!topic/comp.os.linux.networking/Uz8PYiTCZSg)\\]\n\n**Details:**\n\n*   Skill level: intermediate (+linux kernel)\n*   Language: C\n*   Expected size: 350 hours\n*   Mentors: Alexander Mikhalitsyn <alexander@mihalicyn.com\\>, Pavel Tikhomirov <ptikhomirov@virtuozzo.com\\>, Andrei Vagin <avagin@gmail.com\\>\n"}