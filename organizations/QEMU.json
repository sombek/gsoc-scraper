{"name":"QEMU","description":"Open source machine emulator and virtualizer","gsoc_url":"https://summerofcode.withgoogle.com/programs/2025/organizations/qemu","ideas_url":"https://wiki.qemu.org/Google_Summer_of_Code_2025","logo":"https://summerofcode.withgoogle.com/media/org/qemu/gik5gsxljb3j1jx1-360.png","technologies":["c","python","linux","rust"],"topics":["systems programming","kernel","compiler","emulator","hypervisor"],"projects":[{"project_name":"Tracing and logging in Rust","summary":"Implement Rust APIs for tracing and logging in QEMU, enabling safe and idiomatic integration of Rust with existing C code relating to tracing.","difficulty":"intermediate/advanced"},{"project_name":"Adding Kani proofs for Virtqueues in Rust-vmm","summary":"Use Kani proofs to verify the conformance of the virtqueue implementation to the VirtIO specification, providing stronger validation than standard unit tests.","difficulty":"intermediate"},{"project_name":"FUSE-over-io_uring exports","summary":"Extend QEMU's FUSE export type to support FUSE-over-io_uring, optimizing file operations and reducing CPU overhead for disk image interactions.","difficulty":"intermediate"},{"project_name":"Asynchronous request handling for virtiofsd","summary":"Implement asynchronous request handling in virtiofsd to allow parallel processing of requests, improving performance for mixed workloads.","difficulty":"intermediate"},{"project_name":"Implement LASI network card and/or NCR 710 SCSI controller device models","summary":"Develop emulations for the historic HP PA-RISC LASI network card and NCR 710 SCSI controller to enhance QEMU's support for older architectures.","difficulty":"advanced"},{"project_name":"vhost-user devices in Rust on macOS and *BSD","summary":"Extend rust-vmm to support vhost-user devices running on POSIX systems like macOS and BSD by replacing Linux-specific system calls.","difficulty":"intermediate"}],"jina_response":"Title: Google Summer of Code 2025\n\nURL Source: https://wiki.qemu.org/Google_Summer_of_Code_2025\n\nMarkdown Content:\nIntroduction\n------------\n\nQEMU is participating in [Google Summer of Code 2025](https://summerofcode.withgoogle.com/). This page contains our ideas list and information for applicants and mentors. Google Summer of Code is an open source internship program offering paid remote work.\n\n**Status: Applicants can discuss project ideas with mentors. Applications are open March 24 - April 8 18:00 UTC. See [#Application Process](https://wiki.qemu.org/Google_Summer_of_Code_2025#Application_Process) below for information on how to apply.**\n\nProject Ideas\n-------------\n\nThis is the listing of suggested project ideas. Students are free to suggest their own projects, see [#How to propose a custom project idea](https://wiki.qemu.org/Google_Summer_of_Code_2025#How_to_propose_a_custom_project_idea) below.\n\nTracing and logging in Rust\n---------------------------\n\n**Expected outcome:** Implement Rust APIs for tracing and logging.\n\nThe QEMU project is currently experimenting with using the Rust programming language to create new devices. As part of this, we have to write _bindings_ to the C code that make it possible to use it from Rust safely. For example, QEMU needs to include Rust code to manage timers, interrupts and memory regions with safe and idiomatic Rust code.\n\nQEMU integrates support for tracing using various backends---ranging from good old stdio to systemtap---thanks to a code generator that can produce tracing routines for the hundreds of tracepoints that QEMU supports; for more information see the links below. As part of this project, you will work on adding support for tracing and logging to Rust code.\n\nThe project spans multiple programming languages: the code generator is written in Python, the generated code will of course be Rust, and you will have to read some C to understand the subsystem.\n\nAmong similarly large open source C projects, QEMU is an early adopter for Rust! So you will also have a look at how the two languages can be integrated through the Meson build system.\n\n**Tasks:**\n\n*   implement bindings for QEMU's logging subsystem (logging is one of the tracing backends)\n*   analyze the code generated by tracetool for C for the various tracing backends\n*   try to implement by hand a few tracepoints in Rust\n*   modify tracetool to generate the Rust code automatically\n\n**Links:**\n\n*   [Tracing in QEMU](https://qemu-project.gitlab.io/qemu/devel/tracing.html)\n*   [Rust in QEMU status](https://lore.kernel.org/qemu-devel/17ad81c3-98fc-44c2-8f65-f5e2cc07030b@gnu.org/T/#u)\n\n**Details:**\n\n*   Project size: 350 hours\n*   Skill level: intermediate/advanced\n*   Languages: Python, Rust, C\n*   Mentor: Paolo Bonzini (OFTC: bonzini, Email: pbonzini@redhat.com)\n\nAdding Kani proofs for Virtqueues in Rust-vmm\n---------------------------------------------\n\n**Expected outcome:** Verify conformance of the virtqueue implementation in rust-vmm to the VirtIO specification.\n\nIn the rust-vmm project, devices rely on the virtqueue implementation provided by the \\`vm-virtio\\` crate. This implementation is based on the VirtIO specification, which defines the behavior and requirements for virtqueues. To ensure that the implementation meets these specifications, we have been relying on unit tests that check the output of the code given specific inputs.\n\nHowever, writing unit tests can be incomplete, as it's challenging to cover all possible scenarios and edge cases. During this internship, we propose a more comprehensive approach: using [Kani](https://github.com/model-checking/kani/) proofs to verify that the virtqueue implementation conforms to the VirtIO specification.\n\nKani allows us to write exhaustive checks for all possible values, going beyond what unit tests can achieve. By writing Kani proofs, we can confirm that our implementation meets the requirements of the VirtIO specification. If a proof passes, it provides strong evidence that the virtqueue implementation is correct and conformant.\n\nKani is an open-source tool and any issues like regarding performance can be reported on GitHub. For more information, the blog[\\[1\\]](https://model-checking.github.io/kani-verifier-blog/) contains several examples on how to use Kani in real codebases (including Firecracker). Also, there is a current effort for verifying the Rust Standard Library using Kani [\\[2\\]](https://model-checking.github.io/verify-rust-std/).\n\n**Tasks:**\n\n*   Finish [current PR](https://github.com/rust-vmm/vm-virtio/pull/324) that adds a proof for the notification suppression mechanism\n*   Port [add\\_used() proof](https://github.com/firecracker-microvm/firecracker/blob/4bbbec06ee0d529add07807f75d923cc3d3cd210/src/vmm/src/devices/virtio/queue.rs#L1006)\n*   Port [verify\\_prepare\\_kick() proof](https://github.com/firecracker-microvm/firecracker/blob/4bbbec06ee0d529add07807f75d923cc3d3cd210/src/vmm/src/devices/virtio/queue.rs#L966)\n*   Port other proofs from queue.rs\n\n**Links:**\n\n*   [LPC Talk about how we may check conformance in the VirtIO specification (video)](https://www.youtube.com/watch?v=w7BAR228344)\n*   [FOSDEM'25 talk current effort to use Kani](https://fosdem.org/2025/schedule/event/fosdem-2025-5930-hunting-virtio-specification-violations/)\n*   [Kani Blog](https://model-checking.github.io/kani-verifier-blog/)\n\n**Details:**\n\n*   Project size: 175 or 350 hours, depending on how many proofs you wish to tackle\n*   Skill level: intermediate\n*   Language: Rust\n*   Mentor: Matias Ezequiel Vara Larsen (mvaralar@redhat.com)\n\nFUSE-over-io\\_uring exports\n---------------------------\n\n**Expected outcome:** Extend QEMU's FUSE export type with FUSE-over-io\\_uring support\n\nFUSE-over-io\\_uring is a new high-performance interface for Filesystem in Userspace (FUSE) servers. The FUSE kernel code has added uring\\_cmd support so that FUSE servers can send and receive data directly over io\\_uring instead of reading/writing from/to the FUSE device. This reduces the number of system calls, as well as allowing for batching and polling, so that CPU overhead should be reduced.\n\nQEMU's FUSE export type presents a file containing the contents of a disk image. This is a convenient way of using tools like fdisk(1) or dd(1) on a non-raw disk image file, like qcow2, that these tools would otherwise not be able to operate on. The current FUSE export implementation uses libfuse's FUSE device file descriptor handling APIs (fuse\\_session\\_fd(), fuse\\_session\\_receive\\_buf(), etc) to read(2)/write(2) in the traditional way.\n\nYour task is to add FUSE-over-io\\_uring support as an alternative mode on systems where FUSE-over-io\\_uring is available.\n\n**Tasks:**\n\n*   Integrate FUSE-over-io\\_uring mode into the QEMU FUSE export\n*   Add support for multiple in-flight requests\n*   Benchmark with and without FUSE-over-io\\_uring using the fio(1) tool\n*   Add support support multiple IOThreads\n\n**Links:**\n\n*   [QEMU FUSE export code](https://gitlab.com/qemu-project/qemu/-/blob/master/block/export/fuse.c#L288)\n*   [libfuse branch with FUSE-over-io\\_uring support](https://github.com/bsbernd/libfuse/tree/uring/)\n*   [Overview of low-level FUSE-over-io\\_uring interface (handled by libfuse, but good background info)](https://docs.kernel.org/filesystems/fuse-io-uring.html)\n\n**Details:**\n\n*   Project size: 350 hours\n*   Skill level: intermediate\n*   Language: C\n*   Mentors: Kevin Wolf (kwolf@redhat.com), Stefan Hajnoczi (stefanha@redhat.com)\n\nAsynchronous request handling for virtiofsd\n-------------------------------------------\n\n**Expected outcome:** Make virtiofsdâ€™s request handling asynchronous, allowing single-threaded parallel request processing.\n\nvirtiofsd is a virtio-fs device implementation, i.e. grants VM guests access to host directories. In its current state, it processes guest requests one by one, which means operations of long duration will block processing of others that could be processed more quickly.\n\nWith asynchronous request processing, longer-lasting operations could continue in the background while other requests with lower latency are fetched and processed in parallel. This should improve performance especially for mixed workloads, i.e. one guest process executing longer-lasting filesystem operations, while another runs random small read requests on a single file.\n\nYour task is to:\n\n*   Get familiar with a Linux AIO interface, preferably io\\_uring\n*   Have virtiofsd make use of that interface for its operations\n*   Make the virtiofsd request loop process requests asynchronously, so requests can be fetched and processed while others are continuing in the background\n*   Evaluate the resulting performance with different workloads\n\nHow you make the request loop asynchronous will largely be left to your discretion. You can use Rust `async` together with a runtime like tokio, some other runtime, or an entirely custom one; or keep the code synchronous, but allow deferring operations to the background, and when they complete, return the virtio descriptors to the guest then. That said, we assume that using `async` would provide the better long-term solution, as long as youâ€™re comfortable to use/learn it.\n\n**Links:**\n\n*   virtiofsd repository: [https://gitlab.com/virtio-fs/virtiofsd](https://gitlab.com/virtio-fs/virtiofsd)\n*   virtiofsdâ€™s filesystem operations: [https://gitlab.com/virtio-fs/virtiofsd/-/blob/main/src/passthrough/mod.rs#L1490](https://gitlab.com/virtio-fs/virtiofsd/-/blob/main/src/passthrough/mod.rs#L1490)\n*   virtiofsdâ€™s request processing loop: [https://gitlab.com/virtio-fs/virtiofsd/-/blob/main/src/vhost\\_user.rs#L244](https://gitlab.com/virtio-fs/virtiofsd/-/blob/main/src/vhost_user.rs#L244)\n\n**Details:**\n\n*   Project size: 350 hours\n*   Skill level: intermediate\n*   Language: Rust\n*   Mentors: Hanna Czenczek (hreitz@redhat.com), German Maglione (gmaglione@redhat.com)\n\nImplement LASI network card and/or NCR 710 SCSI controller device models\n------------------------------------------------------------------------\n\n**Expected outcome:** Develop device emulations of the HP PA-RISC LASI network card and/or NCR 710 SCSI controller\n\nQEMU can emulate a lot of physical machines. Beside widely used x86 machines as used with KVM, this includes historic machines based on PowerPC, Alpha or HP PA-RISC CPUs too. To emulate additional historic machine models, device models that emulate specific hardware like network or SCSI cards need to be developed.\n\nThis project is about developing such a device model for the historic HP PA-RISC architecture. Based on the knowledge and interest of the applicant, here are two non-exclusive options:\n\n1\\. LASI network card. This is basically an Intel 82596 network chip, which was integrated into another ASIC in the HP 700 series. That chip was used in SUN machines as well, and the [full Linux driver source code](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/net/ethernet/i825xx) for the various machines is available. A QEMU device model exists (see [here](https://gitlab.com/qemu-project/qemu/-/blob/master/hw/net/lasi_i82596.c) and [here](https://gitlab.com/qemu-project/qemu/-/blob/master/hw/net/i82596.c)), but it's not fully functional yet. Datasheets for this chip exists too. This project is about debugging and analyzing existing code, including development of missing code.\n\n2\\. First-generation NCR 710 SCSI controller. Really old machines used a NCR 710 SCSI controller, for which currently no QEMU device model exists. QEMU has a LSI53C895A device model, which partly even allows emulating a LSI53C810, but those chips are \"too new\" and as such are not accepted and supported on old operating systems (e.g. HP-UX9). The WinUAE project seem to have modified the existing QEMU device model to [emulate a NCR 710 to support the Amiga](https://github.com/tonioni/WinUAE/blob/master/qemuvga/lsi53c710.cpp). The goal of this project is to develop a nice & clean NCR 710 device model that can be merged into QEMU.\n\n**Links:**\n\n*   [https://parisc.docs.kernel.org/en/latest/technical\\_documentation.html](https://parisc.docs.kernel.org/en/latest/technical_documentation.html)\n\n**Details:**\n\n*   Project size: 350 hours\n*   Skill level: advanced\n*   Language: C\n*   Mentor: Helge Deller (deller@gmx.de)\n\nvhost-user devices in Rust on macOS and \\*BSD\n---------------------------------------------\n\n**Expected outcome:** Extend rust-vmm crates to support vhost-user devices running on POSIX system like macOS and \\*BSD.\n\nVIRTIO devices can be emulated in an external process to QEMU thanks to the vhost-user protocol, which allows QEMU to offload the entire emulation to a daemon. This is done through an AF\\_UNIX socket used as a control path between the frontend (i.e. QEMU) and the backend (i.e. the vhost-user daemon). QEMU will share guest memory with the daemon, provide all the information for data path setup, and notification mechanisms.\n\nMoving the emulation of VIRTIO devices to a separate process from QEMU offers significant advantages, primarily in terms of safety, if a device crashes, we can restart it without affecting QEMU. Additionally, this approach simplifies updating device implementations, allows development in other languages (such as Rust as we do in the rust-vmm community), and enhances isolation through seccomp, cgroups, and similar mechanisms.\n\nThe rust-vmm community already provides several crates (e.g. vhost, vhost-user-backend, etc.) to implement a vhost-user backend in an external daemon. For example, these crates are used by virtiofsd (virtio-fs vhost-user device) but also by all vhost-user devices maintained by the rust-vmm community in the rust-vmm/vhost-device workspace. These crates work great on Linux, but unfortunately they use some Linux-specific system calls such as epoll(7) and eventfd(2) that make them impossible to use on other POSIX systems.\n\nThe goal of this project is to make sure that we can use rust-vmm's vhost and vhost-user-backend crates on other POSIX systems besides Linux. If time permits, we could also fix up simple devices such as vhost-device-console or vhost-device-vsock to run on any POSIX systems.\n\n**Tasks:**\n\n*   Run QEMU with a vhost-user device on macOS or FreeBSD/OpenBSD as covered in the FOSDEM 2025 talk\n*   Analyze rust-vmm crates (vmm-sys-util, vhost, vhost-user-backend) to understand which components are Linux-specific\n*   Replace epoll(7) with alternatives such as [https://github.com/smol-rs/polling](https://github.com/smol-rs/polling)\n*   Automatic fallback to pipe()/pipe2() if eventfd(2) is not available as QEMU already does\n*   Handle any other cases discovered during the analysis\n*   Adapt a simple device such as vhost-device-console or vhost-device-vsock to test that everything works on macOS or FreeBSD/OpenBSD\n\n**Links:**\n\n*   FOSDEM 2025 talk: [Can QEMU and vhost-user devices be used on macOS and \\*BSD?](https://fosdem.org/2025/schedule/event/fosdem-2025-5100-can-qemu-and-vhost-user-devices-be-used-on-macos-and-bsd-/)\n*   [vhost-user spacification](https://qemu-project.gitlab.io/qemu/interop/vhost-user.html)\n*   [QEMU series to support vhost-user on any POSIX](https://patchew.org/QEMU/20240618100043.144657-1-sgarzare@redhat.com/)\n*   [sgarzare's tree where to find some missing QEMU patches](https://gitlab.com/sgarzarella/qemu/-/tree/macos-vhost-user)\n*   [rust-vmm vhost & vhost-user-backend crates](https://github.com/rust-vmm/vhost)\n*   [rust-vmm vmm-sys-util crate](https://github.com/rust-vmm/vmm-sys-util)\n*   [rust-vmm vhost-device workspace](https://github.com/rust-vmm/vhost-device)\n*   [virtio-fs vhost-user device](https://gitlab.com/virtio-fs/virtiofsd)\n*   [Mac build support #110 - rust-vmm/vhost](https://github.com/rust-vmm/vhost/issues/110)\n*   [Add macOS support #169 - virtio-fs/virtiofsd](https://gitlab.com/virtio-fs/virtiofsd/-/issues/169)\n\n**Details:**\n\n*   Project size: 350 hours\n*   Skill level: intermediate\n*   Language: Rust\n*   Mentors: Stefano Garzarella <sgarzare@redhat.com\\>, German Maglione <gmaglione@redhat.com\\>\n\nApplication Process\n-------------------\n\n### 1\\. Discuss the project idea with the mentor(s)\n\nRead the project ideas list and choose one you are interested in. Read the links in the project idea description and start thinking about how you would approach this. Ask yourself:\n\n*   Do I have the necessary technical skills to complete this project?\n*   Will I be able to work independently without the physical presence of my mentor?\n\nIf you answer no to these questions, choose another project idea and/or organization that fits your skills.\n\nOnce you have identified a suitable project idea, email the mentor(s) your questions about the idea and explain your understanding of the project idea to them to verify that you are on the right track.\n\n### 2\\. Submit your proposal\n\nUpload your proposal PDF file to the [Google Summer of Code website](https://summerofcode.withgoogle.com/) and notify your mentor(s) so they can give you feedback. You can make changes and upload the PDF again until the application deadline. Your proposal must include the following:\n\n*   Project idea (title)\n*   Your name and email address\n*   Outline of your solution\n    *   Do some background research by looking at source code, browsing relevant specifications, etc in order to decide how to tackle the project. Discuss any questions with your mentor. This section will explain how your solution will work.\n*   Project schedule\n    *   Create a week-by-week schedule of the coding period. Breaking down the project into tasks and estimate how many weeks they will take. The schedule can be adjusted during the summer so don't worry about getting everything right ahead of time.\n*   Relevant experience (programming language knowledge, hobby projects, etc)\n*   Are you available to work with no other commitments (jobs, university, vacation, etc) for the duration of your project? If not, please give details about the working hours and dates.\n\n### 3\\. Contribution task\n\nOnce you have submitted your proposal PDF, let your mentor know and request a contribution task. The task will be a real bug or small feature that should not take more than 1 or 2 days to complete. This will allow you to demonstrate your skills in a realistic setting. Your mentor will provide you the details and help you with any questions.\n\nKey Dates\n---------\n\nFrom the [timeline](https://developers.google.com/open-source/gsoc/timeline):\n\n*   February 27 18:00 UTC - Organizations and project ideas announced\n*   March 24 - April 8 18:00 UTC - Application period\n*   April 15 - Contribution task deadline\n*   May 8 18:00 UTC - Accepted applicants announced\n*   June 2 - September 1 - Standard coding period (an extended timeline is possible depending on your project)\n\nFind Us\n-------\n\n*   IRC (GSoC specific): [#qemu-gsoc on irc.oftc.net](https://webchat.oftc.net/?channels=qemu-gsoc)\n\n*   IRC (development):\n    *   QEMU: [#qemu on irc.oftc.net](https://webchat.oftc.net/?channels=qemu)\n    *   KVM: #kvm on chat.freenode.net\n\n*   Mailing lists:\n    *   QEMU: [qemu-devel](http://lists.nongnu.org/mailman/listinfo/qemu-devel)\n    *   KVM: [linux-kvm](http://www.linux-kvm.org/page/Lists,_IRC)\n\nFor general questions about QEMU in GSoC, please contact the following people:\n\n*   [Stefan Hajnoczi](https://wiki.qemu.org/User:Stefanha \"User:Stefanha\") <stefanha@gmail.com\\> (stefanha on IRC)\n\nHow to add a project idea\n-------------------------\n\n1.  Create a new wiki page under \"Internships/ProjectIdeas/YourIdea\" and follow [#Project idea template](https://wiki.qemu.org/Google_Summer_of_Code_2025#Project_idea_template).\n2.  Add a link from this page like this: {{:Internships/ProjectIdeas/YourIdea}}\n\nThis is the listing of suggested project ideas. Students are free to suggest their own projects, see [#How to propose a custom project idea](https://wiki.qemu.org/Google_Summer_of_Code_2025#How_to_propose_a_custom_project_idea) below.\n\nProject idea template\n---------------------\n\n\\=== TITLE ===\n \n '''Summary:''' Short description of the project\n \n Detailed description of the project.\n \n '''Links:'''\n \\* Wiki links to relevant material\n \\* External links to mailing lists or web sites\n \n '''Details:'''\n \\* Skill level: beginner or intermediate or advanced\n \\* Language: C\n \\* Mentor: Email address and IRC nick\n \\* Suggested by: Person who suggested the idea\n\nHow to propose a custom project idea\n------------------------------------\n\nApplicants are welcome to propose their own project ideas. The process is as follows:\n\n1.  Email your project idea to qemu-devel@nongnu.org. CC Stefan Hajnoczi <stefanha@gmail.com\\> and regular QEMU contributors who you think might be interested in mentoring.\n2.  If a mentor is willing to take on the project idea, work with them to fill out the \"Project idea template\" above and email Stefan Hajnoczi <stefanha@gmail.com\\>.\n3.  Stefan will add the project idea to the wiki.\n\nNote that other candidates can apply for newly added project ideas. This ensures that custom project ideas are fair and open.\n\nHow to get familiar with our software\n-------------------------------------\n\nSee what people are developing and talking about on the mailing lists:\n\n*   [qemu-devel](http://thread.gmane.org/gmane.comp.emulators.qemu/)\n*   [libvir-list](https://www.redhat.com/archives/libvir-list/)\n*   [kvm](http://www.spinics.net/lists/kvm/)\n\nGrab the source code or browse it:\n\n*   [qemu.git](http://git.qemu-project.org/?p=qemu.git;a=summary)\n*   [libvirt.git](http://libvirt.org/git/?p=libvirt.git;a=summary)\n*   [kvm.git](https://git.kernel.org/cgit/virt/kvm/kvm.git/)\n\nBuild QEMU and run it: [QEMU on Linux Hosts](http://wiki.qemu-project.org/Hosts/Linux)\n\nLinks\n-----\n\n*   [Student Manual](https://google.github.io/gsocguides/student/)\n*   [FAQ](https://developers.google.com/open-source/gsoc/faq)\n*   [Timeline](https://developers.google.com/open-source/gsoc/timeline)\n*   [Advice for students applying (from 2011 but still relevant!)](http://blog.vmsplice.net/2011/03/advice-for-students-applying-to-google.html)\n\nInformation for mentors\n-----------------------\n\nMentors are responsible for keeping in touch with their intern and assessing progress. GSoC has evaluations where both the mentor and intern assess each other.\n\nThe mentor typically gives advice, reviews the intern's code, and has regular communication with the intern to ensure progress is being made.\n\nBeing a mentor is a significant time commitment, plan for 5 hours per week. Make sure you can make this commitment because backing out during the summer will affect the intern's experience.\n\nThe mentor chooses their intern by reviewing application forms and conducting IRC interviews with applicants. Depending on the number of candidates, this can be time-consuming in itself. Choosing the right intern is critical so that both the mentor and the intern can have a successful experience.\n"}