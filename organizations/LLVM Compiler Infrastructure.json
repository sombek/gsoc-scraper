{"name":"LLVM Compiler Infrastructure","description":"LLVM Compiler Infrastructure","gsoc_url":"https://summerofcode.withgoogle.com/programs/2025/organizations/llvm-compiler-infrastructure","ideas_url":"https://llvm.org/OpenProjects.html","logo":"https://summerofcode.withgoogle.com/media/org/llvm-compiler-infrastructure/ize6lrlftlvdxtqe-360.png","technologies":["llvm","c++","clang","mlir"],"topics":["compilers","development tools","libraries"],"projects":[{"project_name":"Google Summer of Code Ideas & Projects","summary":"This project focuses on providing a comprehensive list of ideas and projects for students interested in contributing to the LLVM Compiler Infrastructure during the Google Summer of Code program.","difficulty":"varied"},{"project_name":"LLVM Core Projects","summary":"A collection of diverse tasks aimed at improving the core of the LLVM infrastructure, including optimizations, new features, and error handling improvements.","difficulty":"varied"},{"project_name":"Clang Projects","summary":"A set of objectives centered around enhancing the Clang compiler by adding functionalities such as improved documentation parsing and addressing C++ features like modules.","difficulty":"varied"},{"project_name":"LLDB Projects","summary":"Enhancements focused on the LLVM Debugger (LLDB), including features like autosuggestions, completion improvements, and command-line interface enhancements.","difficulty":"varied"},{"project_name":"LLVM libc Projects","summary":"Initiatives focusing on enhancing the LLVM C library with support for new data types and optimization of existing math functions.","difficulty":"varied"},{"project_name":"Enzyme Projects","summary":"Development tasks centered around automatic differentiation capabilities using the LLVM framework, with goals to optimize performance and extend functionality.","difficulty":"varied"},{"project_name":"Polly Projects","summary":"Improvements to the Polly project, which focuses on loop optimizations and leveraging LLVM infrastructure for advanced transformations.","difficulty":"varied"},{"project_name":"MLIR Projects","summary":"Tasks aimed at enhancing the MLIR infrastructure, fostering better optimization for heterogeneous programming models, and extending support for new types and languages.","difficulty":"varied"},{"project_name":"Code Coverage and Testing","summary":"Efforts to improve LLVM's code coverage tools and testing frameworks to enhance user experience and robustness of the compiler.","difficulty":"varied"},{"project_name":"Miscellaneous Improvements","summary":"Various smaller tasks aimed at cleaning up the codebase, improving usability, and increasing the performance of various components within LLVM.","difficulty":"varied"}],"jina_response":"Title: The LLVM Compiler Infrastructure Project\n\nURL Source: https://llvm.org/OpenProjects.html\n\nMarkdown Content:\n| **Site Map:**  \n**Download!**  \n**Search this Site**  \n**Useful Links**  \n**Release Emails**  \nMaintained by the  \n[llvm-admin team](mailto:llvm-admin@lists.llvm.org) | Open LLVM Projects\n\n*   Google Summer of Code Ideas & Projects\n    *   [Google Summer of Code 2025](https://llvm.org/OpenProjects.html#gsoc25)\n        *   **LLVM Core**\n            *   [Introduce an ABI lowering library](https://llvm.org/OpenProjects.html#llvm-abi-lowering)\n            *   [Byte type](https://llvm.org/OpenProjects.html#byte-type)\n        *   [**Clang**](http://clang.llvm.org/)\n            *   [Simple C++20 modules without a build system](https://llvm.org/OpenProjects.html#clang-driver-modules)\n            *   [Usability Improvements for trapping Undefined Behavior Sanitizer (UBSan)](https://llvm.org/OpenProjects.html#clang-improve-trapping-ubsan-2025)\n            *   [Improve documentation parsing in Clang](https://llvm.org/OpenProjects.html#improve-documentation-parsing-in-clang)\n            *   [Advanced symbol resolution and reoptimization for clang-repl](https://llvm.org/OpenProjects.html#improve-symbol-discovery-clang-repl)\n        *   [**LLDB**](http://lldb.llvm.org/)\n            *   [Rich disassembler for LLDB](https://llvm.org/OpenProjects.html#rich-disassembler-for-lldb-2025)\n        *   [**LLVM libc**](http://libc.llvm.org/)\n            *   [Bfloat16 in LLVM libc](https://llvm.org/OpenProjects.html#bfloat16-libc)\n            *   [Direct I/O from the GPU with io\\_uring](https://llvm.org/OpenProjects.html#io_uring-libc)\n            *   [Profiling and testing the LLVM libc GPU math](https://llvm.org/OpenProjects.html#testing-math-libc)\n        *   [**ClangIR**](https://clangir.org/)\n            *   [Validate existing Clang CodeGen test coverage with ClangIR](https://llvm.org/OpenProjects.html#clangir-codegen-tests)\n            *   [Participate in ClangIR upstreaming](https://llvm.org/OpenProjects.html#clangir-upstreaming)\n        *   [**Clang Static Analyzer**](https://clang.llvm.org/docs/ClangStaticAnalyzer.html)\n            *   [Teach the Clang Static Analyzer to understand lifetime annotations](https://llvm.org/OpenProjects.html#csa-lifetime-annotations)\n        *   [**Enzyme**](https://enzyme.mit.edu/)\n            *   [Improve Enzyme reliability and compile times for Rust](https://llvm.org/OpenProjects.html#rust-enzyme-improvements)\n        *   [**Offload**](https://discourse.llvm.org/t/offload-new-subproject-pending-move-of-libomptarget/78185) (Former [**OpenMP Offloading**](https://openmp.llvm.org/))\n            *   [LLVM Compiler Remarks Visualization Tool for Offload Proposal](https://llvm.org/OpenProjects.html#offload-remarks-visualization)\n    *   [Google Summer of Code 2024](https://llvm.org/OpenProjects.html#gsoc24)\n        *   **LLVM Core**\n            *   [Remove undefined behavior from tests](https://llvm.org/OpenProjects.html#remove_ub_tests)\n            *   [Automatically generate TableGen file for SPIR-V instruction set](https://llvm.org/OpenProjects.html#spirv_tablegen)\n            *   [LLVM bitstream integration with CAS (content-addressable storage)](https://llvm.org/OpenProjects.html#bitstream_cas)\n            *   [Add 3-way comparison intrinsics](https://llvm.org/OpenProjects.html#three_way_comparison)\n            *   [Improve the LLVM.org Website Look and Feel](https://llvm.org/OpenProjects.html#llvm_www)\n            *   [The 1001 thresholds in LLVM](https://llvm.org/OpenProjects.html#parameter-tuning)\n        *   [**Clang**](http://clang.llvm.org/)\n            *   [Out-of-process execution for clang-repl](https://llvm.org/OpenProjects.html#clang-repl-out-of-process)\n            *   [Support clang plugins on Windows](https://llvm.org/OpenProjects.html#clang-plugins-windows)\n            *   [On Demand Parsing in Clang](https://llvm.org/OpenProjects.html#clang-on-demand-parsing)\n            *   [Improve Clang-Doc Usability](https://llvm.org/OpenProjects.html#clang-doc-improve-usability)\n        *   [**LLDB**](http://lldb.llvm.org/)\n            *   [Rich disassembler for LLDB](https://llvm.org/OpenProjects.html#rich-disassembler-for-lldb)\n        *   [**(OpenMP) Offload**](http://openmp.llvm.org/)\n            *   [GPU Delta Debugging](https://llvm.org/OpenProjects.html#gpu-delta-debugging)\n            *   [Offloading libcxx](https://llvm.org/OpenProjects.html#offload-libcxx)\n            *   [Performance tuning the GPU libc](https://llvm.org/OpenProjects.html#gpu-libc)\n            *   [Improve GPU First Framework](https://llvm.org/OpenProjects.html#gpu-first)\n        *   [**ClangIR**](https://clangir.org/)\n            *   [Compile GPU kernels using ClangIR](https://llvm.org/OpenProjects.html#clangir-gpu)\n        *   [**LLVM libc**](http://libc.llvm.org/)\n            *   [Half precision in LLVM libc](https://llvm.org/OpenProjects.html#half-precision-libc)\n    *   [Google Summer of Code 2023](https://llvm.org/OpenProjects.html#gsoc23)\n        *   **LLVM Core**\n            *   [Re-optimization using JITLink](https://llvm.org/OpenProjects.html#llvm_new_jitlink_reopt)\n            *   [JITLink new backends](https://llvm.org/OpenProjects.html#llvm_new_jitlink_backends)\n            *   [Improving compile times](https://llvm.org/OpenProjects.html#llvm_improving_compile_times)\n            *   [Addressing Rust optimization failures](https://llvm.org/OpenProjects.html#llvm_addressing_rust_optimization_failures)\n            *   [Better performance models for MLGO training](https://llvm.org/OpenProjects.html#llvm_mlgo_latency_model)\n            *   [Machine Learning Guided Ordering of Compiler Optimization Passes](https://llvm.org/OpenProjects.html#llvm_mlgo_passes_2023)\n            *   [Map LLVM values to corresponding source-level expressions](https://llvm.org/OpenProjects.html#llvm_map_value_to_src_expr)\n        *   [**Clang**](http://clang.llvm.org/)\n            *   [Out-of-process execution for clang-repl](https://llvm.org/OpenProjects.html#clang-repl-out-of-process)\n            *   [Improve and Stabilize the Clang Static Analyzer's \"Taint Analysis\" Checks](https://llvm.org/OpenProjects.html#clang_analyzer_taint_analysis)\n            *   [Implement autocompletion in clang-repl](https://llvm.org/OpenProjects.html#clang-repl-autocompletion)\n            *   [Modules build daemon: build system agnostic support for explicitly built modules](https://llvm.org/OpenProjects.html#clang-modules-build-daemon)\n            *   [ExtractAPI Objective-C categories](https://llvm.org/OpenProjects.html#clang-extract-api-categories)\n            *   [ExtractAPI C++ Support](https://llvm.org/OpenProjects.html#clang-extract-api-cpp-support)\n            *   [ExtractAPI while building](https://llvm.org/OpenProjects.html#clang-extract-api-while-building)\n            *   [Improve Clang diagnostics](https://llvm.org/OpenProjects.html#clang-improve-diagnostics2)\n            *   [Tutorial development with clang-repl](https://llvm.org/OpenProjects.html#clang-tutorials-clang-repl)\n            *   [Add WebAssembly Support in clang-repl](https://llvm.org/OpenProjects.html#clang-repl-wasm)\n        *   **LLD**\n            *   [LLD Linker Improvements for Embedded Targets](https://llvm.org/OpenProjects.html#llvm_lld_embedded)\n        *   **MLIR**\n            *   [Optimizing MLIR’s Presburger library](https://llvm.org/OpenProjects.html#llvm_mlir_presburger_opt)\n            *   [Interactively query MLIR IR](https://llvm.org/OpenProjects.html#llvm_mlir_query)\n        *   **Code Coverage**\n            *   [Support a hierarchical directory structure in generated coverage html reports](https://llvm.org/OpenProjects.html#llvm_code_coverage)\n            *   [Patch based test coverage for quick test feedback](https://llvm.org/OpenProjects.html#llvm_patch_coverage)\n        *   **ClangIR**\n            *   [Build and run SingleSource benchmarks using ClangIR](https://llvm.org/OpenProjects.html#clangir)\n        *   **[Enzyme](https://enzyme.mit.edu/)**\n            *   [Move additional Enzyme Rules to Tablegen](https://llvm.org/OpenProjects.html#enzyme_tblgen_extension)\n    *   [Google Summer of Code 2022](https://llvm.org/OpenProjects.html#gsoc22)\n        *   **LLVM Core**\n            *   [Implement a shared-memory based JITLinkMemoryManager for out-of-process JITting](https://llvm.org/OpenProjects.html#llvm_shared_jitlink)\n            *   [Modernize the LLVM \"Building A JIT\" tutorial series](https://llvm.org/OpenProjects.html#llvm_build_jit_tutorial)\n            *   [Write JITLink support for a new format/architecture](https://llvm.org/OpenProjects.html#llvm_jit_new_format)\n            *   [Instrumentation of Clang/LLVM for Compile Time](https://llvm.org/OpenProjects.html#llvm_instrumentaion_for_compile_time)\n            *   [Richer symbol dependency information for LTO](https://llvm.org/OpenProjects.html#llvm_lto_dependency_info)\n            *   [Machine Learning Guided Ordering of Compiler Optimization Passes](https://llvm.org/OpenProjects.html#llvm_mlgo_passes)\n            *   [Learning Loop Transformation Heuristics](https://llvm.org/OpenProjects.html#llvm_mlgo_loop)\n            *   [Evaluate and Expand the Module-Level Inliner](https://llvm.org/OpenProjects.html#llvm_module_inliner)\n            *   [Remove undef: move uninitialized memory to poison](https://llvm.org/OpenProjects.html#llvm_undef_load)\n            *   [Add ABI/API export annotations to the LLVM build](https://llvm.org/OpenProjects.html#llvm_abi_export)\n        *   [**Clang**](http://clang.llvm.org/)\n            *   [Extend clang AST to provide information for the type as written in template instantiations](https://llvm.org/OpenProjects.html#clang-template-instantiation-sugar)\n            *   [Implement support for C++17 structured bindings in the Clang Static Analyzer](https://llvm.org/OpenProjects.html#clang-sa-structured-bindings)\n            *   [Improve Clang Diagnostics](https://llvm.org/OpenProjects.html#clang-improve-diagnostics)\n        *   [**Polly**](https://polly.llvm.org/)\n            *   [Completely switch to new pass manager](https://llvm.org/OpenProjects.html#polly_npm)\n        *   **[Enzyme](https://enzyme.mit.edu/)**\n            *   [Move Enzyme Instruction Transformation Rules to Tablegen](https://llvm.org/OpenProjects.html#enzyme_tblgen)\n            *   [Vector Reverse-Mode Automatic Differentiation](https://llvm.org/OpenProjects.html#enzyme_vector)\n            *   [Enable The New Pass Manager](https://llvm.org/OpenProjects.html#enzyme_pm)\n    *   [Google Summer of Code 2021](https://llvm.org/OpenProjects.html#gsoc21)\n        *   **LLVM Core**\n            *   [Distributed lit testing](https://llvm.org/OpenProjects.html#llvm_distributing_lit)\n            *   [Learning Loop Transformation Heuristics](https://llvm.org/OpenProjects.html#llvm_loop_heuristics)\n            *   [Fuzzing LLVM-IR Passes](https://llvm.org/OpenProjects.html#llvm_ir_fuzzing)\n            *   [llvm.assume the missing pieces](https://llvm.org/OpenProjects.html#llvm_ir_assume)\n            *   [Implement a shared-memory based JITLinkMemoryManager for out-of-process JITting](https://llvm.org/OpenProjects.html#llvm_shared_jitlink)\n            *   [Modernize the LLVM \"Building A JIT\" tutorial series](https://llvm.org/OpenProjects.html#llvm_build_jit_tutorial)\n            *   [Write JITLink support for a new format/architecture](https://llvm.org/OpenProjects.html#llvm_jit_new_format)\n            *   [Fix fundamental issues in LLVM's IR](https://llvm.org/OpenProjects.html#llvm_ir_issues)\n            *   [Utilize LoopNest Pass](https://llvm.org/OpenProjects.html#llvm_utilize_loopnest)\n        *   [**Clang**](http://clang.llvm.org/)\n            *   [Extend clang AST to provide information for the type as written in template instantiations](https://llvm.org/OpenProjects.html#clang-template-instantiation-sugar)\n        *   **OpenMP**\n            *   [JIT-ing OpenMP GPU kernels transparently](https://llvm.org/OpenProjects.html#openmp_gpu_jit)\n        *   **OpenACC**\n            *   [OpenACC Diagnostics from the OpenMP Runtime](https://llvm.org/OpenProjects.html#openacc_rt_diagnostics)\n        *   **[Polly](https://polly.llvm.org/)**\n            *   [Use official isl C++ bindings](https://llvm.org/OpenProjects.html#polly_isl_bindings)\n        *   **[Enzyme](https://enzyme.mit.edu/)**\n            *   [Integrate custom derivatives of BLAS, Eigen, and similar routines into Enzyme](https://llvm.org/OpenProjects.html#enzyme_blas)\n            *   [Integrate Enzyme into Swift to provide high-performance differentiation in Swift](https://llvm.org/OpenProjects.html#enzyme_swift)\n            *   [Differentiation of Fixed-Point Arithmetic](https://llvm.org/OpenProjects.html#enzyme_fixed)\n            *   [Integrate Enzyme into Rust to provide high-performance differentiation in Rust](https://llvm.org/OpenProjects.html#enzyme_rust)\n        *   **Clang Static Analyzer**\n            *   [Clang Static Analyzer performance profiling](https://llvm.org/OpenProjects.html#static_analyzer_profling)\n            *   [Clang Static Analyzer constraint solver improvements](https://llvm.org/OpenProjects.html#static_analyzer_constraint_solver)\n        *   **LLDB**\n            *   [A structured approach to diagnostics in LLDB](https://llvm.org/OpenProjects.html#lldb_diagnostics)\n    *   [Google Summer of Code 2020](https://llvm.org/OpenProjects.html#gsoc20)\n        *   **LLVM Core**\n            *   [Improve debugging of optimized code](https://llvm.org/OpenProjects.html#llvm_optimized_debugging)\n            *   [Improve inter-procedural analyses and optimizations](https://llvm.org/OpenProjects.html#llvm_ipo)\n            *   [Improve parallelism-aware analyses and optimizations](https://llvm.org/OpenProjects.html#llvm_par)\n            *   [Make LLVM passes debug info invariant](https://llvm.org/OpenProjects.html#llvm_dbg_invariant)\n            *   [Improve MergeFunctions to incorporate MergeSimilarFunction patches and ThinLTO Support](https://llvm.org/OpenProjects.html#llvm_mergesim)\n            *   [Add DWARF support to yaml2obj](https://llvm.org/OpenProjects.html#llvm_dwarf_yaml2obj)\n            *   [Improve hot cold splitting to aggressively outline small blocks](https://llvm.org/OpenProjects.html#llvm_hotcold)\n            *   [Advanced Heuristics for Ordering Compiler Optimization Passes](https://llvm.org/OpenProjects.html#llvm_pass_order)\n            *   [Machine learning and compiler optimizations: using inter-procedural analysis to select optimizations](https://llvm.org/OpenProjects.html#llvm_ml_scc)\n            *   [Add PostDominatorTree in LoopStandardAnalysisResults](https://llvm.org/OpenProjects.html#llvm_postdominators)\n            *   [Create loop nest pass](https://llvm.org/OpenProjects.html#llvm_loopnest)\n            *   [Instruction properties dumper and checker](https://llvm.org/OpenProjects.html#llvm_instdump)\n            *   [Unify ways to move code or check if code is safe to be moved](https://llvm.org/OpenProjects.html#llvm_movecode)\n        *   [**Clang**](http://clang.llvm.org/)\n            *   [Extend clang AST to provide information for the type as written in template instantiations](https://llvm.org/OpenProjects.html#clang-template-instantiation-sugar)\n            *   [Find null smart pointer dereferences with the Static Analyzer](https://llvm.org/OpenProjects.html#clang-sa-cplusplus-checkers)\n        *   [**LLDB**](http://lldb.llvm.org/)\n        \n        *   [Support autosuggestions in LLDB's command line](https://llvm.org/OpenProjects.html#lldb-autosuggestions)\n        *   [Implement the missing tab completions for LLDB's command line](https://llvm.org/OpenProjects.html#lldb-more-completions)\n        *   [Reimplement LLDB's command-line commands using the public SB API.](https://llvm.org/OpenProjects.html#lldb-reimplement-lldb-cmdline)\n        *   [Add support for batch-testing to the LLDB testsuite.](https://llvm.org/OpenProjects.html#lldb-batch-testing)\n        \n        *   **MLIR**\n            *   See the [MLIR open project list](https://mlir.llvm.org/getting_started/openprojects/)\n    *   [Google Summer of Code 2019](https://llvm.org/OpenProjects.html#gsoc19)\n        *   **LLVM Core**\n            *   [Debug Info should have no effect on codegen](https://llvm.org/OpenProjects.html#debuginfo_codegen_mismatch)\n            *   [Improve (function) attribute inference](https://llvm.org/OpenProjects.html#llvm_function_attributes)\n            *   [Improve LLVM binary utilities](https://llvm.org/OpenProjects.html#improve_binary_utilities)\n        *   [**Clang**](http://clang.llvm.org/)\n            *   [Implement an ASTImporter fuzzer](https://llvm.org/OpenProjects.html#clang-astimporter-fuzzer)\n            *   [Improve shell autocompletion for Clang](https://llvm.org/OpenProjects.html#improve-autocompletion)\n            *   [Apply the Clang Static Analyzer to LLVM-based Projects](https://llvm.org/OpenProjects.html#analyze-llvm)\n            *   [Generate annotated sources based on LLVM-IR analyses](https://llvm.org/OpenProjects.html#header-generation)\n    *   [Google Summer of Code 2018](https://llvm.org/OpenProjects.html#gsoc18)\n    *   [Google Summer of Code 2017](https://llvm.org/OpenProjects.html#gsoc17)\n*   [What is this?](https://llvm.org/OpenProjects.html#what)\n*   [LLVM Subprojects: Clang and more](https://llvm.org/OpenProjects.html#subprojects)\n*   [Improving the current system](https://llvm.org/OpenProjects.html#improving)\n    1.  [Factor out target descriptions](https://llvm.org/OpenProjects.html#target-desc)\n    2.  [Implementing Code Cleanup bugs](https://llvm.org/OpenProjects.html#code-cleanups)\n    3.  [Compile programs with the LLVM Compiler](https://llvm.org/OpenProjects.html#programs)\n    4.  [Add programs to the llvm-test suite](https://llvm.org/OpenProjects.html#llvmtest)\n    5.  [Benchmark the LLVM compiler](https://llvm.org/OpenProjects.html#benchmark)\n    6.  [Benchmark Statistics and Warning System](https://llvm.org/OpenProjects.html#statistics)\n    7.  [Improving Coverage Reports](https://llvm.org/OpenProjects.html#coverage)\n    8.  [Miscellaneous Improvements](https://llvm.org/OpenProjects.html#misc_imp)\n*   [Adding new capabilities to LLVM](https://llvm.org/OpenProjects.html#new)\n    1.  [Extend the LLVM intermediate representation](https://llvm.org/OpenProjects.html#llvm_ir)\n    2.  [Pointer and Alias Analysis](https://llvm.org/OpenProjects.html#pointeranalysis)\n    3.  [Profile-Guided Optimization](https://llvm.org/OpenProjects.html#profileguided)\n    4.  [Code Compaction](https://llvm.org/OpenProjects.html#compaction)\n    5.  [New Transformations and Analyses](https://llvm.org/OpenProjects.html#xforms)\n    6.  [Code Generator Improvements](https://llvm.org/OpenProjects.html#codegen)\n    7.  [Miscellaneous Additions](https://llvm.org/OpenProjects.html#misc_new)\n*   [Project using LLVM](https://llvm.org/OpenProjects.html#using)\n    1.  [Add a MachineModulePass](https://llvm.org/OpenProjects.html#machinemodulepass)\n    2.  [Encode Analysis Results in MachineInstr IR](https://llvm.org/OpenProjects.html#encodeanalysis)\n    3.  [Code Layout in the LLVM JIT](https://llvm.org/OpenProjects.html#codelayoutjit)\n    4.  [Improved Structure Splitting and Field Reordering](https://llvm.org/OpenProjects.html#fieldlayout)\n    5.  [Finish the Slimmer Project](https://llvm.org/OpenProjects.html#slimmer)\n\nWelcome prospective Google Summer of Code 2025 Students! This document is your starting point to finding interesting and important projects for LLVM, Clang, and other related sub-projects. This list of projects is not only developed for Google Summer of Code, but open projects that really need developers to work on and are very beneficial for the LLVM community.\n\nWe encourage you to look through this list and see which projects excite you and match well with your skill set. We also invite proposals not on this list. More information and discussion about GSoC can be found in [discourse](https://discourse.llvm.org/c/community/gsoc) . If you have questions about a particular project please find the relevant entry in discourse, check previous discussion and ask. If there is no such entry or you would like to propose an idea please create a new entry. Feedback from the community is a requirement for your proposal to be considered and hopefully accepted.\n\nThe LLVM project has participated in Google Summer of Code for many years and has had some very successful projects. We hope that this year is no different and look forward to hearing your proposals. For information on how to submit a proposal, please visit the Google Summer of Code main [website.](https://summerofcode.withgoogle.com/)\n\n**Description**\n\nUse the variable location information from the debug info to annotate LLDB’s disassembler (and \\`register read\\`) output with the location and lifetime of source variables. The rich disassembler output should be exposed as structured data and made available through LLDB’s scripting API so more tooling could be built on top of this. In a terminal, LLDB should render the annotations as text.\n\n**Expected outcomes**\n\nFor example, we could augment the disassembly for the following function\n\nframe #0: 0x0000000100000f80 a.out\\`main(argc=1, argv=0x00007ff7bfeff1d8) at demo.c:4:10 \\[opt\\]\n  1   void puts(const char\\*);\n  2   int main(int argc, char \\*\\*argv) {\n  3    for (int i = 0; i < argc; ++i)\n→ 4      puts(argv\\[i\\]);\n  5    return 0;\n  6   }\n(lldb) disassemble\na.out\\`main:\n...\n  0x100000f71 <+17\\>: movl  %edi, %r14d\n  0x100000f74 <+20\\>: xorl  %r15d, %r15d\n  0x100000f77 <+23\\>: nopw  (%rax,%rax)\n→  0x100000f80 <+32\\>: movq  (%rbx,%r15,8), %rdi\n  0x100000f84 <+36\\>: callq 0x100000f9e ; symbol stub for: puts\n  0x100000f89 <+41\\>: incq  %r15\n  0x100000f8c <+44\\>: cmpq  %r15, %r14\n  0x100000f8f <+47\\>: jne 0x100000f80 ; <+32\\> at demo.c:4:10\n  0x100000f91 <+49\\>: addq  $0x8, %rsp\n  0x100000f95 <+53\\>: popq  %rbx\n...\n\nusing the debug information that LLDB also has access to (observe how the source variable i is in r15 from \\[0x100000f77+slide))\n\n$ dwarfdump demo.dSYM --name  i\ndemo.dSYM/Contents/Resources/DWARF/demo: file format Mach-O 64-bit x86-64\n0x00000076: DW\\_TAG\\_variable\n DW\\_AT\\_location (0x00000098:\n \\[0x0000000100000f60, 0x0000000100000f77): DW\\_OP\\_consts +0, DW\\_OP\\_stack\\_value\n \\[0x0000000100000f77, 0x0000000100000f91): DW\\_OP\\_reg15 R15)\n DW\\_AT\\_name (\"i\")\n DW\\_AT\\_decl\\_file (\"/tmp/t.c\")\n DW\\_AT\\_decl\\_line (3)\n DW\\_AT\\_type (0x000000b2 \"int\")\n\nto produce output like this, where we annotate when a variable is live and what its location is:\n\n(lldb) disassemble\na.out\\`main:\n...                                                               ; i=0\n  0x100000f74 <+20\\>: xorl  %r15d, %r15d                           ; i=r15\n  0x100000f77 <+23\\>: nopw  (%rax,%rax)                            ; |\n→  0x100000f80 <+32\\>: movq  (%rbx,%r15,8), %rdi                   ; |\n  0x100000f84 <+36\\>: callq 0x100000f9e ; symbol stub for: puts    ; |\n  0x100000f89 <+41\\>: incq  %r15                                   ; |\n  0x100000f8c <+44\\>: cmpq  %r15, %r14                             ; |\n  0x100000f8f <+47\\>: jne 0x100000f80 ; <+32\\> at t.c:4:10          ; |\n  0x100000f91 <+49\\>: addq  $0x8, %rsp                             ; i=undef\n  0x100000f95 <+53\\>: popq  %rbx\n\nThe goal would be to produce output like this for a subset of unambiguous cases, for example, variables that are constant or fully in registers.\n\n**Confirmed mentors and their contacts**\n\n*   Adrian Prantl aprantl@apple.com (primary contact)\n*   Jonas Devlieghere jdevlieghere@apple.com\n\n**Required / desired skills**\n\nRequired:\n\n*   Good understanding of C++\n*   Familiarity with using a debugger on the terminal\n*   Need to be familiar with all the concepts mentioned in the example above\n*   Need to have a good understanding of at least one assembler dialect for machine code (x86\\_64 or AArch64).\n\nDesired:\n\n*   Compiler knowledge including data flow and control flow analysis is a plus.\n*   Being able to navigate debug information (DWARF) is a plus.\n\n**Size of the project:**\n\nmedium (~175h)\n\n**Project difficulty:**\n\nhard\n\n**Discourse:** [URL](https://discourse.llvm.org/t/rich-disassembler-for-lldb/76952)\n\n**Description:**\n\n[Bfloat16](https://en.wikipedia.org/wiki/Bfloat16_floating-point_format) is a recently developed floating point format tailored to machine learning and AI, and in the latest [C++23 standard](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/n4950.pdf), it is officially standardized as std::bfloat16\\_t. Its support could be found in many modern hardware, ranging from CPUs of all the major vendors including Intel, AMD, Apple, and Amazon, to GPUs (nVidia and AMD GPUs) and Google TPUs. On the software side, it is supported in all major accelerator libraries, such as CUDA, ROCm, oneAPI, PyTorch, and Tensorflow. The goal for this project is to implement bfloat16 math functions in the LLVM libc library.\n\n**Expected result:**\n\n*   Setup the generated headers properly so that the type and the functions can be used with various compilers (+versions) and architectures.\n*   Implement generic basic math operations supporting bfloat16 data types that work on supported architectures: x86\\_64, arm (32 + 64), risc-v (32 + 64), and GPUs.\n*   Implement specializations using compiler builtins or special hardware instructions to improve their performance whenever possible.\n*   If time permits, we can start investigating higher math functions for bfloat16.\n\n**Skills:**\n\nBasic C & C++ skills + Interest in knowing / learning more about the delicacy of floating point formats.\n\n**Project size:** Large\n\n**Difficulty:** Easy/Medium\n\n**Confirmed Mentors:** [Tue Ly](mailto:lntue.h@gmail.com), [Nicolas Celik](mailto:its.overmighty@gmail.com),\n\n**Discourse:** [URL](https://discourse.llvm.org/t/libc-gsoc-2025-bfloat16-in-llvm-libc/84469)\n\n**Description:**\n\nModern GPUs are capable of unified addressing with the host. We currently use this to provide I/O support using the [RPC interface](https://libc.llvm.org/gpu/rpc.html). However, this requires a dedicated user thread on the CPU to handle the server code. We want to explore alternatives to providing I/O from the GPU using the Linux [io\\_uring](https://en.wikipedia.org/wiki/Io_uring) interface.\n\nThis interface is a ring buffer designed to accelerate syscalls. However, it provides a [polling mode](https://unixism.net/loti/tutorial/sq_poll.html#sq-poll) that allows the kernel to flush the ring buffer without the user initiating a system call. We should be able to register `mmap()` memory with the GPU using [AMD](https://github.com/ROCm/ROCR-Runtime/blob/amd-staging/runtime/hsa-runtime/inc/hsa_ext_amd.h#L3022) and [NVIDIA](https://docs.nvidia.com/cuda/cuda-driver-api/group__CUDA__UNIFIED.html) API calls. This interface should allow us to implement a rudimentary read/write interface which can be thought of as the same as the syscall on the CPU. That can then be used to implement a whole file interface.\n\n**Expected result:**\n\n*   An implementation of `pwrite` and `pread` that runs on the GPU.\n*   Support for `printf` by forwarding `snprintf` into `pwrite`.\n*   If time permits, exploring GPU file APIs.\n\n**Skills:**\n\nBasic C & C++ skills + access to a GPU, Linux kernel knowledge, GPU knowledge.\n\n**Project size:** Small\n\n**Difficulty:** Hard\n\n**Confirmed Mentors:** [Joseph Huber](mailto:joseph.huber@amd.com), [Tian Shilei](mailto:i@tianshilei.me)\n\n**Discourse:** [URL](https://discourse.llvm.org/t/libc-gsoc-2025-direct-i-o-from-the-gpu-with-io-uring/84569)\n\n**Description:**\n\nThe LLVM C library provides implementations of math functions. We want to profile these against existing implementations, such as CUDA's `libdevice`, ROCm's `device libs`, and OpenCL's `libclc`. Last year we worked on some interfaces to support these tests, now they need to be refined and filled out for the interesting functions.\n\nAdditionally, we want to verify the accuracy of these functions when run on the GPU via brute force testing. The goal is to verify that the implementations are correct and at least conformant to the error ranges in the [OpenCL standard](https://registry.khronos.org/OpenCL/specs/3.0-unified/html/OpenCL_C.html#relative-error-as-ulps). This will require a set of unit tests written in the `offload/` project, ideally using the new API that @callumfare is working on.\n\n**Expected result:**\n\n*   Final performance results similar to [Old results](https://dl.acm.org/doi/fullHtml/10.1145/3624062.3624166) but with the more optimized functions and higher accuracy.\n*   A test suite that can do brute force testing to confirm that the implementations are conformant.\n\n**Skills:**\n\nBasic C & C++ skills + access to a GPU, some math knowledge\n\n**Project size:** Small\n\n**Difficulty:** Easy / Medium\n\n**Confirmed Mentors:** [Joseph Huber](mailto:joseph.huber@amd.com), [Tue Ly](mailto:lntue.h@gmail.com)\n\n**Discourse:** [URL](https://discourse.llvm.org/t/libc-gsoc-2025-profiling-and-testing-of-the-llvm-libc-gpu-math/84570)\n\n**Description:** The [ClangIR](https://clangir.org/) (CIR) project aims to establish a new intermediate representation (IR) for Clang. Built on top of MLIR, it provides a dialect for C/C++ based languages in Clang, and the necessary infrastructure to emit it from the Clang AST, as well as a lowering path to the LLVM-IR dialect. ClangIR [upstreaming](https://discourse.llvm.org/t/rfc-upstreaming-clangir/76587) is currently in progress.\n\nIn order to give community more frequent updates it'd be great if we can report ClangIR progress by measuring the coverage of existing Clang's CodeGen tests in face of a ClangIR enabled pipeline. By collecting information on crashing, passing or failing tests we can come up with a metric that is easier to report and understand, provide entry points for newcomers looking for tasks and help the project by classifying existing issues. Existing Clang CodeGen tests live in clang/test/CodeGen\\* and can be found in different states regarding ClangIR support:\n\n*   **FileCheck fails**. LLVM IR builds but FileCheck fails to match output\n    *   LLVM IR differs because ClangIR pipeline is emitting different IR (e.g. different instructions are used, missing attributes). Issues need to be created and ClangIR needs to be fixed.\n    *   LLVM IR differs because CHECK lines need be made more flexible (LLVM-IR dialect output is different, SSA value names, order of attributes, etc). It's possible a tool like llvm-canon might be of good use here.\n*   **Test crash / error**. ClangIR doesn't support some C/C++ construct or LLVM lowering hasn't been implemented.\n*   **Test pass**. Yay!\n\nIn order to retrieve the information above, the student needs to make changes to Clang's testing infra (LIT configs, scripts, tests, ???) such that it's easier to replay the same invocations with ClangIR enabled, compare against traditional pipeline result or retrieve special directives from tests.\n\nIt's not clear what is the best methodology just yet, but it's expected that submitted proposals that want to be taken seriously should present few possible ideas on how to achieve this, prior discussion with other members of the community is encouraged. The student is also expected to interact with the ClangIR community, file github issues, investigate and/or make changes to failing codegen tests.\n\n**Expected result:**\n\n1.  Build the infrastructure to run tests and collect results.\n2.  Present the results in a way that can be placed on a webpage.\n3.  File issues or change check lines for 50% of the \"FileCheck fails\" category above. The only subdirectories that need consideration for the moment are:\n    \n        clang/test/CodeGen\n        clang/test/CodeGenCXX\n        clang/test/CodeGenOpenCL\n        clang/test/CodeGenCUDA\n        \n    \n\n*   Bonus point: find ways to automate/facilitate changes to tests, put PRs to fix problems in ClangIR.\n\n**Skills:** Python, intermediate C++ programming skills and familiarity with basic compiler design concepts are required. Prior experience with LLVM IR, MLIR, Clang or ClangIR programming is a big plus, but willingness to learn is also a possibility.\n\n**Project size:** Large\n\n**Difficulty:**Medium\n\n**Potential Mentors:** [Bruno Cardoso Lopes](https://github.com/bcardosolopes) [Andy Kaylor](https://github.com/andykaylor)\n\n**Discourse:** [URL](https://discourse.llvm.org/t/clangir-gsoc2025-validate-existing-clang-codegen-test-coverage-with-clangir/84481)\n\n**Description:** [ClangIR](https://clangir.org/) is a new, MLIR\\_based intermediate representation of C and C++ code. It has been developed in an LLVM incubator project, but work is now underway to migrate the code from the incubator to the main LLVM repository. As the code is moved, it must be updated to align with LLVM coding standards and quality expectations. The goal for this project is to participate in the ClangIR upstreaming process and help improve both the code and the upstreaming process.\n\nThe ClangIR project intends to unlock the possibility of better optimization, analysis, and diagnostics for C and C++ code by adding new abstractions that more closely model the source constructs, preserving more details than are available in standard LLVM IR. The ClangIR dialect is already being used to solve real-world problems using the implementation available in the ClangIR incubator, but we need to move this into the main LLVM repository in order to make this functionality available to a larger audience.\n\nThis project will be an opportunity to gain hands-on experience with MLIR development with a focus on day-to-day software engineering discipline. Participants will work side-by-side with other LLVM contributors to achieve a common goal, and in the process will gain a deep understanding of the ClangIR dialect.\n\n**Expected result:**\n\n1.  Migrate ClangIR support for C and C++ language features into the main LLVM repository\n2.  Improve the quality of code as it is being migrated\n3.  Suggest ways to improve the migration process\n\n**Skills:** Proficiency with modern C++ programming and familiarity with basic compiler design concepts are required. Prior experience with LLVM IR, MLIR, Clang or ClangIR programming is a big plus, but since the goal of this project is to gain such experience, it is not a prerequisite.\n\n**Project size:** Medium to Large\n\n**Difficulty:**Medium\n\n**Potential Mentors:** [Andy Kaylor](https://github.com/andykaylor) [Bruno Cardoso Lopes](https://github.com/bcardosolopes)\n\n**Discourse:** [URL](https://discourse.llvm.org/t/clangir-gsoc-2025-clangir-upstreaming/84766)\n\n**Description:** The [Clang Static Analyzer](https://clang.llvm.org/docs/ClangStaticAnalyzer.html) (CSA) can already find a wide range of temporal memory errors. These checks often have hardcoded knowledge about the behavior of some APIs. For example, the `cplusplus.InnerPointer` checker knows the semantics of `std::string::data`. The Clang community introduced some lifetime annotations including `[[clang::lifetimebound]]` and `[[clang::lifetime_capture_by(X)]]` and made [many improvements](https://discourse.llvm.org/t/lifetime-analysis-improvements-in-clang/81374) to Clang's default warnings. Unfortunately, the compiler's warnings only do statement local analysis. The CSA is capable of advanced inter-procedural analysis. Generalizing the existing checks like `cplusplus.InnerPointer` could enable the analyzer to find even more errors in annotated code. This can become even more impactful once the standard library [gets annotated](https://github.com/llvm/llvm-project/pull/112751).\n\n**Expected result:**\n\n1.  Identify the checks that can benefit from the `[[clang::lifetimebound]]` and `[[clang::lifetime_capture_by(X)]]` annotations.\n2.  Extend those checks to support these annotations.\n3.  Make sure the generated bug reports are high quality, the diagnostics properly explain how the analyzer took these annotations into account.\n4.  Validate the results on real world projects.\n5.  Potentially warn about faulty annotations (stretch goal).\n\n**Skills:** Intermediate C++ programming skills and familiarity with basic compiler design concepts are required. Prior experience with Clang or CSA programming is a big plus, but willingness to learn is also a possibility.\n\n**Project size:** Large\n\n**Difficulty:**Hard\n\n**Potential Mentors:** [Gabor Horvath](https://github.com/Xazax-hun) [Balazs Benics](https://github.com/steakhal) [Daniel Domjan](https://github.com/isuckatcs)\n\n**Discourse:** [URL](https://discourse.llvm.org/t/clang-static-analyzer-gsoc-2025-teach-the-clang-static-analyzer-to-understand-lifetime-annotations/84487)\n\n**Description**\n\nCurrently there is no easy way to take a collection of source files using C++20 modules and build an executable from them. This makes it hard to create simple tests or tiny programs using C++20 modules without first setting up a build system. This project's goal is to extend the extremely simple build system in Clang's driver to handle these cases.\n\nThis can be done by using Clang's existing support for scanning for C++20 modules to discover the dependencies between the source files that have been passed in, and then build them in that order, passing in the right PCM files where needed. This may also be extended to support explicitly building Clang modules discovered via module map files too.\n\n**Expected outcomes**\n\nInvoking clang similarly to\n\nclang -o program -std=c++20 main.cpp A.cppm B.cppm\n\nshould compile successfully where each translation-unit only imports modules defined in other source files on the command line, or the standard library. This should add no overhead to cases where modules are not used.\n\n**Confirmed mentors and their contacts**\n\n*   [Michael Spencer](https://github.com/Bigcheese)\n\n**Required skills**\n\nIntermediate knowledge of C++; familiarity with how C++ code is built. Familiarity with C++20 modules is an asset, but not required.\n\n**Size of the project:**\n\nmedium (~175h)\n\n**Project difficulty:**\n\nmedium\n\n**Discourse:** [URL](https://discourse.llvm.org/t/clang-gsoc-2025-support-simple-c-20-modules-use-from-the-clang-driver-without-a-build-system/84511)\n\n**Description**\n\nUndefined Behavior Sanitizer (UBSan) is a useful compilation mode in Clang for finding uses of undefined behavior (e.g. signed integer overflow) and problematic C/C++ code (e.g. unsigned integer overflow). The default version of UBSan uses a compiler runtime that only works in userspace (e.g. it won’t work in the kernel or for embedded applications) and is not considered secure enough for use in production environments. To handle these other environments UBSan provides a trapping mode that emits trap instructions that immediately halts the application rather than calling into the UBSan runtime which normally diagnoses the problem and then carries on execution.\n\nUnfortunately trapping UBSan has some deficiencies which make it hard to use. In particular:\n\n*   Clang silently ignores the \\-fsanitize-trap=undefined flag when it's passed without \\-fsanitize=undefined. This project would fix this as a “warm up task” to get familiar with the Clang codebase.\n*   When a UBSan trap is hit with the debugger attached it is not convenient to figure out the reason UBSan trapped. For x86\\_64 and arm64 some information is encoded in the instruction but decoding this is very inconvenient. While LLDB could be taught to look at the instruction and decode the meaning this is brittle because it depends on undocumented compiler ABI. Instead we can build upon the \\_\\_builtin\\_verbose\\_trap work to encode the reason for trapping inside the debug information.\n\n**Expected outcomes**\n\n*   When the \\-fsanitize-trap=undefined flag is passed on its own the compiler silently ignores it. Currently Clang requires that the \\-fsanitize-trap= flag is also passed. Clang should be taught to warn about this.\n*   Teach Clang to emit the UBSan trap reasons in debug information on UBSan trap instructions similar to how \\_\\_builtin\\_verbose\\_trap works.\n*   Confirm LLDB is able to recognize the UBSan trap reasons and add tests for this.\n\n**Confirmed mentors and their contacts**\n\n*   [Dan Liew](https://github.com/delcypher)\n*   [Michael Buch](https://github.com/Michael137)\n\n**Required skills**\n\nGood understanding of C++\n\n**Desirable skills**\n\n*   Familiarity with UBSan\n*   Familiarity with LLDB\n\n**Size of the project:**\n\nsmall (~10h). but can be extended if time allows\n\n**Project difficulty:**\n\nEasy. This project would be good to a beginner to LLVM. If we end up having lots of extra time we can investigate improving the UBSan reasons by encoding other useful information that the compiler knows into the trap reason.\n\n**Discourse:** [URL](https://discourse.llvm.org/t/clang-gsoc-2025-usability-improvements-for-trapping-undefined-behavior-sanitizer/84568)\n\n**Description of the project:** [Clang-Doc](https://clang.llvm.org/extra/clang-doc.html) is a C/C++ documentation generation tool created as an alternative for Doxygen and built on top of LibTooling. This effort started in 2018 and critical mass has landed in 2019, but the development has been largely stagnant mostly due to a lack of resources until last year when the development restarted as a successful Google Summer of Code project.\n\nThe tool is built on top of LibTooling and leverages Clang parsers which supports parsing of Doxygen commands in documentation comments (this support is also used in the implementation of Clang’s\n\n\\-Wdocumentation\n\nwhich can be used to validate the content of documentation comments during compilation).\n\nUnfortunately, Clang’s documentation parser is incomplete and has several issues:\n\n*   Not all Doxygen commands are supported, limiting the Clang-Doc’s usability.\n*   Not all C/C++ constructs are currently handled, most notably C++20 features such as concepts.\n*   Markdown support in documentation comments introduced in Doxygen version 1.8.0 is missing.\n\n**Expected result:** The goal of this project is to implement the missing features in Clang’s documentation parser as well as their handling in Clang-Doc to improve the quality of the generated documentation. The eventual goal is for the LLVM project to start using Clang-Doc for generating its reference documentation, but before we can do that we need to ensure that all required features are implemented.\n\nSuccessful proposals should focus not only on addressing the existing limitations, but also draw inspiration for other potential improvements from other documentation tools such as [hdoc](https://hdoc.io/), [standardese](https://github.com/standardese/standardese), [subdoc](https://github.com/chromium/subspace/tree/main/subdoc) or [cppdocgen](https://cs.opensource.google/fuchsia/fuchsia/+/main:tools/cppdocgen/).\n\nOver the course of the project, the candidate will have an opportunity to gain significant experience with LLVM and Clang internals (including lexer and parser) and C/C++ language.\n\n**Skills:** Intermediate knowledge of C++; interest in compilers and parsers. Previous experience with Clang/LibTooling is a bonus but not required.\n\n**Project size:** Either medium or large.\n\n**Difficulty:** Medium\n\n**Confirmed Mentor:** [Petr Hosek](https://github.com/petrhosek), [Paul Kirth](https://github.com/ilovepi)\n\n**Discourse:** [URL](https://discourse.llvm.org/t/improve-documentation-parsing-in-clang/84513)\n\n**Description of the project:** The Clang compiler is part of the LLVM compiler infrastructure and supports various languages such as C, C++, ObjC and ObjC++. The design of LLVM and Clang enables them to be used as libraries, and has led to the creation of an entire compiler-assisted ecosystem of tools. The relatively friendly codebase of Clang and advancements in the JIT infrastructure in LLVM further enable research into different methods for processing C++ by blurring the boundary between compile time and runtime. Challenges include incremental compilation and fitting compile/link time optimizations into a more dynamic environment. Incremental compilation pipelines process code chunk-by-chunk by building an ever-growing translation unit. Code is then lowered into the LLVM IR and subsequently run by the LLVM JIT. Such a pipeline allows creation of efficient interpreters. The interpreter enables interactive exploration and makes the C++ language more user friendly. Clang-Repl is one example.\n\n**Expected result:** The project aims to develop a robust mechanism for resolving missing symbols by dynamically identifying and loading the appropriate shared objects or static archives. Additionally, it will explore use cases where adapting symbols based on execution profiles leads to measurable performance improvements, optimizing the efficiency of just-in-time compilation and dynamic execution environments.\n\n**Skills:** Intermediate knowledge of C++, Understanding of LLVM and the LLVM JIT in particular\n\n**Project size:**Either medium or large.\n\n**Difficulty:** Medium\n\n**Confirmed Mentor:** [Vassil Vassilev](https://github.com/vgvassilev)\n\n**Discourse:** URL\n\n**Description**\n\nEnzyme requires good information about the memory layout of types. LLVM-IR is intentionally opaque, e.g. \\`&f32\\` and \\`&f64\\` both have the LLVM-IR type \\`ptr\\`. Enzyme is generally able to infer the underlying type (e.g. f32 vs f64) through usage analysis, but that process is slow and can in some cases fail. To make autodiff more robust, we should lower either MIR or THIR type information into LLVM-IR metadata. This analysis is recursive, for example \\`&\\[T\\]\\` is a fat pointer and therefore will be represented as a (ptr, int) pair in LLVM-IR. In this case the algorithm should recursively also analyze \\`T\\` and generate metadata for it.\n\nThe function [here](https://github.com/rust-lang/rust/blob/d4bdd1ed551fed0c951eb47b4be2c79d7a02d181/compiler/rustc_monomorphize/src/partitioning/autodiff.rs#L30) can be extended to generate metadata from rusts Mid-level IR (MIR). A prototype of the parser was implemented [here](https://github.com/EnzymeAD/rust/blob/58fee1abf3f2cd0e73ee8b98e53869d6fc3ba604/compiler/rustc_middle/src/ty/mod.rs#L2826) and can be used for inspiration. Various LLVM-IR examples for the metadata which we want to generate can be found in [this](https://github.com/EnzymeAD/Enzyme/blob/main/enzyme/test/TypeAnalysis) test folder. Look for annotations in the style of \\` {\\[-1\\]:Pointer, \\[-1,0\\]:Float@float}\\`.\n\nThe online compiler [Explorer](https://enzyme.mit.edu/explorer/) fork can be used to trigger related bugs, starting with \"can not deduce type of X\".\n\n**Expected outcomes**\n\nThe participant should find and select some interesting testcases, in which Enzyme either fails to differentiate an example due to inssuficient Type Information, or takes unreasonable long times (e.g. \\> 20x slower than compiling the code without autodiff). In the second case, a profiler should be used to verify that Enzyme causes a long compile time due to type analysis. The participant should then write (or later extend) the Type parser to generate the correct metadata, such that Enzyme can handle the new testcases. The LIT testcases should be added to the rust compiler, to avoid further regressions.\n\nExamples for code that currently is not handled correctly can be discussed in the project proposal phase.\n\n**Confirmed mentors and their contacts**\n\n*   [Manuel Drehwald](https://github.com/ZuseZ4)\n*   [Oli Scherer](https://github.com/oli-obk)\n*   [Johannes Doerfert](https://github.com/jdoerfert)\n\n**Required skills**\n\nIntermediate knowledge of Rust and C++; Familiarity with profilers or LLVM metadata is an asset, but not required.\n\n**Size of the project:**\n\nmedium (~175h)\n\n**Project difficulty:**\n\nmedium\n\n**Discourse:** [URL](https://discourse.llvm.org/t/gsoc2025-improve-rust-enzyme-reliability-and-compile-times/84523)\n\n**Description:** Currently, every LLVM-based frontend that wants to support calling into C code (FFI) needs to re-implement a substantial amount of complex call ABI handling. The goal of this project is to introduce an LLVM ABI library, which can be reused across different frontends, including Clang. More details on the motivation and a broad outline of the design are available in the [corresponding RFC](https://discourse.llvm.org/t/rfc-an-abi-lowering-library-for-llvm/84495/1).\n\nThe initial phase of the project will be to implement a prototype that can handle at least the x86\\_64 System V ABI. This will involve implementing the ABI type system, mapping of Clang types to ABI types and moving at least part of the X86 ABIInfo implementation from Clang to the new ABI library. This is to demonstrate general feasibility, figure out design questions and analyze compilation-time impact.\n\nAssuming the results from the prototype are positive, the next step would be to upstream the implementation by splitting it into smaller PRs. Finally, the implementation can be expanded to cover additional targets, ultimately removing Clang's ABI handling code entirely.\n\n**Expected result:** The minimum result is a prototype for the x86\\_64 ABI. The maximum result is fully upstreamed support for all targets. The expected result is somewhere in the middle between those two.\n\n**Skills:** Intermediate C++. Some familiarity with LLVM is a plus, but not required.\n\n**Project size:** Large\n\n**Difficulty:** Hard\n\n**Confirmed mentors:** [Nikita Popov](https://github.com/nikic)\n\n**Discourse:** [URL](https://discourse.llvm.org/t/llvm-introduce-an-abi-lowering-library/84554)\n\n**Description:** LLVM IR can't represent implementations of memcpy, memcmp, etc correctly due to the lack of a way to represent raw memory. This project aims to add a new 'byte' type to the LLVM IR to represent raw memory.\n\nIn addition to adding the new type, the project involves changing clang to lower chars to the new b8 type instead of i8, fixing incorrect lowerings of memory intrinsics, and tracking down the performance regressions.\n\nThere is already a [prototype](https://github.com/georgemitenkov/GSoC-2021) implementation of the byte type for an older version of LLVM. More information [here](https://gist.github.com/georgemitenkov/3def898b8845c2cc161bd216cbbdb81f).\n\n**Expected result:** The minimum result is a port of the existing prototype to the current LLVM, fixing all known incorrect optimizations, add support for the byte type to Alive2, and a performance analysis.\n\n**Skills:** Intermediate C++, familiarity with LLVM, profiling.\n\n**Project size:** Large\n\n**Difficulty:** Hard\n\n**Confirmed mentors:** [Nuno Lopes](https://web.ist.utl.pt/nuno.lopes/)\n\n**Discourse:** [URL](https://discourse.llvm.org/t/gsoc-2025-byte-type/84636)\n\n**Description:** LLVM offers different information via remarks, profiling, or runtime debug annotations (e.g., LIBOMPTARGET\\_INFO=-1). However, as projects increase, dissecting this information becomes difficult for users. For example, it is difficult to collect all this data, visualize it, and learn from it when building large projects.\n\nCurrently, some of this information—for example, compilation remarks—can be exported in JSON format. We want to create a tool to visualize, aggregate, and summarize the information. To aid accelerator development, we will start with the offload project as the primary candidate.\n\nSimilar tools, such as opt-viewer, can be used as references and starting points.\n\n**Expected outcomes:** The expected outcome is a tool (e.g., in the form of a compiler wrapper such as ccache) that will allow the dump of all the compiler-generated information in JSON format and organize it in a project structure.\n\nThe tool should generate an HTML-based report to help visualize the remarks. We envision a small client-server application using Python to spawn a local server as the visualization's front end. The server will expose the different reports and perform early analysis and aggregation.\n\nAdditionally, the tool should be designed so that, in the future, the analysis of the remarks can provide generalized guidelines for the developer (e.g., show the most common remark, use LLM models to explain actions, etc.). The client (HTML viewer) will display the aggregated data, in-line remarks, profile information, etc. We do not expect the project to have all the features at the end of the GSoC but to serve as a placeholder for growth in the future.\n\nIn particular, the outcomes of this project should be:\n\n*   Together with the mentors, help the design of the compiler wrapper, data storage layer, and client/server infrastructure. This includes the server API. The outcome of this task is a design document (similar to an RFC).\n*   Create a compiler wrapper that will dump different information in JSON format into the data storage layer (e.g., folders).\n*   Create a simple server layer that exposes the backend API to the front end. Python is the right way to do this, but we welcome other suggestions that align with the LLVM project. We would like to avoid relying on external projects (e.g., Flask) to avoid adding more dependencies to the LLVM project.\n*   Create a simple client-side visualization tool that can be extended in the future to show more reports.\n\n**Mentors:** [@shiltian](https://github.com/shiltian), [@jdoerfert](https://github.com/jdoerfert), [@josemonsalve2](https://github.com/josemonsalve2)\n\n**Required/desired skills:**\n\n*   Basic understanding of the LLVM Compiler to be able to generate compiler remarks, profiling data, and other information from the compiler.\n*   Proficiency in Python and C++.\n*   Full-stack web development.\n\n**Project size:** Large\n\n**Difficulty:** Easy\n\n**Discourse Link:** [\\[GSoC\\]\\[Offload\\]LLVM Compiler Remarks Visualization Tool for Offload Proposal](https://discourse.llvm.org/t/gsoc-offload-llvm-compiler-remarks-visualization-tool-for-offload-proposal/84596)\n\nGoogle Summer of Code 2024 was yet another successful one for LLVM project. For the list of accepted and completed projects, please take a look into Google Summer of Code [website](https://summerofcode.withgoogle.com/archive/2024/organizations/llvm-compiler-infrastructure).\n\nWelcome prospective Google Summer of Code 2024 Students! This document is your starting point to finding interesting and important projects for LLVM, Clang, and other related sub-projects. This list of projects is not only developed for Google Summer of Code, but open projects that really need developers to work on and are very beneficial for the LLVM community.\n\nWe encourage you to look through this list and see which projects excite you and match well with your skill set. We also invite proposals not on this list. More information and discussion about GSoC can be found in [discourse](https://discourse.llvm.org/c/community/gsoc) . If you have questions about a particular project please find the relevant entry in discourse, check previous discussion and ask. If there is no such entry or you would like to propose an idea please create a new entry. Feedback from the community is a requirement for your proposal to be considered and hopefully accepted.\n\nThe LLVM project has participated in Google Summer of Code for several years and has had some very successful projects. We hope that this year is no different and look forward to hearing your proposals. For information on how to submit a proposal, please visit the Google Summer of Code main [website.](https://summerofcode.withgoogle.com/)\n\n**Description of the project:** Many of LLVM's unit tests have been reduced automatically from larger tests. Previous-generation reduction tools used undef and poison as placeholders everywhere, as well as introduced undefined behavior (UB). Tests with UB are not desirable because 1) they are fragile since in the future the compiler may start optimizing more aggressively and break the test, and 2) it breaks translation validation tools such as [Alive2](https://github.com/AliveToolkit/alive2/) (since it's correct to translate a fuction that is always UB into anything).  \nThe major steps include:\n\n1.  Replace known patterns such as branch on undef/poison, memory accesses with invalid pointers, etc with non-UB patterns.\n2.  Use Alive2 to detect further patterns (by searching for tests that are always UB).\n3.  Report any LLVM bug found by Alive2 that is exposed when removing UB.\n\n**Expected result:** The majority of LLVM's unit tests will be free of UB.\n\n**Skills:** Experience with scripting (Python or PHP) is required. Experience with regular expressions is encouraged.\n\n**Project size:** Either medium or large.\n\n**Difficulty:** Medium\n\n**Confirmed Mentor:** [Nuno Lopes](https://web.ist.utl.pt/nuno.lopes/)\n\n**Discourse:** [URL](https://discourse.llvm.org/t/gsoc-2004-remove-undefined-behavior-from-tests/77236)\n\n**Description of the project:** The existing file that describes the SPIR-V instruction set in LLVM was manually created and is not always complete or up to date. Whenever new instructions need to be added to the SPIR-V backend, the file must be amended. In addition, since it is not created in a systematic way, there are often slight discrepancies between how an instruction is described in the SPIR-V spec and how it is declared in the TableGen file. Since SPIR-V backend developers often use the spec as a reference when developing new features, having a consistent mapping between the specification and TableGen records will ease development. This project proposes creating a script capable of generating a complete TableGen file that describes the SPIR-V instruction set given the JSON grammar available in the KhronosGroup/SPIRV-Headers repository, and updating SPIR-V backend code to use the new definitions. The specific method used for translating the JSON grammar to TableGen is left up to the discretion of the applicant, however, it should be checked into the LLVM repository with well-documented instructions to replicate the translation process so that future maintainers will be able to regenerate the file when the grammar changes. Note that the grammar itself should remain out-of-tree in its existing separate repository.\n\n**Expected result:**\n\n*   The SPIR-V instruction set's definition in TableGen is replaced with one that is autogenerated.\n*   A script and documentation are written that support regenerating the definitions as needed given the JSON grammar of the SPIR-V instruction set.\n*   Usage of the SPIR-V instruction set in the SPIR-V backend updated to use the new autogenerated definitions.\n\n**Skills:** Experience with scripting and an intermediate knowledge of C++. Previous experience with LLVM/TableGen is a bonus but not required.\n\n**Project size:** Medium (175 hour)\n\n**Confirmed Mentors:** [Natalie Chouinard](https://github.com/sudonatalie/), [Nathan Gauër](https://github.com/keenuts/)\n\n**Discourse:** [URL](https://discourse.llvm.org/t/clang-automatically-generate-tablegen-file-for-spir-v-instruction-set/76369)\n\n**Description of the project:** The LLVM bitstream file format is used for serialization of intermediate compiler artifacts, such as LLVM IR or Clang modules. There are situations where multiple bitstream files store identical information, and this duplication leads to increased storage requirements.\n\nThis project aims to integrate the LLVM CAS library into the LLVM bitstream file format. If we factor out the frequently duplicated part of a bitstream file into a separate CAS object, we can replace all copies with a small reference to the canonical CAS object, saving storage.\n\nThe primary motivating use-case for this project is the dependency scanner that's powering \"implicitly-discovered, explicitly-built\" Clang modules. There are real-world situations where even coarse de-duplication on the block level could halve the size of the scanning module cache.\n\n**Expected result:** There's a way to configure the LLVM bitstream writer/reader to use CAS as the backing storage.\n\n**Skills:** Intermediate knowledge of C++, some familiarity with data serialization, self-motivation.\n\n**Project size:** Medium or large\n\n**Confirmed Mentors:** [Jan Svoboda](https://github.com/jansvoboda11/), [Steven Wu](https://github.com/cachemeifyoucan/)\n\n**Discourse:** [URL](https://discourse.llvm.org/t/llvm-bitstream-integration-with-cas-content-addressable-storage/76757)\n\n**Description of the project:** [3-way comparisons](https://en.wikipedia.org/wiki/Three-way_comparison) return the values -1, 0 or 1 depending on whether the values compare lower, equal or greater. They are exposed in C++ via the spaceship operator (operator<\\=\\>) and in Rust via the PartialOrd and Ord traits. Currently, such comparisons produce sub-optimal codegen and optimization results in some cases.\n\nThe goal of this project is to resolve these optimization issues by implementing new 3-way comparison intrinsics, as described in [\\[RFC\\] Add 3-way comparison intrinsics](https://discourse.llvm.org/t/rfc-add-3-way-comparison-intrinsics/76685). The implementation steps are broadly:\n\n1.  Add the intrinsics to LLVM IR.\n2.  Implement legalization/expansion support in SelectionDAG and GlobalISel.\n3.  Implement optimization support in ConstantFolding, InstSimplify, InstCombine, CorrelatedValuePropagation, IndVarSimplify, ConstraintElimination, IPSCCP, and other relevant transforms.\n4.  Make use of the intrinsics via InstCombine canonicalization or direct emission in clang/rustc.\n\nAdding new target-independent intrinsics is a good way of becoming familiar with a broad slice of LLVM!\n\n**Expected result:** Support for the intrinsics in the backend and the most important optimization passes. Ideally full integration starting at the frontend.\n\n**Skills:** Intermediate knowledge of C++\n\n**Project size:** Medium or large\n\n**Difficulty:** Medium\n\n**Confirmed Mentors:** [Nikita Popov](https://github.com/nikic), [Dhruv Chawla](https://github.com/dc03)\n\n**Discourse:** [URL](https://discourse.llvm.org/t/llvm-add-3-way-comparison-intrinsics/76807)\n\n**Description of the project:** The llvm.org website serves as the central hub for information about the LLVM project, encompassing project details, current events, and relevant resources. Over time, the website has evolved organically, prompting the need for a redesign to enhance its modernity, structure, and ease of maintenance.\n\nThe goal of this project is to create a contemporary and coherent static website that reflects the essence of LLVM.org. This redesign aims to improve navigation, taxonomy, content discoverability, mobile device support, accessibility, and overall usability. Given the critical role of the website in the community, efforts will be made to engage with community members, seeking consensus on the proposed changes.\n\n**Expected result:** A modern, coherent-looking website that attracts new prospect users and empowers the existing community with better navigation, taxonomy, content discoverability, and overall usability. Since the website is a critical infrastructure and most of the community will have an opinion this project should try to engage with the community building community consensus on the steps being taken. Suggested approach:\n\n*   Conduct a comprehensive content audit of the existing website.\n*   Select appropriate technologies, preferably static site generators like Hugo or Jekyll.\n*   Advocate for a separation of data and visualization, utilizing formats such as YAML and Markdown to facilitate content management without direct HTML coding.\n*   Present three design mockups for the new website, fostering open discussions and allowing time for alternative proposals from interested parties.\n*   Implement the chosen design, incorporating valuable feedback from the community.\n*   Collaborate with content creators to integrate or update content as needed.\n\nThe successful candidate should commit to regular participation in weekly meetings, deliver presentations, and contribute blog posts as requested. Additionally, they should demonstrate the ability to navigate the community process with patience and understanding.\n\n**Skills:** Knowledge in the area of web development with static site generators. Knowledge in html, css, bootstrap, and markdown. Patience and self-motivation.\n\n**Difficulty:** Hard\n\n**Project size:** Large\n\n**Confirmed Mentors:** [Tanya Lattner](https://github.com/tlattner), [Vassil Vassilev](https://github.com/vgvassilev)\n\n**Discourse:** [URL](https://discourse.llvm.org/t/improve-the-llvm-org-website-look-and-feel/76864)\n\n**Description of the project:** The Clang compiler is part of the LLVM compiler infrastructure and supports various languages such as C, C++, ObjC and ObjC++. The design of LLVM and Clang enables them to be used as libraries, and has led to the creation of an entire compiler-assisted ecosystem of tools. The relatively friendly codebase of Clang and advancements in the JIT infrastructure in LLVM further enable research into different methods for processing C++ by blurring the boundary between compile time and runtime. Challenges include incremental compilation and fitting compile/link time optimizations into a more dynamic environment.\n\nIncremental compilation pipelines process code chunk-by-chunk by building an ever-growing translation unit. Code is then lowered into the LLVM IR and subsequently run by the LLVM JIT. Such a pipeline allows creation of efficient interpreters. The interpreter enables interactive exploration and makes the C++ language more user friendly. Clang-Repl is one example.\n\nClang-Repl uses the Orcv2 JIT infrastructure within the same process. That design is efficient and easy to implement however it suffers from two significant drawbacks. First, it cannot be used in devices which do not have sufficient resources to host the entire infrastructure, such as the arduino due (see this [talk](https://compiler-research.org/meetings/#caas_10Mar2022) for more details). Second, crashes in user codes mean that the entire process crashes, hindering overall reliability and ease of use.\n\nThis project aims to move Clang-Repl to an out-of-process execution model in order to address both of these issues.\n\n**Expected result:** Implement an out-of-process execution of statements with Clang-Repl; Demonstrate that Clang-Repl can support some of the ez-clang use-cases; Research into approaches to restart/continue the session upon crash; As a stretch goal design a versatile reliability approach for crash recovery;\n\n**Skills:** Intermediate knowledge of C++, Understanding of LLVM and the LLVM JIT in particular\n\n**Project size:**Either medium or large.\n\n**Difficulty:** Medium\n\n**Confirmed Mentor:** [Vassil Vassilev](https://github.com/vgvassilev),\n\n**Discourse:** [URL](https://discourse.llvm.org/t/clang-out-of-process-execution-for-clang-repl/68225)\n\n**Description of the project:** The Clang compiler is part of the LLVM compiler infrastructure and supports various languages such as C, C++, ObjC and ObjC++. The design of LLVM and Clang allows the compiler to be extended with plugins\\[1\\]. A plugin makes it possible to run extra user defined actions during a compilation. Plugins are supported on unix and darwin but not on windows due to some specifics of the windows platform.\n\nThis project would expose the participant to a broad cross section of the LLVM codebase. It involves exploring the API surface, classifying the interfaces as being public or private, and annotating that information to the API declarations. It would also expose the participant to details and differences of different platforms as this work is cross-platform (Windows, Linux, Darwin, BSD, etc). The resulting changes would improve LLVM on Linux and Windows while enabling new functionality on Windows.\n\n**Expected result:** This project aims to allow make clang -fplugin=windows/plugin.dll work. The implementation approach should extend the working prototype \\[3\\] and extend the annotation tool \\[4\\]. The successful candidate should be prepared to attend a weekly meeting, make presentations and prepare blog posts upon request.\n\n_Further reading_  \n\\[1\\] https://clang.llvm.org/docs/ClangPlugins.html  \n\\[2\\] https://discourse.llvm.org/t/clang-plugins-on-windows  \n\\[3\\] https://github.com/llvm/llvm-project/pull/67502  \n\\[4\\] https://github.com/compnerd/ids\n\n**Skills:** Intermediate knowledge of C++, Experience with Windows and its compilation and linking model.\n\n**Project size:**Either medium or large.\n\n**Difficulty:** Medium\n\n**Confirmed Mentor:** [Vassil Vassilev](https://github.com/vgvassilev), [Saleem Abdulrasool](https://github.com/compnerd)\n\n**Discourse:** [URL](https://discourse.llvm.org/t/support-clang-plugins-on-windows/76408)\n\n**Description of the project:** Clang, like any C++ compiler, parses a sequence of characters as they appear, linearly. The linear character sequence is then turned into tokens and AST before lowering to machine code. In many cases the end-user code uses a small portion of the C++ entities from the entire translation unit but the user still pays the price for compiling all of the redundancies.\n\nThis project proposes to process the heavy compiling C++ entities upon using them rather than eagerly. This approach is already adopted in Clang’s CodeGen where it allows Clang to produce code only for what is being used. On demand compilation is expected to significantly reduce the compilation peak memory and improve the compile time for translation units which sparsely use their contents. In addition, that would have a significant impact on interactive C++ where header inclusion essentially becomes a no-op and entities will be only parsed on demand.\n\nThe Cling interpreter implements a very naive but efficient cross-translation unit lazy compilation optimization which scales across hundreds of libraries in the field of high-energy physics.\n\n// A.h\n#include <string\\>\n#include <vector\\>\ntemplate <class T, class U = int\\> struct AStruct {\n  void doIt() { /\\*...\\*/ }\n  const char\\* data;\n  // ...\n};\n\ntemplate<class T, class U = AStruct<T\\>\\>\ninline void freeFunction() { /\\* ... \\*/ }\ninline void doit(unsigned N = 1) { /\\* ... \\*/ }\n\n// Main.cpp\n#include \"A.h\"\nint main() {\n  doit();\n  return 0;\n}\n    \n\nThis pathological example expands to 37253 lines of code to process. Cling builds an index (it calls it an autoloading map) where it contains only forward declarations of these C++ entities. Their size is 3000 lines of code. The index looks like:\n\n// A.h.index\nnamespace std{inline namespace \\_\\_1{template <class \\_Tp, class \\_Allocator\\> class \\_\\_attribute\\_\\_((annotate(\"$clingAutoload$vector\")))  \\_\\_attribute\\_\\_((annotate(\"$clingAutoload$A.h\")))  \\_\\_vector\\_base;\n  }}\n...\ntemplate <class T, class U = int\\> struct \\_\\_attribute\\_\\_((annotate(\"$clingAutoload$A.h\"))) AStruct;\n    \n\nUpon requiring the complete type of an entity, Cling includes the relevant header file to get it. There are several trivial workarounds to deal with default arguments and default template arguments as they now appear on the forward declaration and then the definition. You can read more in \\[1\\].\n\nAlthough the implementation could not be called a reference implementation, it shows that the Parser and the Preprocessor of Clang are relatively stateless and can be used to process character sequences which are not linear in their nature. In particular namespace-scope definitions are relatively easy to handle and it is not very difficult to return to namespace-scope when we lazily parse something. For other contexts such as local classes we will have lost some essential information such as name lookup tables for local entities. However, these cases are probably not very interesting as the lazy parsing granularity is probably worth doing only for top-level entities.\n\nSuch implementation can help with already existing issues in the standard such as CWG2335, under which the delayed portions of classes get parsed immediately when they're first needed, if that first usage precedes the end of the class. That should give good motivation to upstream all the operations needed to return to an enclosing scope and parse something.\n\n**Implementation approach**: Upon seeing a tag definition during parsing we could create a forward declaration, record the token sequence and mark it as a lazy definition. Later upon complete type request, we could re-position the parser to parse the definition body. We already skip some of the template specializations in a similar way \\[2, 3\\].\n\nAnother approach is every lazy parsed entity to record its token stream and change the Toks stored on LateParsedDeclarations to optionally refer to a subsequence of the externally-stored token sequence instead of storing its own sequence (or maybe change CachedTokens so it can do that transparently). One of the challenges would be that we currently modify the cached tokens list to append an \"eof\" token, but it should be possible to handle that in a different way.\n\nIn some cases, a class definition can affect its surrounding context in a few ways you'll need to be careful about here:\n\n1) \\`struct X\\` appearing inside the class can introduce the name \\`X\\` into the enclosing context.\n\n2) \\`static inline\\` declarations can introduce global variables with non-constant initializers that may have arbitrary side-effects.\n\nFor point (2), there's a more general problem: parsing any expression can trigger a template instantiation of a class template that has a static data member with an initializer that has side-effects. Unlike the above two cases, I don't think there's any way we can correctly detect and handle such cases by some simple analysis of the token stream; actual semantic analysis is required to detect such cases. But perhaps if they happen only in code that is itself unused, it wouldn't be terrible for Clang to have a language mode that doesn't guarantee that such instantiations actually happen.\n\nAlternative and more efficient implementation could be to make the lookup tables range based but we do not have even a prototype proving this could be a feasible approach.\n\n**Expected result:**\n\n*   Design and implementation of on-demand compilation for non-templated functions\n*   Support non-templated structs and classes\n*   Run performance benchmarks on relevant codebases and prepare report\n*   Prepare a community RFC document\n*   \\[Stretch goal\\] Support templates\n\nThe successful candidate should commit to regular participation in weekly meetings, deliver presentations, and contribute blog posts as requested. Additionally, they should demonstrate the ability to navigate the community process with patience and understanding.\n\n_Further reading_  \n\\[1\\] https://github.com/root-project/root/blob/master/README/README.CXXMODULES.md#header-parsing-in-root  \n\\[2\\] https://github.com/llvm/llvm-project/commit/b9fa99649bc99  \n\\[3\\] https://github.com/llvm/llvm-project/commit/0f192e89405ce\n\n**Skills:** Knowledge of C++, Deeper understanding of how Clang works, knowledge of Clang AST and Preprocessor.\n\n**Project size:**Large\n\n**Difficulty:** Hard\n\n**Confirmed Mentor:** [Vassil Vassilev](https://github.com/vgvassilev), [Matheus Izvekov](https://github.com/mizvekov)\n\n**Discourse:** [URL](https://discourse.llvm.org/t/on-demand-parsing-in-clang/76912)\n\n**Description of the project:** [Clang-Doc](https://clang.llvm.org/extra/clang-doc.html) is a C/C++ documentation generation tool created as an alternative for Doxygen and built on top of LibTooling. This effort started in 2018 and critical mass has landed in 2019, but the development has been largely dormant since then, mostly due to a lack of resources.\n\nThe tool can currently generate documentation in Markdown and HTML formats, but the tool has some structural issues, is difficult to use, the generated documentation has usability issues and is missing several key features:\n\n*   Not all C/C++ constructs are currently handled by the Markdown and HTML emitter limiting the tool’s usability.\n*   The generated HTML output does not scale with the size of the codebase making it unusable for larger C/C++ projects.\n*   The implementation does not always use the most efficient or appropriate data structures which leads to correctness and performance issues.\n*   There is a lot of duplicated boiler plate code which could be improved with templates and helpers.\n\n**Expected result:** The goal of this project is to address the existing shortcomings and improve the usability of Clang-Doc to the point where it can be used to generate documentation for large scale projects such as LLVM. The ideal outcome is that the LLVM project will use Clang-Doc for generating its [reference documentation](https://llvm.org/doxygen/).\n\nSuccessful proposals should focus not only on addressing the existing limitations, but also draw inspiration for other potential improvements from other similar tools such as [hdoc](https://hdoc.io/), [standardese](https://github.com/standardese/standardese), [subdoc](https://github.com/chromium/subspace/tree/main/subdoc) or [cppdocgen](https://cs.opensource.google/fuchsia/fuchsia/+/main:tools/cppdocgen/).\n\n**Skills:** Experience with web technologies (HTML, CSS, JS) and an intermediate knowledge of C++. Previous experience with Clang/LibTooling is a bonus but not required.\n\n**Project size:** Either medium or large.\n\n**Difficulty:** Medium\n\n**Confirmed Mentor:** [Petr Hosek](https://github.com/petrhosek), [Paul Kirth](https://github.com/ilovepi)\n\n**Discourse:** [URL](https://discourse.llvm.org/t/improve-clang-doc-usability/76996)\n\n**Description**\n\nUse the variable location information from the debug info to annotate LLDB’s disassembler (and \\`register read\\`) output with the location and lifetime of source variables. The rich disassembler output should be exposed as structured data and made available through LLDB’s scripting API so more tooling could be built on top of this. In a terminal, LLDB should render the annotations as text.\n\n**Expected outcomes**\n\nFor example, we could augment the disassembly for the following function\n\nframe #0: 0x0000000100000f80 a.out\\`main(argc=1, argv=0x00007ff7bfeff1d8) at demo.c:4:10 \\[opt\\]\n  1   void puts(const char\\*);\n  2   int main(int argc, char \\*\\*argv) {\n  3    for (int i = 0; i < argc; ++i)\n→ 4      puts(argv\\[i\\]);\n  5    return 0;\n  6   }\n(lldb) disassemble\na.out\\`main:\n...\n  0x100000f71 <+17\\>: movl  %edi, %r14d\n  0x100000f74 <+20\\>: xorl  %r15d, %r15d\n  0x100000f77 <+23\\>: nopw  (%rax,%rax)\n→  0x100000f80 <+32\\>: movq  (%rbx,%r15,8), %rdi\n  0x100000f84 <+36\\>: callq 0x100000f9e ; symbol stub for: puts\n  0x100000f89 <+41\\>: incq  %r15\n  0x100000f8c <+44\\>: cmpq  %r15, %r14\n  0x100000f8f <+47\\>: jne 0x100000f80 ; <+32\\> at demo.c:4:10\n  0x100000f91 <+49\\>: addq  $0x8, %rsp\n  0x100000f95 <+53\\>: popq  %rbx\n...\n\nusing the debug information that LLDB also has access to (observe how the source variable i is in r15 from \\[0x100000f77+slide))\n\n$ dwarfdump demo.dSYM --name  i\ndemo.dSYM/Contents/Resources/DWARF/demo: file format Mach-O 64-bit x86-64\n0x00000076: DW\\_TAG\\_variable\n DW\\_AT\\_location (0x00000098:\n \\[0x0000000100000f60, 0x0000000100000f77): DW\\_OP\\_consts +0, DW\\_OP\\_stack\\_value\n \\[0x0000000100000f77, 0x0000000100000f91): DW\\_OP\\_reg15 R15)\n DW\\_AT\\_name (\"i\")\n DW\\_AT\\_decl\\_file (\"/tmp/t.c\")\n DW\\_AT\\_decl\\_line (3)\n DW\\_AT\\_type (0x000000b2 \"int\")\n\nto produce output like this, where we annotate when a variable is live and what its location is:\n\n(lldb) disassemble\na.out\\`main:\n...                                                               ; i=0\n  0x100000f74 <+20\\>: xorl  %r15d, %r15d                           ; i=r15\n  0x100000f77 <+23\\>: nopw  (%rax,%rax)                            ; |\n→  0x100000f80 <+32\\>: movq  (%rbx,%r15,8), %rdi                   ; |\n  0x100000f84 <+36\\>: callq 0x100000f9e ; symbol stub for: puts    ; |\n  0x100000f89 <+41\\>: incq  %r15                                   ; |\n  0x100000f8c <+44\\>: cmpq  %r15, %r14                             ; |\n  0x100000f8f <+47\\>: jne 0x100000f80 ; <+32\\> at t.c:4:10          ; |\n  0x100000f91 <+49\\>: addq  $0x8, %rsp                             ; i=undef\n  0x100000f95 <+53\\>: popq  %rbx\n\nThe goal would be to produce output like this for a subset of unambiguous cases, for example, variables that are constant or fully in registers.\n\n**Confirmed mentors and their contacts**\n\n*   Adrian Prantl aprantl@apple.com (primary contact)\n*   Jonas Devlieghere jdevlieghere@apple.com\n\n**Required / desired skills**\n\nRequired:\n\n*   Good understanding of C++\n*   Familiarity with using a debugger on the terminal\n*   Need to be familiar with all the concepts mentioned in the example above\n*   Need to have a good understanding of at least one assembler dialect for machine code (x86\\_64 or AArch64).\n\nDesired:\n\n*   Compiler knowledge including data flow and control flow analysis is a plus.\n*   Being able to navigate debug information (DWARF) is a plus.\n\n**Size of the project.**\n\nmedium (~175h)\n\n**An easy, medium or hard rating if possible**\n\nhard\n\n**Discourse:** [URL](https://discourse.llvm.org/t/rich-disassembler-for-lldb/76952)\n\n**Description**\n\nLLVM-reduce, and similar tools perform delta debugging but are less useful if many implicit constraints exist and violation could easily lead to errors similar to the cause that is to be isolated. This project is about developing a GPU-aware version, especially for execution time bugs, that can be used in conjunction with LLVM/OpenMP GPU-record-and-replay, or simply a GPU loader script, to minimize GPU test cases more efficiently and effectively.\n\n**Expected outcomes**\n\nA tool to reduce GPU errors without loosing the original error. Optionally, other properties could be the focus of the reduction, not only errors.\n\n**Confirmed mentors and their contacts**\n\n*   Parasyris, Konstantinos parasyris1@llnl.gov\n*   Johannes Doerfert jdoerfert@llnl.gov\n\n**Required / desired skills**\n\nRequired:\n\n*   Good understanding of C++\n*   Familiarity with GPUs and LLVM-IR\n\nDesired:\n\n*   Compiler knowledge including data flow and control flow analysis is a plus.\n*   Experience with debugging and bug reduction techniques (llvm-reduce) is helpful\n\n**Size of the project.**\n\nmedium\n\n**An easy, medium or hard rating if possible**\n\nmedium\n\n**Discourse:** [URL](https://discourse.llvm.org/t/gsoc-2024-gpu-delta-debugging/77237)\n\n**Description**\n\nModern C++ defines parallel algorithms as part of the standard library, like \\`std::transform\\_reduce(std::execution::par\\_unseq, vec.begin(), vec.end(), 0, std::plus, …)\\`. In this project we want to extend an implementation of those that is using OpenMP, including GPU offload, where reasonable. While some algorithms might be amenable to GPU offload via a pure (wrapper) runtime solution, we know others, especially those featuring user provided functors, will also require static program analysis and potentially transformation for additional data management. The goal of the project is to explore different algorithms and the options we have to execute them on the host as well as on accelerator devices, esp. GPUs, automatically via OpenMP.\n\n**Expected outcomes**\n\nImprovements to the prototype support of offloading in libcxx. Evaluations against other offloading approaches and documentation on the missing parts and shortcommings.\n\n**Confirmed mentors and their contacts**\n\n*   Johannes Doerfert jdoerfert@llnl.gov\n*   Tom Scogland scogland1@llnl.gov\n*   Tom Deakin tom.deakin@bristol.ac.uk\n\n**Required / desired skills**\n\nRequired:\n\n*   Good understanding of C++ and C++ standard algorithms\n*   Familiarity with GPUs and (OpenMP) offloading\n\nDesired:\n\n*   Experience with libcxx (development).\n*   Experience debugging and profiling GPU code.\n\n**Size of the project.**\n\nlarge\n\n**An easy, medium or hard rating if possible**\n\nmedium\n\n**Discourse:** [URL](https://discourse.llvm.org/t/gsoc-2024-offloading-libcxx/77238)\n\n**Description**\n\nLLVM has lots of thresholds and flags to avoid \"costly cases\". However, it is unclear if these thresholds are useful, their value is reasonable, and what impact they really have. Since there are a lot, we cannot do a simple exhaustive search. In some prototype work we introduced a C++ class that can replace hardcoded values and offers control over the threshold, e.g., you can increase the recursion limit via a command line flag from the hardcoded \"6\" to a different number. In this project we want to explore the thresholds, when they are hit, what it means if they are hit, how we should select their values, and if we need different \"profiles\".\n\n**Expected outcomes**\n\nStatistical evidence on the impact of various thresholds inside of LLVM's code base, including compile time changes, impact on transformations, and performance measurements.\n\n**Confirmed mentors and their contacts**\n\n*   Jan Hueckelheim jhueckelheim@anl.gov\n*   Johannes Doerfert jdoerfert@llnl.gov\n*   William Moses wmoses@mit.edu\n\n**Required / desired skills**\n\nRequired:\n\n*   Profiling skills and knowledge of statistical reasoning\n\nDesired:\n\n*   Good understanding of the LLVM code base and optimization flow\n\n**Size of the project.**\n\nmedium\n\n**An easy, medium or hard rating if possible**\n\neasy\n\n**Discourse:** [URL](https://discourse.llvm.org/t/gsoc-2024-the-1001-thresholds-in-llvm/77235)\n\n**Description**\n\nWe have begun work on a libc library targeting GPUs. This will allow users to call functions such as malloc or memcpy while executing on the GPU. However, it is important that these implementations be functional and performant. The goal of this project is to benchmark the implementations of certain libc functions on the GPU. Work would include writing benchmarks to test the current implementations as well as writing more optimal implementations.\n\n**Expected outcomes**\n\nIn-depth performance for libc functions. Overhead of GPU-to-CPU remote procedure calls. More optimal implementations of 'libc' functions.\n\n**Confirmed mentors and their contacts**\n\n*   Joseph Huber joseph.huber@amd.com\n*   Johannes Doerfert jdoerfert@llnl.gov\n\n**Required / desired skills**\n\nRequired:\n\n*   Profiling skills and understanding of GPU architecture\n\nDesired:\n\n*   Experience with libc utilities\n\n**Size of the project.**\n\nsmall\n\n**An easy, medium or hard rating if possible**\n\neasy\n\n**Discourse:** [URL](https://discourse.llvm.org/t/libc-gsoc-2024-performance-and-testing-in-the-gpu-libc/77042)\n\n**Description**\n\n[GPU First](https://arxiv.org/abs/2306.11686) is a methodology and framework that can enable any existing host code to execute the entire program on a GPU without any modification from users. The goal of this project is two folded: 1) Port [host code](https://github.com/shiltian/llvm-project/tree/direct_gpu_compilation) to handle RPC to the new plugin and rewrite it with the host RPC framework introduced in the GPU LibC project. 2) Explore the support for MPI among multiple thread blocks on a single GPU, or even multiple GPUs.\n\n**Expected outcomes**\n\nMore efficient GPU First framework that can support both NVIDIA and AMD GPUs. Optionally, upstream the framework.\n\n**Confirmed mentors and their contacts**\n\n*   Shilei Tian i@tianshilei.me\n*   Johannes Doerfert jdoerfert@llnl.gov\n*   Joseph Huber joseph.huber@amd.com\n\n**Required / desired skills**\n\nRequired:\n\n*   Good understanding of C++ and GPU architecture\n*   Familiarity with GPUs and LLVM IR\n\nDesired:\n\n*   Good understanding of the LLVM code base and OpenMP target offloading\n\n**Size of the project.**\n\nmedium\n\n**An easy, medium or hard rating if possible**\n\nmedium\n\n**Discourse:** [URL](https://discourse.llvm.org/t/openmp-gsoc-2024-improve-gpu-first-framework/77048)\n\n**Description:** Heterogeneous programming models such as [SYCL](https://sycl.tech/), [OpenMP](https://www.openmp.org/) and [OpenACC](https://www.openacc.org/) help developers to offload computationally intensive kernels to GPUs and other accelerators. [MLIR](https://mlir.llvm.org/) is expected to unlock new high-level optimisations and better code generation for the next generation of compilers for heterogeneous programming models. However, the availability of a robust MLIR-emitting C/C++ frontend is a prerequisite for these efforts.\n\nThe [ClangIR](https://clangir.org/) (CIR) project aims to establish a new intermediate representation (IR) for Clang. Built on top of MLIR, it provides a dialect for C/C++ based languages in Clang, and the necessary infrastructure to emit it from the Clang AST, as well as a lowering path to the LLVM-IR dialect. Over the last year, ClangIR has evolved into a mature incubator project, and a recent [RFC](https://discourse.llvm.org/t/rfc-upstreaming-clangir/76587) on upstreaming it into the LLVM monorepo has seen positive comments and community support.\n\nThe overall goal of this GSoC project is to identify and implement missing features in ClangIR to make it possible to compile GPU kernels in the [OpenCL C language](https://registry.khronos.org/OpenCL/specs/3.0-unified/html/OpenCL_C.html) to LLVM-IR for the [SPIR-V](https://registry.khronos.org/SPIR-V) target. The OpenCL to SPIR-V flow is a great environment for this project because a) it is [already supported](https://clang.llvm.org/docs/OpenCLSupport.html) in Clang and b) OpenCL's work-item- and work-group-based programming model still captures modern GPU architectures well. The contributor will extend the AST visitors, the dialect and the LLVM-IR lowering, to add support e.g. for multiple address spaces, vector and custom floating point types, and the `spir_kernel` and `spir_func` calling conventions.\n\nA good starting point for this work is the [Polybench-GPU](https://github.com/sgrauerg/polybenchGpu/tree/master/OpenCL) benchmark suite. It contains self-contained small- to medium sized OpenCL implementations of common algorithms. We expect only the device code (\\*.cl files) to be compiled via ClangIR. The existing OpenCL support in Clang can be used to create lit tests with reference LLVM-IR output to guide the development. Optionally, the built-in result verification and time measurements in Polybench could also be used to assess the correctness and quality of the generated code.\n\n**Expected result:** Polybench-GPU's [`2DCONV`](https://github.com/sgrauerg/polybenchGpu/blob/master/OpenCL/2DCONV/2DConvolution.cl), [`GEMM`](https://github.com/sgrauerg/polybenchGpu/blob/master/OpenCL/GEMM/gemm.cl) and [`CORR`](https://github.com/sgrauerg/polybenchGpu/blob/master/OpenCL/CORR/correlation.cl) OpenCL kernels can be compiled with ClangIR to LLVM-IR for SPIR-V.\n\n**Skills:** Intermediate C++ programming skills and familiarity with basic compiler design concepts are required. Prior experience with LLVM IR, MLIR, Clang or GPU programming is a big plus, but willingness to learn is also a possibility.\n\n**Project size:** Large\n\n**Difficulty:** Medium\n\n**Confirmed Mentors:** [Julian Oppermann](https://github.com/jopperm), [Victor Lomüller](https://github.com/Naghasan), [Bruno Cardoso Lopes](https://github.com/bcardosolopes)\n\n**Discourse:** [URL](https://discourse.llvm.org/t/clangir-compile-gpu-kernels-using-clangir/76984)\n\n**Description:**\n\nHalf precision is an IEEE 754 floating point format that has been widely used recently, especially in machine learning and AI. It has been standardized as \\_Float16 in the latest C23 standard, bringing its support to the same level as float or double data types. The goal for this project is to implement C23 half precision math functions in the LLVM libc library.\n\n**Expected result:**\n\n*   Setup the generated headers properly so that the type and the functions can be used with various compilers (+versions) and architectures.\n*   Implement generic basic math operations supporting half precision data types that work on supported architectures: x86\\_64, arm (32 + 64), risc-v (32 + 64), and GPUs.\n*   Implement specializations using compiler builtins or special hardware instructions to improve their performance whenever possible.\n*   If time permits, we can start investigating higher math functions for half precision.\n\n**Skills:**\n\nIntermediate C++ programming skills and familiarity with basic compiler design concepts are required. Prior experience with LLVM IR, MLIR, Clang or GPU programming is a big plus, but willingness to learn is also a possibility.\n\n**Project size:** Large\n\n**Difficulty:** Easy/Medium\n\n**Confirmed Mentors:** [Tue Ly](mailto:lntue@google.com), [Joseph Huber](mailto:joseph.huber@amd.com),\n\n**Discourse:** [URL](https://discourse.llvm.org/t/libc-gsoc-2024-half-precision-in-llvm-libc/77027)\n\nGoogle Summer of Code 2023 was very successful for LLVM project. For the list of accepted and completed projects, please take a look into Google Summer of Code [website](https://summerofcode.withgoogle.com/archive/2023/organizations/llvm-compiler-infrastructure).\n\n**Description of the project:** In Just-In-Time compilers we often choose a low optimization level to minimize compile time and improve launch times and latencies, however some functions (which we call hot functions) are used very frequently and for these functions it is worth optimizing more heavily. In general hot functions can only be identified at runtime (different inputs will cause different functions to become hot), so the aim of the reoptimization project is to build infrastructure to (1) detect hot functions at runtime and (2) compile them a second time at a higher optimization level, hence the name \"re-optimization\".\n\nThere are many possible approaches to both parts of this problem. E.g. hot functions could be identified by sampling, or using existing profiling infrastructure, or by implementing custom instrumentation. Reoptimization could be applied to whole functions, or outlining could be used to enable optimization of portions of functions. Re-entry into the JIT infrastructure from JIT’d code might be implemented on top of existing lazy compilation, or via a custom path.\n\nWhatever design is adopted, the goal is that the infrastructure should be generic so that it can be used by other LLVM API clients, and should support out-of-process JIT-compilation (so some of the solution will be implemented in the ORC runtime).\n\n**Expected result:**\n\n*   Improve ergonomics of indirection – ideally all forms of indirection (for re-optimization, lazy compilation, and procedure-linkage-tables) should be able to share a single stub (and/or binary rewriting metadata) at runtime.\n*   Implement basic re-optimization on top of the tidied up indirection.\n*   (Stretch goal) Garbage-collect unoptimized code that is no longer needed once the optimized version is available.\n\n**Desirable skills:** Intermediate C++; Understanding of LLVM and the LLVM JIT in particular.\n\n**Project size:** Large.\n\n**Difficulty:** Medium\n\n**Confirmed Mentor:** [Vassil Vassilev](https://github.com/vgvassilev), [Lang Hames](https://github.com/lhames)\n\n**Discourse:** [URL](https://discourse.llvm.org/t/re-optimization-using-jitlink/68260)\n\n**Description of the project:** JITLink is LLVM's new JIT linker API -- the low-level API that transforms compiler output (relocatable object files) into ready-to-execute bytes in memory. To do this JITLink’s generic linker algorithm needs to be specialized to support the target object format (COFF, ELF, MachO), and architecture (arm, arm64, i386, x86-64). LLVM already has mature implementations of JITLink for MachO/arm64, MachO/x86-64, ELF/x86-64, ELF/aarch64 and COFF/x86-64, while the implementations for ELF/riscv, ELF/aarch32 and COFF/i386 are still relatively new.  \nYou can either work on an entirely new architecture like PowerPC or eBPF, or complete one of the recently added JITLink implementations. In both cases you will likely reuse the existing generic code for one of the target object formats. You will also work on relocation resolution, populate PLTs and GOTs and wire up the ORC runtime for your chosen target.\n\n**Expected result:** Write a JITLink specialization for a not-yet-supported or incomplete format/architecture such as PowerPC, AArch32 or eBPF.\n\n**Desirable skills:** Intermediate C++; Understanding of LLVM and the LLVM JIT in particular; familiarity with your chosen format/architecture, and basic linker concepts (e.g. sections, symbols, and relocations).\n\n**Project size:** Large.\n\n**Difficulty:**Medium\n\n**Confirmed Mentor:** [Vassil Vassilev](https://github.com/vgvassilev), [Lang Hames](https://github.com/lhames)\n\n[Stefan Gränitz](https://github.com/weliveindetail)\n\n**Discourse:** [URL](https://discourse.llvm.org/t/jitlink-new-backends/68223)\n\n**Description of the project:** While the primary job of a compiler is to produce fast code (good run-time performance), it is also important that optimization doesn’t take too much time (good compile-time performance). The goal of this project is to improve compile-time without hurting optimization quality.  \nThe general approach to this project is:\n\n1.  Pick a workload to optimize. For example, this could be a file from [CTMark](https://github.com/llvm/llvm-test-suite/tree/main/CTMark) compiled in a certain build configuration (e.g. `-O0 -g` or `-O3 -flto=thin`).\n2.  Collect profiling information. This could involve compiler options like `-ftime-report` or `-ftime-trace` for a high-level overview, as well as `perf record` or `valgrind --tool=callgrind` for a detailed profile.\n3.  Identify places that are unexpectedly slow. This is heavily workload dependent.\n4.  Try to optimize an identified hotspot, ideally without impacting generated code. The [compile-time tracker](https://llvm-compile-time-tracker.com/) can be used to quickly evaluate impact on CTMark.\n\nAs a disclaimer, it should be noted that outside of pathological cases, compilation doesn’t tend to have a convenient hotspot where 90% of the time is spent, instead it is spread out across many passes. As such, individual improvements also tend to have only small impact on overall compile-time. Expect to do 10 improvements of 0.2% each, rather than one improvement of 2%.\n\n**Expected result:** Substantial improvements on some individual files (multiple percent), and a small improvement on overall geomean compile-time.\n\n**Desirable skills:** Intermediate C++. Familiarity with profiling tools (especially if you are not on Linux, in which case I won’t be able to help).\n\n**Project size:** Either medium or large.\n\n**Difficulty:** Medium\n\n**Confirmed Mentor:** [Nikita Popov](https://github.com/nikic)\n\n**Discourse:** [URL](https://discourse.llvm.org/t/llvm-improving-compile-times/68094)\n\n**Description of the project:** The [Rust programming language](https://www.rust-lang.org/) uses LLVM for code generation, and heavily relies on LLVM’s optimization capabilities. However, there are many cases where LLVM fails to optimize typical code patterns that are emitted by rustc. Such issues are reported using the [I-slow](https://github.com/rust-lang/rust/issues?q=is%3Aopen+is%3Aissue+label%3AI-slow) and/or [A-LLVM](https://github.com/rust-lang/rust/issues?q=is%3Aopen+is%3Aissue+label%3AA-LLVM) labels.  \nThe usual approach to fixing these issues is:\n\n1.  Inspect the `--emit=llvm-ir` output on [Godbolt](https://rust.godbolt.org/).\n2.  Create an LLVM IR test case that is not optimized when run through `opt -O3`.\n3.  Identify a minimal missing transform and prove its correctness using [alive2](https://alive2.llvm.org/ce/).\n4.  Identify which LLVM pass or passes could perform the transform.\n5.  Add necessary test coverage and implement the transform.\n6.  (Much later: Check that the issue is really resolved after the next major LLVM version upgrade in Rust.)\n\nThe goal of this project is to address some of the less hard optimization failures. This means that in some cases, the process would stop after step 3 or 4 without proceeding to implementation, because it’s unclear how the issue could be addressed, or it would take a large amount of effort. Having an analysis of the problem is still valuable in that case.\n\n**Expected result:** Fixes for a number of easy to medium Rust optimization failures. Preliminary analysis for some failures even if no fix was implemented.\n\n**Desirable skills:** Intermediate C++ for implementation. Some familiarity with LLVM (at least ability to understand LLVM IR) for analysis. Basic Rust knowledge (enough to read, but not write Rust).\n\n**Project size:** Either medium or large.\n\n**Difficulty:** Medium\n\n**Confirmed Mentor:** [Nikita Popov](https://github.com/nikic)\n\n**Discourse:** [URL](https://discourse.llvm.org/t/llvm-addressing-rust-optimization-failures-in-llvm/68096)\n\n**Description of the project:** The Clang compiler is part of the LLVM compiler infrastructure and supports various languages such as C, C++, ObjC and ObjC++. The design of LLVM and Clang enables them to be used as libraries, and has led to the creation of an entire compiler-assisted ecosystem of tools. The relatively friendly codebase of Clang and advancements in the JIT infrastructure in LLVM further enable research into different methods for processing C++ by blurring the boundary between compile time and runtime. Challenges include incremental compilation and fitting compile/link time optimizations into a more dynamic environment.\n\nIncremental compilation pipelines process code chunk-by-chunk by building an ever-growing translation unit. Code is then lowered into the LLVM IR and subsequently run by the LLVM JIT. Such a pipeline allows creation of efficient interpreters. The interpreter enables interactive exploration and makes the C++ language more user friendly. The incremental compilation mode is used by the interactive C++ interpreter, Cling, initially developed to enable interactive high-energy physics analysis in a C++ environment.\n\n[Our group](https://compiler-research.org/) puts efforts to incorporate and possibly redesign parts of Cling in Clang mainline through a new tool, clang-repl. The project aims at the design and implementation of robust autocompletion when users type C++ at the prompt of clang-repl. For example:\n\n      \\[clang-repl\\] class MyLongClassName {};\n      \\[clang-repl\\] My<tab\\>\n      // list of suggestions.\n    \n\n**Expected result:** There are several foreseen tasks:\n\n*   Research the current approaches for autocompletion in clang such as clang -code-completion-at=file:col1:col2.\n*   Implement a version of the autocompletion support using the partial translation unit infrastructure in clang’s libInterpreter.\n*   Investigate the requirements for semantic autocompletion which takes into account the exact grammar position and semantics of the code. Eg:\n    \n              \\[clang-repl\\] struct S {S\\* operator+(S&) { return nullptr;}};\n              \\[clang-repl\\] S a, b;\n              \\[clang-repl\\] v = a + <tab\\> // shows b as the only acceptable choice here.\n            \n    \n*   Present the work at the relevant meetings and conferences.\n**Project size:**Large.\n\n**Difficulty:** Medium\n\n**Confirmed Mentor:** [Vassil Vassilev](https://github.com/vgvassilev)\n\n**Discourse:** [URL](https://discourse.llvm.org/t/clang-repl-implement-autocompletion-in-clang-repl/60364)\n\n**Description of the project:** Clang currently handles modules independently in each `clang` instance using the filesystem for synchronization of which instance builds a given module. This has many issues with soundness and performance due to tradeoffs made for module reuse and filesystem contention.\n\nClang has another way of building modules, explicitly built modules, that currently requires build system changes to adopt. Here the build system determines which modules are needed, for example by using [clang-scan-deps](https://github.com/llvm/llvm-project/tree/main/clang/tools/clang-scan-deps), and ensures those modules are built before running the `clang` compile task that needs them.\n\nIn order to allow adoption of this new way of building modules without major build system work we need a module build daemon. With a small change to the command line, clang will connect to this daemon and ask for the modules it needs. The module build daemon then either returns an existing valid module, or builds and then returns it.\n\nThere is an existing open source dependency scanning daemon that is in a llvm-project fork. This only handles file dependencies, but has an IPC mechanism. This IPC system could be used as a base for the modules build daemon, but does need to be extended to work on Windows.\n\n**Expected result:** A normal project using Clang modules with an existing build system (like Make or CMake) can be built using only explicitly built modules via a modules build daemon.\n\n**Desirable skills:** Intermediate C++ programming skills; familiarity with compilers; familiarity with Clang is an asset, but not required.\n\n**Project size:** 175h or 350h depending on reuse of IPC\n\n**Difficulty:** medium\n\n**Confirmed Mentors:** [Michael Spencer](https://github.com/Bigcheese), [Jan Svoboda](https://github.com/jansvoboda11)\n\n**Discourse:** [URL](https://discourse.llvm.org/t/clang-modules-build-daemon-build-system-agnostic-support-for-explicitly-built-modules/68224)\n\n**Description of the project:** [Swift-DocC](https://github.com/apple/swift-docc) is the canonical documentation compiler for the Swift OSS project. However Swift-DocC is not Swift specific and uses [SymbolKit](https://github.com/apple/swift-docc-symbolkit/blob/main/openapi.yaml)'s languaguage agnostic JSON-based symbol graph format to understand which symbols are available in the code, this way any language can be supported by Swift-DocC as long as there is a symbol graph generator.\n\nClang supports symbol graph generation for C and Objective-C as described in [\\[RFC\\] clang support for API information generation in JSON](https://discourse.llvm.org/t/rfc-clang-support-for-api-information-generation-in-json/58845). Today, support for Objective-C categories is not complete, on one hand if the category extends a type in the current module, the category members are assumed to belong to the extended type itself. On the other hand, if the extended type belongs to another module the category is ignored. Nonetheless, it is common to extend types belonging to other modules in Objective-C as part of the public API of the module. The goal of this project is to extend the symbol graph format to accommodate Objective-C categories and to implement support for generating this information both through clang and through libclang.\n\n**Expected result:** Adding the necessary support to clang's symbol graph generator and in libclang for describing categories of symbols defined in other modules. This might involve additions to SymbolKit that would need to be discussed with that community.\n\n**Desirable skills:** Intermediate C++ programming skills; familiarity with clang and Objective-C are assets but not required.\n\n**Project size:** Medium\n\n**Difficulty:** Medium\n\n**Confirmed Mentors:** [Daniel Grumberg](https://github.com/daniel-grumberg), [Zixu Wang](https://github.com/zixu-w), [Juergen Ributzka](https://github.com/ributzka)\n\n**Discourse:** [URL](https://discourse.llvm.org/t/clang-extractapi-objective-c-categories/68370)\n\n**Description of the project:** [Swift-DocC](https://github.com/apple/swift-docc) is the canonical documentation compiler for the Swift OSS project. However Swift-DocC is not Swift specific and uses [SymbolKit](https://github.com/apple/swift-docc-symbolkit/blob/main/openapi.yaml)'s languaguage agnostic JSON-based symbol graph format to understand which symbols are available in the code, this way any language can be supported by Swift-DocC as long as there is a symbol graph generator.\n\nClang supports symbol graph generation for C and Objective-C as described in [\\[RFC\\] clang support for API information generation in JSON](https://discourse.llvm.org/t/rfc-clang-support-for-api-information-generation-in-json/58845).\n\nCurrently the emitted symbol graph format does not support various C++ constructs such as templates and exceptions and the symbol graph generator does not fully understand C++. This project aims to introduce support for various C++ constructs in the symbol graph format and to implement support for generating this data in clang.\n\n**Expected result:** Adding the necessary support to clang's symbol graph generator and in libclang for describing categories of symbols defined in other modules. This will involve additions to SymbolKit that would need to be discussed with that community.\n\n**Desirable skills:** Intermediate C++ programming skills; familiarity with clang and Objective-C are assets but not required.\n\n**Project size:** Large\n\n**Difficulty:** Medium/Hard\n\n**Confirmed Mentors:** [Daniel Grumberg](https://github.com/daniel-grumberg), [Zixu Wang](https://github.com/zixu-w), [Juergen Ributzka](https://github.com/ributzka)\n\n**Discourse:** [URL](https://discourse.llvm.org/t/extractapi-c-support/68371)\n\n**Description of the project:** [Swift-DocC](https://github.com/apple/swift-docc) is the canonical documentation compiler for the Swift OSS project. However Swift-DocC is not Swift specific and uses [SymbolKit](https://github.com/apple/swift-docc-symbolkit/blob/main/openapi.yaml)'s languaguage agnostic JSON-based symbol graph format to understand which symbols are available in the code, this way any language can be supported by Swift-DocC as long as there is a symbol graph generator.\n\nClang supports symbol graph generation for C and Objective-C as described in [\\[RFC\\] clang support for API information generation in JSON](https://discourse.llvm.org/t/rfc-clang-support-for-api-information-generation-in-json/58845).\n\nCurrently users can use clang to generate symbol graph files using the `clang -extract-api` command line interface or generating symbol graphs for a specific symbol using the libclang interface. This project would entail adding a third mode that would generate the symbol graph output as a side-effect of a regular compilation job. This can enable using the symbol graph format as a light weight alternative to clang Index or clangd for code intelligence services.\n\n**Expected result:** Enable generating symbol graph files during a regular compilation (or module build); provide a tool to merge symbol graph files in the same way a static linker links individual object files; Extend clang Index to support all the information contained by symbol graph files.\n\n**Desirable skills:** Intermediate C++ programming skills; familiarity with clang and Objective-C are assets but not required.\n\n**Project size:** Medium\n\n**Difficulty:** Medium/Hard\n\n**Confirmed Mentors:** [Daniel Grumberg](https://github.com/daniel-grumberg), [Zixu Wang](https://github.com/zixu-w), [Juergen Ributzka](https://github.com/ributzka)\n\n**Discourse:** [URL](https://discourse.llvm.org/t/clang-extractapi-while-building/68372)\n\n**Description:** The diagnostics clang emits are ultimately its interface to the developer. While the diagnostics are generally good, there are some rough edges that need to be ironed out. Some cases can be improved by special-casing them in the compiler as well.\n\nAs one can see from Clang’s issue tracker, there are [lots of issues](https://github.com/llvm/llvm-project/issues?page=2&q=is%3Aopen+is%3Aissue+label%3Aclang%3Adiagnostics) open against clang’s diagnostics.\n\nThis project does not aim to implement one big feature but instead focuses on smaller, incremental improvements to Clang’s diagnostics.\n\nPossible example issues to resolve:\n\n*   [Calling nullptr function pointer in a constexpr function results in poor diagnostic](https://github.com/llvm/llvm-project/issues/59872)\n*   [Print name of uninitialized subobject (instead of type)](https://github.com/llvm/llvm-project/issues/58601)\n*   [https://github.com/llvm/llvm-project/issues/57906](https://github.com/llvm/llvm-project/issues/57906)\n*   [clang(++) unhelpful frame-larger-than warning, very small stack frame exceeding very large limit](https://github.com/llvm/llvm-project/issues/57337)\n*   Any other diagnostics issue you find interesting or ran into personally.\n\n**Expected outcomes**: At least three fixed smaller diagnostics issues, or one larger implemented diagnostics improvement.\n\n**Confirmed Mentor:**[Timm Bäder](https://github.com/tbaederr)\n\n**Desirable skills:**\n\n*   Intermediate C++ knowledge.\n*   Preferably experience in the Clang code base, since the issues mentioned can have their root cause in various parts of it.\n*   Preferably an already working local LLVM build\n\n**Project type:** Medium/200 hr\n\n**Discourse** [URL](https://discourse.llvm.org/t/improve-clang-diagnostics-2/68900/3)\n\n**Description:** The Clang compiler is part of the LLVM compiler infrastructure and supports various languages such as C, C++, ObjC and ObjC++. The design of LLVM and Clang enables them to be used as libraries, and has led to the creation of an entire compiler-assisted ecosystem of tools. The relatively friendly codebase of Clang and advancements in the JIT infrastructure in LLVM further enable research into different methods for processing C++ by blurring the boundary between compile time and runtime. Challenges include incremental compilation and fitting compile/link time optimizations into a more dynamic environment.\n\nIncremental compilation pipelines process code chunk-by-chunk by building an ever-growing translation unit. Code is then lowered into the LLVM IR and subsequently run by the LLVM JIT. Such a pipeline allows creation of efficient interpreters. The interpreter enables interactive exploration and makes the C++ language more user friendly. The incremental compilation mode is used by the interactive C++ interpreter, Cling, initially developed to enable interactive high-energy physics analysis in a C++ environment.\n\nWe invest efforts to incorporate and possibly redesign parts of Cling in Clang mainline through a new tool, clang-repl. The project aims implementing tutorials demonstrating the capabilities of the project and investigating adoption of clang-repl in xeus-clang-repl prototype allowing to write C++ in Jupyter.\n\n**Expected result:** There are several foreseen tasks:\n\n*   Write several tutorials demostrating the current capabilities of clang-repl.\n*   Investigate the requirements for adding clang-repl as a backend to xeus-cling.\n*   Improve the xeus kernel protocol for clang-repl.\n*   Prepare a blog post about clang-repl and possibly Jupyter. Present the work at the relevant meetings and conferences.\n**Confirmed Mentor:** [Vassil Vassilev](https://github.com/vgvassilev) [David Lange](https://github.com/davidlange6)\n\n**Desirable skills:** Intermediate C++; Understanding of Clang and the Clang API in particular\n\n**Project type:** Medium\n\n**Discourse** [URL](https://discourse.llvm.org/t/clang-repl-tutorial-development-with-clang-repl/60365)\n\n**Description:** The Clang compiler is part of the LLVM compiler infrastructure and supports various languages such as C, C++, ObjC and ObjC++. The design of LLVM and Clang enables them to be used as libraries, and has led to the creation of an entire compiler-assisted ecosystem of tools. The relatively friendly codebase of Clang and advancements in the JIT infrastructure in LLVM further enable research into different methods for processing C++ by blurring the boundary between compile time and runtime. Challenges include incremental compilation and fitting compile/link time optimizations into a more dynamic environment.\n\nIncremental compilation pipelines process code chunk-by-chunk by building an ever-growing translation unit. Code is then lowered into the LLVM IR and subsequently run by the LLVM JIT. Such a pipeline allows creation of efficient interpreters. The interpreter enables interactive exploration and makes the C++ language more user friendly. The incremental compilation mode is used by the interactive C++ in Jupyter via the xeus kernel protocol. Newer versions of the protocol allow possible in-browser execution allowing further possibilities for clang-repl and Jupyter.\n\nWe invest efforts to incorporate and possibly redesign parts of Cling in Clang mainline through a new tool, clang-repl. The project aims to add WebAssembly support in clang-repl and adopt it in xeus-clang-repl to aid Jupyter-based C++.\n\n**Expected result:** There are several foreseen tasks:\n\n*   Investigate feasibility of generating WebAssembly in a similar way to the new [interactive CUDA support](https://reviews.llvm.org/D146389).\n*   Enable generating WebAssembly in clang-repl.\n*   Adopt the feature in xeus-clang-repl.\n*   Prepare a blog post about clang-repl and possibly Jupyter. Present the work at the relevant meetings and conferences.\n**Confirmed Mentor:** [Vassil Vassilev](https://github.com/vgvassilev) [Alexander Penev](https://github.com/alexander-penev)\n\n**Desirable skills:** Good C++; Understanding of Clang and the Clang API and the LLVM JIT in particular\n\n**Project type:** Large\n\n**Discourse** [URL](https://discourse.llvm.org/t/clang-repl-add-webassembly-support-in-clang-repl/69419)\n\n**Description of the project** GNU toolchain is used widely for building embedded targets. There's a certain momentum in the Clang/LLVM community towards improving the Clang toolchain to support embedded targets. Using the Clang toolchain as an alternative can help us improve code quality, find and fix security bugs, improve developer experience and take advantage of the new ideas and the momentum surrounding the Clang/LLVM community in supporting embedded devices.\n\n**A non-comprehensive list of improvements that can be made to LLD**:\n\n*   **\\--print-memory-usage support**\n    \n    \"--print-memory-usage\" in GCC provides a breakdown of the memory used in each memory region defined in the linker file. Embedded developers use this flag to understand the impact on memory. Often embedded systems define multiple memory regions with different space constraints. Supporting this in Clang toolchain will help projects that wish to use Clang toolchain for their projects.\n    \n*   **Linkmap**\n    \n    Currently, the LLD linker's linkmap output is not as rich as the BFD linker output. Achieving feature parity on linkmap output will be highly useful in analyzing the binaries created by the LLD linker. Further, outputting linkmap in different formats (current LLD output, BFD, and JSON) can help build automation tools for investigating the artifacts produced by the linker.\n    \n*   **\\--print-gc-sections improvement**\n    \n    When the \"--print-gc-sections\" flag is enabled, LLD prints the sections that were discarded during the linking process. This information currently does not include the mapping between the symbol and the section groups, which is useful for debugging. Preserving this information during the linking process will require modifications to internal linker data structures.\n    \n\n**Project size:** Medium or Large\n\n**Difficulty:** Medium/Hard\n\n**Skills:** C++\n\n**Expected result**:\n\n*   Implementation of \"--print-memory-usage\" flag.\n*   Support for new linkmap output formats 1. BFD and 2. JSON.\n*   Improved \"--print-gc-sections\" output to include information about the surviving symbols.\n\n**Confirmed Mentors:** [Prabhu Rajasekaran](https://github.com/Prabhuk) [Petr Hosek](https://github.com/petrhosek)\n\n**Discourse:** [URL](https://discourse.llvm.org/t/lld-linker-improvements-for-embedded/68129)\n\n**Description**: MLIR’s Presburger Library, FPL ([https://grosser.science/FPL](https://grosser.science/FPL)), provides mathematical abstractions for polyhedral compilation and analysis. The main abstraction that the library provides is a set of integer tuples defined by a system of affine inequality constraints. The library supports standard set operations over such sets. The result will be a set defined by another constraint system, possibly having more constraints. When many set operations are performed in sequence, the constraint system may become very large, negatively impacting performance. There are several potential ways to simplify the constraint system; however, this involves performing additional computations. Thus, spending more time on more aggressive simplifications may make each individual operation slower, but at the same time, insufficient simplifications can make sequences of operations slow due to an explosion in constraint system size. The aim of this project is to find the right balance between the two.\n\n**The goals of this project:**\n\n*   Understand the library's performance in terms of runtime and output size.\n*   Optimize the library by finding the best output size and performance tradeoff.\n\n**Expected outcomes**:\n\n*   Benchmarking the performance and output constraint complexity of the primary operations of the library.\n*   Implementing simplification heuristics.\n*   A better understanding of which simplification heuristics improve overall performance enough to be worth the additional computational cost.\n\n**Desirable skills**: Intermediate C++, Experience in benchmarking\n\n**Project size**: Large\n\n**Difficulty**: Medium\n\n**Confirmed mentors**: [Kunwar Grover](https://github.com/Groverkss)\n\n**Discourse**: [URL](https://discourse.llvm.org/t/mlir-optimizing-mlir-s-presburger-library/68213/1)\n\n**Description**: The project aims to develop an interactive query language for MLIR that enables developers to query the MLIR IR dynamically. The tool will provide a REPL (or command-line) interface to enable users to query various properties of MLIR code, such as \"isConstant\" and \"resultOf\". The proposed tool is intended to be similar to clang-query, which allows developers to match AST expressions in C++ code using a TUI with autocomplete and other features.\n\n**The goals of this project:**\n\n*   Understand the MLIR IR representation and common explorations user do.\n*   Implement a REPL to execute queries over MLIR IR.\n\n**Expected outcomes**:\n\n*   Standalone that can be used to interactively explore IR.\n*   Implement common matchers that are usable by the tool.\n*   (stretch) Enable extracting parts of the IR matched by query into self-contained IR snippets.\n\n**Desirable skills**: Intermediate C++, Experience in writing/debugging peephole optimizations\n\n**Project size**: Either medium or large.\n\n**Difficulty**: Medium\n\n**Confirmed mentors**: [Jacques Pienaar](https://github.com/jpienaar)\n\n**Discourse**: [URL](https://discourse.llvm.org/t/gsoc-proposal-interactive-mlir-query-tool-to-make-exploring-the-ir-easier/69601)\n\n**Description of the project** We are using machine-guided compiler optimizations (\"MLGO\") for register allocation eviction and inlining for size, in real-life deployments. The ML models have been trained with reinforcement learning algorithms. Expanding to more performance areas is currently impeded by the poor prediction quality of our performance estimation models. Improving those is critical to the effectiveness of reinforcement learning training algorithms, and therefore to enabling applying MLGO systematically to more optimizations.\n\n**Project size:** either 175 or 350 hr.\n\n**Difficulty:** Medium\n\n**Skills:** C/C++, some compiler experience, some Python. ML experience is a bonus.\n\n**Expected outcomes**: Better modeling of the execution environment by including additional runtime/profiling information, such as additional PMU data, LLC miss probabilities or branch mispredictions. This involves (1) building a data collection pipeline that covers additional runtime information, (2) modifying the ML models to allow processing this data, and (3) modifying the training and inference process for the models to make use this data.\n\nToday, the models are almost pure static analysis; they see the instructions, but they make one-size-fits-all assumptions about the execution environment and the runtime behavior of the code. The goal of this project is to move from static analysis towards more dynamic models that better represent code the way it actually executes.\n\n**Mentors** Ondrej Sykora, Mircea Trofin, Aiden Grossman\n\n**Discourse** [URL](https://discourse.llvm.org/t/better-performance-models-for-mlgo-training/68219)\n\n**Description of the project:** The Clang static analyzer comes with an experimental implementation of taint analysis, a security-oriented analysis technique built to warn the user about flow of attacker-controlled (\"tainted\") data into sensitive functions that may behave in unexpected and dangerous ways if the attacker is able to forge the right input. The programmer can address such warnings by properly \"sanitizing\" the tainted data in order to eliminate these dangerous inputs. A common example of a problem that can be caught this way is [SQL injections](https://xkcd.com/327/). A much simpler example, which is arguably much more relevant to users of Clang, is buffer overflow vulnerabilities caused by attacker-controlled numbers used as loop bounds while iterating over stack or heap arrays, or passed as arguments to low-level buffer manipulating functions such as memcpy().\n\nBeing a static symbolic execution engine, the static analyzer implements taint analysis by simply maintaining a list of \"symbols\" (named unknown numeric values) that were obtained from known taint sources during the symbolic simulation. Such symbols are then treated as potentially taking arbitrary concrete values, as opposed to the general case of taking an unknown subset of possible values. For example, division by a unchecked unknown value doesn't necessarily warrant a division by zero warning, because it's typically not known whether the value can be zero or not. However, division by an unchecked _tainted_ value does immediately warrant a division by zero warning, because the attacker is free to pass zero as an input. Therefore the static analyzer's taint infrastructure consists of several parts: there is a mechanism for keeping track of tainted symbols in the symbolic program state, there is a way to define new sources of taint, and a few path-sensitive checks were taught to consume taint information to emit additional warnings (like the division by zero checker), acting as taint \"sinks\" and defining checker-specific \"sanitization\" conditions.\n\nThe entire facility is flagged as experimental: it's basically a proof-of-concept implementation. It's likely that it can be made to work really well, but it needs to go through some quality control by running it on real-world source code, and a number of bugs need to be addressed, especially in individual checks, before we can declare it stable. Additionally, the tastiest check of them all – buffer overflow detection based on tainted loop bounds or size parameters – was never implemented. There is also a related check for array access with tainted index – which is, again, experimental; let's see if we can declare this one stable as well!\n\n**Expected result:** A number of taint-related checks either enabled by default for all users of the static analyzer, or available as opt-in for users who care about security. They're confirmed to have low false positive rate on real-world code. Hopefully, the buffer overflow check is one of them.\n\n**Desirable skills:** Intermediate C++ to be able to understand LLVM code. We'll run our analysis on some plain C code as well. Some background in compilers or security is welcome but not strictly necessary.\n\n**Project size:** Either medium or large.\n\n**Difficulty:** Medium\n\n**Confirmed Mentors:** [Artem Dergachev](https://github.com/haoNoQ), [Gábor Horváth](https://github.com/xazax-hun), [Ziqing Luo](https://github.com/ziqingluo-90)\n\n**Discourse:** [URL](https://discourse.llvm.org/t/clang-improve-and-stabilize-the-static-analyzers-taint-analysis-checks/68235)\n\n**Description of the project** This continues the work of GSoC 2020 and [2021](https://summerofcode.withgoogle.com/archive/2021/projects/6411038932598784). Developers generally use standard optimization pipelines like -O2 and -O3 to optimize their code. Manually crafted heuristics are used to determine which optimization passes to select and how to order the execution of those passes. However, this process is not tailored for a particular program, or kind of program, as it is designed to perform “reasonably well” for any input. We want to improve the existing heuristics or replace the heuristics with machine learning-based models so that the LLVM compiler can provide a superior order of the passes customized per program. The last milestone enabled feature extraction, and started investigating training a policy for selecting a more appropriate pass pipeline.\n\n**Project size:** either 175 or 350 hr.\n\n**Difficulty:** Medium\n\n**Skills:** C/C++, some compiler experience. ML experience is a bonus.\n\n**Expected outcomes**: Pre-trained model selecting the most economical optimization pipeline, with no loss in performance; hook-up of model in LLVM; (re-)training tool; come up with new optimization sequences through search or learning.\n\n**Mentors** Tarindu Jayatilaka, Mircea Trofin, Johannes Doerfert\n\n**Discourse** [URL](https://discourse.llvm.org/t/machine-learning-guided-ordering-of-compiler-optimization-passes/60415)\n\n**Description of the project:**  \nClang supports source-based coverage that shows which lines of code are covered by the executed tests [\\[1\\]](https://clang.llvm.org/docs/SourceBasedCodeCoverage.html). It uses llvm-profdata [\\[2\\]](https://llvm.org/docs/CommandGuide/llvm-profdata.html) and llvm-cov [\\[3\\]](https://llvm.org/docs/CommandGuide/llvm-cov.html) tools to generate coverage reports. llvm-cov currently generates a single top-level index HTML file. For example, a single top-level directory code coverage report [\\[4\\]](https://lab.llvm.org/coverage/coverage-reports/index.html) for LLVM repo is published on a coverage bot. Top-level indexing causes rendering scalability issues in large projects, such as Fuchsia [\\[5\\]](https://fuchsia.dev/). The goal of this project is to generate a hierarchical directory structure in generated coverage html reports to match the directory structure and solve scalability issues. Chromium uses its own post-processing tools to show a per-directory hierarchical structure for coverage results [\\[6\\]](https://analysis.chromium.org/coverage/p/chromium). Similarly, Lcov, which is a graphical front-end Gcov[\\[7\\]](https://gcc.gnu.org/onlinedocs/gcc/Gcov.html), provides a one-level directory structure to display coverage results [\\[8\\]](https://llvm.org/reports/coverage/index.html).  \n\\[1\\] [Source-based code coverage](https://clang.llvm.org/docs/SourceBasedCodeCoverage.html)  \n\\[2\\] [llvm-profdata](https://llvm.org/docs/CommandGuide/llvm-profdata.html)  \n\\[3\\] [llvm-cov](https://llvm.org/docs/CommandGuide/llvm-cov.html)  \n\\[4\\] [LLVM coverage reports](https://lab.llvm.org/coverage/coverage-reports/index.html)  \n\\[5\\] [Fuchsia](https://fuchsia.dev/)  \n\\[6\\] [Coverage summary for Chromium](https://analysis.chromium.org/coverage/p/chromium)  \n\\[7\\] [Gcov](https://gcc.gnu.org/onlinedocs/gcc/Gcov.html)  \n\\[8\\] [Lcov coverage reports](https://llvm.org/reports/coverage/index.html)  \n\\[9\\] [Issue #54711: Support per-directory index files for HTML coverage report](https://github.com/llvm/llvm-project/issues/54711)\n\n**Expected result:** Implement a support in hierarchical directory structure in generated coverage html reports and show the usage of this feature in LLVM repo code coverage reports.\n\n**Project size:** Medium or Large\n\n**Difficulty:** Medium\n\n**Confirmed Mentors:** [Gulfem Savrun Yeniceri](https://github.com/gulfemsavrun) [Petr Hosek](https://github.com/petrhosek)\n\n**Discourse:** [URL](https://discourse.llvm.org/t/coverage-support-a-hierarchical-directory-structure-in-generated-coverage-html-reports/68239)\n\n**Description of the project** Developers often use compiler generated remarks and analysis reports to optimize their code. While compilers in general are good at including source code positions (i.e line and column numbers) in the generated messages, it is useful if these generated messages also include the corresponding source-level expressions. The approach used by the LLVM implementation is to use a small set of intrinsic functions to define a mapping between LLVM program objects and the source-level expressions. The goal of this project is to use the information included within these intrinsic functions to either generate the source expression corresponding to LLVM values or to propose and implement solutions to get the same if the existing information is insufficient. Optimizing memory accesses in a program is important for application performance. We specifically intend to use compiler analysis messages that report source-level memory accesses corresponding to the LLVM load/store instructions that inhibit compiler optimizations. As an example, we can use this information to report memory access dependences that inhibit vectorization.\n\n**Project size:** Medium\n\n**Difficulty:** Medium\n\n**Skills:** Intermediate C++, familiarity with LLVM core or willingness to learn the same.\n\n**Expected result:** Provide an interface which takes an LLVM value and returns a string corresponding to the equivalent source-level expression. We are especially interested in using this interface to map addresses used in load/store instructions to equivalent source-level memory references.\n\n**Confirmed Mentors:** Satish Guggilla (satish.guggilla@intel.com) Karthik Senthil (karthik.senthil@intel.com)\n\n**Discourse:** [URL](https://discourse.llvm.org/t/map-llvm-values-to-corresponding-source-level-expressions/68450)\n\n**Description of the project:**  \nClang codegen works by emitting LLVM IR using AST visitors. In the [ClangIR](https://llvm.github.io/clangir/) project, we emit ClangIR (CIR) from AST visitors too (CIRGen), and then lower to (a) LLVM IR directly or, alternatively, (b) MLIR in-tree dialects. Lowering to LLVM is still quite immature and lacks many instructions, attributes and metadata support. ClangIR would greatly benefit from some level of parity with Clang AST → LLVM IR codegen quality, in both performance and build time. This is key for incrementally bridging correctness and performance testing, providing a baseline for future higher level optimizations on top of C/C++. A good starting point is to build and run simple benchmarks, measuring both generated code and build time performance. LLVM's llvm-test-suite contains scripts and machinery that easily allows checking correctness and collecting perf related data and its [SingleSource](https://github.com/llvm/llvm-test-suite/tree/main/SingleSource) collection provide a set of simpler programs to build. In a nutshell, while working on this project the student will brigde the gap of CIR → LLVM lowering, and at times fix any lacking Clang AST → CIR support. The work is going to be done incrementally on top of SingleSource benchmarks, while measuring compiler build time and the performance of compiled programs.\n\n**Skills:** Intermediate C++ programming skills; familiarity with compilers, LLVM IR, MLIR or Clang are a big plus, but willingness to learn is also a possibility.\n\n**Expected result:**Build and run programs from the SingleSource subdirectory from the lvm-test-suite, collect and present results (perf and build time) against regular (upstream) clang codegen.\n\n**Project size:** Large\n\n**Difficulty:** Medium\n\n**Confirmed Mentors:** [Bruno Cardoso Lopes](https://github.com/bcardosolopes) [Nathan Lanza](https://github.com/lanza)\n\n**Discourse:** [URL](https://discourse.llvm.org/t/clangir-build-and-run-singlesource-benchmarks-using-clangir/68473)\n\n**Description of the project:** Enzyme performs automatic differentiation (in the calculus sense) of LLVM programs. This enables users to use Enzyme to perform various algorithms such as back-propagation in ML or scientific simulation on existing code for any language that lowers to LLVM. The support for an increasing number of LLVM Versions (7-main), AD modes (Reverse, Forward, Forward-Vector, Reverse-Vector, Jacobian), and libraries (BLAS, OpenMP, MPI, CUDA, ROCm, ...) leads to a steadily increasing code base. In order to limit complexity and help new contributors we would like to express more parts of our core logic using LLVM Tablegen. The applicant is free to decide how to best map the program transformation abstractions within Enzyme to Tablegen.\n\n**Expected results:** 1. Extend the tablegen rule generation system within Enzyme to cover a new component beside of the AdjointGenerator  \n2\\. Moving several existing rules to the new autogenerated system (e.g. LLVM instructions, LLVM intrinsics, MPI calls, ...\n\n**Confirmed mentor:** [Manuel Drehwald](https://github.com/zuseZ4) [William Moses](mailto:wmoses@mit.edu)\n\n**Desirable skills:** Good knowledge of C++, calculus, and LLVM and/or Clang, and/or MLIR internals. Experience with Tablegen, Enzyme or automatic differentiation would be nice, but can also be learned in the project.\n\n**Project size:** Large\n\n**Difficulty:** Medium\n\n**Discourse** [URL](https://discourse.llvm.org/t/enzyme-move-additional-enzyme-rules-to-tablegen/69738)\n\n**Description of the project** Most of the day to day tests in LLVM are regression tests executed by [Lit](https://llvm.org/docs/CommandGuide/lit.html), structured as source code or IR to be passed to some binary, rather than test code directly calling the code to be tested. This has many advantages but can make it difficult to predict which code path is executed when the compiler is invoked with a certain test input, especially for edge cases where error handling is involved. The goal of this project is to help developers create good test coverage for their patch and enable reviewers to verify that they have done so. To accomplish this we would like to introduce a tool that can be fed a patch as input, add coverage instrumentation for the affected source files, runs Lit tests, and records which test cases cause each counter to be executed. For each counter we can then report the number of test cases executing the counter, but perhaps more importantly we can also report the number of test cases executing the counter that are also changed in some way by the patch, since a modified line that results in the same test results isn’t properly tested, unless it’s intended to be a non-functional change. This can be implemented in three separate parts:\n\n1.  Adding an option to llvm-lit to emit the necessary test coverage data, divided per test case (involves setting a unique value to [`LLVM_PROFILE_FILE`](https://clang.llvm.org/docs/SourceBasedCodeCoverage.html#running-the-instrumented-program) for each RUN)\n2.  New tool to process the generated coverage data and the relevant git patch, and present the results in a user friendly manner\n3.  Adding a way to non-intrusively (without changing build configurations) enable coverage instrumentation to a build. By building the project normally, touching the files changed by the patch, and rebuilding with [`CCC_OVERRIDE_OPTIONS`](https://github.com/llvm/llvm-project/blob/93a1fc2e18b452216be70f534da42f7702adbe1d/clang/tools/driver/driver.cpp#L79-L105) set to [add coverage](https://clang.llvm.org/docs/SourceBasedCodeCoverage.html#compiling-with-coverage-enabled) we can lower the overhead of generating and processing coverage of lines not relevant to the patch.\n\nThe tooling in step 2 and 3 can be made completely agnostic of the actual test-runner, lowering the threshold for other test harnesses than Lit to implement the same functionality. If time permits adding this as a step in CI would also be helpful for reviewers.\n\n**Project size:** Small or medium\n\n**Difficulty:** Simple\n\n**Skills:** Python for Lit, data processing and [diff](https://www.gnu.org/software/diffutils/manual/html_node/Unified-Format.html) processing. No compiler experience necessary.\n\n**Expected result:** Implement a new tool for use by the community. Developers get help finding uncovered edge cases during development, while also avoiding paranoid sprinkling of asserts or logs just to check that the code is actually executed. Reviewers can more easily check which parts of the patch are tested by each test.\n\n**Confirmed Mentors:** [Henrik Olsson](https://github.com/hnrklssn)\n\n**Discourse:** [URL](https://discourse.llvm.org/t/coverage-patch-based-test-coverage-for-quick-test-feedback/68628)\n\nGoogle Summer of Code 2022 was very successful for LLVM project. For the list of accepted and completed projects, please take a look into Google Summer of Code [website](https://summerofcode.withgoogle.com/archive/2022/organizations/llvm-compiler-infrastructure).\n\n**Description of the project:** Write a shared-memory based JITLinkMemoryManager.  \nLLVM’s JIT uses the JITLinkMemoryManager interface to allocate both working memory (where the JIT fixes up the relocatable objects produced by the compiler) and target memory (where the JIT’d code will reside in the target). JITLinkMemoryManager instances are also responsible for transporting fixed-up code from working memory to target memory. LLVM has an existing cross-process allocator that uses remote procedure calls (RPC) to allocate and copy bytes to the target process, however a more attractive solution (when the JIT and target process share the same physical memory) would be to use shared memory pages to avoid copies between processes.\n\n**Expected results:**\n\nImplement a shared-memory based JITLinkMemoryManager:*   Write generic LLVM APIs for shared memory allocation.\n*   Write a JITLinkMemoryManager that uses these generic APIs to allocate shared working-and-target memory.\n*   Make an extensive performance study of the approach.\n\n**Confirmed Mentor:** [Vassil Vassilev](https://github.com/vgvassilev), [Lang Hames](https://github.com/lhames)\n\n**Desirable skills:** Intermediate C++; Understanding of LLVM and the LLVM JIT in particular; Understanding of virtual memory management APIs.\n\n**Project type:** Large\n\n**Discourse** [URL](https://discourse.llvm.org/t/implement-a-shared-memory-based-jitlinkmemorymanager-for-out-of-process-jitting)\n\n**Description of the project:** The LLVM BuildingAJIT tutorial series teaches readers to build their own JIT class from scratch using LLVM’s ORC APIs, however the tutorial chapters have not kept pace with recent API improvements. Bring the existing tutorial chapters up to speed, write up a new chapter on lazy compilation (chapter code already available) or write a new chapter from scratch.\n\n**Expected results:**\n\n*   Update chapter text for Chapters 1-3 -- Easy, but offers a chance to get up-to-speed on the APIs.\n*   Write chapter text for Chapter 4 -- Chapter code is already available, but no chapter text exists yet.\n*   Write a new chapter from scratch -- E.g. How to write an out-of-process JIT, or how to directly manipulate the JIT'd instruction stream using the ObjectLinkingLayer::Plugin API.\n\n**Confirmed Mentor:** [Vassil Vassilev](https://github.com/vgvassilev), [Lang Hames](https://github.com/lhames)\n\n**Desirable skills:** Intermediate C++; Understanding of LLVM and the LLVM JIT in particular; Familiarity with RST (reStructed Text); Technical writing skills.\n\n**Project type:** Medium\n\n**Discourse** [URL](https://discourse.llvm.org/t/modernize-the-llvm-building-a-jit-tutorial-series)\n\n**Description of the project:** JITLink is LLVM’s new JIT linker API -- the low-level API that transforms compiler output (relocatable object files) into ready-to-execute bytes in memory. To do this JITLink’s generic linker algorithm needs to be specialized to support the target object format (COFF, ELF, MachO), and architecture (arm, arm64, i386, x86-64). LLVM already has mature implementations of JITLink for MachO/arm64 and MachO/x86-64, and a relatively new implementation for ELF/x86-64. Write a JITLink implementation for a missing target that interests you. If you choose to implement support for a new architecture using the ELF or MachO formats then you will be able to re-use the existing generic code for these formats. If you want to implement support for a new target using the COFF format then you will need to write both the generic COFF support code and the architecture support code for your chosen architecture.\n\n**Expected results:** Write a JITLink specialization for a not-yet-supported format/architecture.\n\n**Confirmed Mentor:** [Vassil Vassilev](https://github.com/vgvassilev), [Stefan Gränitz](https://github.com/weliveindetail), [Lang Hames](https://github.com/lhames)\n\n**Desirable skills:** Intermediate C++; Understanding of LLVM and the LLVM JIT in particular; familiarity with your chosen format/architecture, and basic linker concepts (e.g. sections, symbols, and relocations).\n\n**Project type:** Large\n\n**Discourse** [URL](https://discourse.llvm.org/t/write-jitlink-support-for-a-new-format-architecture)\n\n**Description of the project:** Every developer, at some point (usually while waiting for their program to compile), has asked \"Why is it taking so long?\" This project is to seek an answer to this question. There exists within LLVM, and by extension CLANG, a timing infrastructure that records events within the compiler. However, its utilization is inconsistent and insufficient. This can be improved by adding more instrumentation throughout LLVM and CLANG but one must be careful. Too much instrumentation, or instrumenting the wrong things, can be confusing and overwhelming, thus making it no more useful than not enough information. The trick is to find the right places to instrument and controlling the instrumentation. Seeking out these key spots will take you through the entire compilation process, from preprocessing through to final code generation, and all phases between. As you instrument the code, you will look at the data as you evolve it, which will further direct your search. You will develop new ways to control and filter the information to allow a better understanding of where the compiler is spending its time. You will seek out and develop example test inputs that illustrate where the compiler can be improved, which will in turn, help direct your instrumenting and search. You will consider and develop ways of controlling the instrumentation to allow better understanding and detailed examination of phases of compilation. Through all of this, you will gain an understanding of how a compiler works, from front end processing, through the LLVM optimization pipeline, through to code generation. You will see, and understand, the big picture of what is required to compile and optimize a C/C++ program, and in particular, how CLANG, LLVM and LLC accomplish these tasks. Your mentors have a combined experience of approximately 25 years of compiler development and around 8 years of experience with LLVM itself to help you on your quest.\n\n**Expected results:**\n\n*   Targetted expansion of the use of the existing timing infrastructure\n*   Identification of appropriate test inputs for improving compile time\n*   Identification of compile time hotspots\n*   New and improved methods of controlling the timing infrastructure\n\n**Confirmed Mentor:** Jamie Schmeiser, Whitney Tsang\n\n**Desirable skills:** C++ programming skills; CLANG/LLVM knowledge an asset but not necessary; self motivated; curiosity; desire to learn\n\n**Project type:**175 or 350 hour\n\n**Difficulty Rating:**Easy - Medium\n\n**Discourse** [URL](https://discourse.llvm.org/t/instrumentation-of-clang-llvm-for-compile-time)\n\n**Description of the project** This continues the work of GSoC 2020 and [2021](https://summerofcode.withgoogle.com/archive/2021/projects/6411038932598784). Developers generally use standard optimization pipelines like -O2 and -O3 to optimize their code. Manually crafted heuristics are used to determine which optimization passes to select and how to order the execution of those passes. However, this process is not tailored for a particular application, or kind of application, as it is designed to perform “reasonably well” for any input. We want to improve the existing heuristics or replace the heuristics with machine learning-based models so that the LLVM compiler can provide a superior order of the passes customized per application. The last milestone enabled feature extraction, and started investigating training a policy for selecting a more appropriate pass pipeline.\n\n**Project size:** either 175 or 350 hr.\n\n**Difficulty:** Medium\n\n**Skills:** C/C++, some compiler experience. ML experience is a bonus.\n\n**Expected outcomes**: Pre-trained model selecting the most economical optimization pipeline, with no loss in performance; hook-up of model in LLVM; (re-)training tool.\n\n**Mentors** Tarindu Jayatilaka, Mircea Trofin, Johannes Doerfert\n\n**Discourse** [URL](https://discourse.llvm.org/t/machine-learning-guided-ordering-of-compiler-optimization-passes/60415)\n\n**Description of the project** This project is a continuation of last [year’s](https://summerofcode.withgoogle.com/archive/2021/projects/5732097817313280). In 2021, the project achieved its first milestone - separating correctness decisions from policy decisions. This opens up the possibility of replacing the latter with machine-learned ones. Rough milestones: 1) select an initial set of features and use the existing ML Guided Optimizations (MLGO) infra to generate training logs; 2) define a reward signal, computable at compile time, to guide a reinforcement learning training loop; 3) iterate through training and refine reward/feature set\n\n**Project size:** either 175 or 350 hr, ideally 350 hr\n\n**Difficulty:** Medium/Hard\n\n**Skills:** C/C++, some compiler experience. ML experience is a bonus.\n\n**Expected outcomes**: policy ('advisor') interface for loop unrolling, with current heuristic as default implementation; set up feature extraction for reinforcement learning training; set up a reward metric; set up training algorithm, and iterate over policy training\n\n**Mentors** Johannes Doerfert, Mircea Trofin\n\n**Discourse** [URL](https://discourse.llvm.org/t/learning-loop-transformation-policies/60413)\n\n**Description of the project** LLVM's inliner is a bottom-up, strongly-connected component-level pass. This places limits on the order in which call sites are evaluated, which impacts the effectiveness of inlining. We now have a functional Module Inliner, as result of [GSoC2021 work](https://summerofcode.withgoogle.com/archive/2021/projects/5195658885070848). We want to call site priority schemes, effectiveness/frequency of running function passes after successful inlinings, interplay with the ML inline advisor, to name a few areas of exploration.\n\n**Project size:** either 175 or 350 hr, ideally 350 hr, milestones allow for 175hr scoping\n\n**Difficulty:** Medium/Hard\n\n**Skills:** C/C++, some compiler experience.\n\n**Expected outcomes**: Proposal and Evaluation of alternative traversal orders; evaluation of 'clustering' inlining decisions (inline more than one call site at a time); evaluation of effectiveness/frequency of function optimization passes after inlining\n\n**Mentors** Kazu Hirata, Liqiang Tao, Mircea Trofin\n\n**Discourse** [URL](https://discourse.llvm.org/t/evaluate-and-expand-the-module-level-inliner/60525)\n\n**Description of the project:** C and C++ programs are often composed of various object files produced from separately-compiled source files that are then linked together. When compiling one source file, knowledge that can be derived from the logic contained within the other source files would normally not be available. Link-time optimization, also known as LTO, is a way for optimization to be done using information from more than one source file.\n\nIn LLVM, LTO is achieved by using LLVM bitcode objects as the output from the \"compile\" step and feeding those objects into the link step. LLVM's LTO operates in conjunction with the linker. The linker is invoked by the user and the linker in turn drives LLVM's LTO when it encounters LLVM bitcode files, getting information from LTO about what symbols a bitcode object defines or references. Information about what symbols are defined in or referenced from an object is necessary for the linker to perform symbol resolution, and a linker is normally able to extract such information from regular (non-bitcode) object files.\n\nThe implied consequences of LLVM's LTO implementation with respect to linker GC (linker garbage collection) can be improved, especially for aggressive forms of linker GC with lazy inclusion of objects and sections. In particular, the symbols referenced but undefined by an LTO module are, to the linker, monolithic at the module level. At the same time, the symbols referenced but undefined by regular (non-LTO) objects are monolithic to LTO. Together, this means that the inclusion of an LTO module into the overall process potentially leads, in the linker's initial symbol resolution, to all the undefined symbols in that module being considered as referenced; in turn, additional artifacts (e.g., archive members) may be added into the resolution, which further leads to references that may resolve to symbols defined in LTO modules and a premature conclusion that the definition of these symbols are needed. This at least means potentially unnecessary codegen is being done for functions that will be garbage-collected in the end (waste of electricity and time).\n\nWe acknowledge that an ideal implementation probably involves a \"coroutine\" like interaction between the linker and LTO codegen where information flows back and forth; however, such an endeavour is invasive to both linkers and to LLVM.\n\nWe believe that by\n\n*   having the linker register, via an API to LTO, symbol reference \"nodes\" modelling the relationship between a symbol and the symbols that are referenced in turn from (the object file section containing) its linker-selected definition, and\n*   using that information in LTO processing,\n\nthe LTO processing will be able to effectively identify a more accurate set of LTO symbols that are visible outside of the LTO unit. The linker merely needs to identify only exported symbols and entry points (such as the entry point for an executable and functions involved in initialization and finalization).\n\nHaving the LLVM opt/codegen understand the dependency implications from the \"outside world\" is strictly better than the other direction: the symbols referred to by relocations in non-LTO code are pretty much fixed as compiled (whereas some references in LTO code may disappear with optimization).\n\n**Expected results:**\n\n1.  Modification of the C++ LTO interface used by LLD to implement an interface to record the symbol reference dependency data (incorporating awareness of sections and comdats). This may additionally include a method to add LTO objects provisionally, simulating behaviours where linkers only add objects as needed.\n2.  Modification of LTO to use new symbol reference information for definitions in regular objects when visiting definitions in the IR prior to the internalization pass to discover (transitive) symbol references and record the so-referenced symbols as being visible to regular objects. This may additionally include the \"late\" incorporation of LTO objects added provisionally into the merged LTO module.\n3.  Modification of LLD (for ELF) to modify initial resolution to use the new interface as a replacement for setting `VisibleToRegularObj` except for entry point functions (including C++ dynamic initialization and finalization).\n\n**Confirmed Mentors:** Sean Fertile, Hubert Tong, Wael Yehia\n\n**Desirable skills:** Intermediate C++; basic linker concepts (e.g., symbols, sections, and relocations)\n\n**Project size:** 350 hours\n\n**Difficultly:** Medium/Hard\n\n**Discourse** [URL](https://discourse.llvm.org/t/richer-symbol-dependency-information-for-lto/60335)\n\n**Description of the project** The existence of the undef value in LLVM prevents several optimizations, even in programs where it is not used. Therefore, we have been trying to move all uses of undef to poison so we can eventually remove undef from LLVM.  \nThis project focuses on uninitialized memory: right now the semantics of LLVM is that loading a value from uninitilized memory yields an undef value. This prevents, for example, SROA/mem2reg from optimizing conditional loads as phi(undef, %x) cannot be replaced with x, as %x might be poison.  \nThis project consists in devising a consistent semantics for uninitialized (based on existing proposals), an upgrade plan for LLVM, and implementing the changes in LLVM and clang. In clang the changes should be specific to bit-fields.  \nFor more information see the following [discussion](https://github.com/llvm/llvm-project/issues/52930) and/or contact the mentor.  \nFurther reading: [introduction to LLVM's memory model](https://web.ist.utl.pt/nuno.lopes/pubs/llvmmem-oopsla18.pdf).\n\n**Project size:** 350 hr\n\n**Difficulty:** Medium/Hard\n\n**Skills:** Intermediate C++\n\n**Expected outcomes**:\n\n*   Semantics for memory operations that removes the need for undef values\n*   Upgrade plan for LLVM and frontends\n*   Implementation of the proposed semantics in LLVM\n*   Implementation of auto-upgrade path for old LLVM IR files\n*   Implementation of fixes in clang to use the new IR features\n*   Benchmarking to check for regressions and/or perf improvements\n\n**Mentors:** [Nuno Lopes](https://web.ist.utl.pt/nuno.lopes/)\n\n**Description of the project**\n\nCurrently, all libraries inside LLVM export all their symbols publicly. When linking statically against them, the linker will remove unused symbols and this is not a problem.\n\nWhen the libraries are built as shared libraries however, the number of exported symbols is very large and symbols that are meant to be internal spill into the public ABI of the shared libLLVM.so.\n\nIn this project, we’d like to change the default visibility of library symbols to “hidden”, add an annotation macro to LLVM and use the macro to gradually move the entire library in this direction. This will eventually enable building the shared libLLVM.so on Windows as well.\n\nIn practice, this means adding -fvisibility=hidden to individual libraries and annotating exported symbols with the LLVM export annotation.\n\nWe would like this work to be as unintrusive into other developer’s workflow as possible, so starting with a small internal library would be beneficial, e.g. one of the LLVM targets or IR passes.\n\nFor further reading, there is a Discourse thread avaiable that discusses the idea behind this proposal: [Supporting LLVM\\_BUILD\\_LLVM\\_DYLIB on Windows](https://discourse.llvm.org/t/supporting-llvm-build-llvm-dylib-on-windows/58891) as well as the linked Phabricator review with a patch implementing the functionality: [⚙ D109192 \\[WIP/DNM\\] Support: introduce public API annotation support](https://reviews.llvm.org/D109192) None of this work has been committed yet but can be used as a starting point for this proposal.\n\n**Project size:** Medium\n\n**Difficulty:** Easy\n\n**Skills:** Build systems, CMake, LLVM\n\n**Expected outcomes**:\n\n*   Export macro implemented and commited to LLVM\n*   At least one internal target ported to the new export scheme\n\n**Mentors:** Timm Bäder, Tom Stellard\n\n**Description of the project:** When instantiating a template, the template arguments are canonicalized before being substituted into the template pattern. Clang does not preserve type sugar when subsequently accessing members of the instantiation.\n\n    std::vector<std::string\\> vs;\n    int n = vs.front(); // bad diagnostic: \\[...\\] aka 'std::basic\\_string<char\\>' \\[...\\]\n\n    template<typename T\\> struct Id { typedef T type; };\n    Id<size\\_t\\>::type // just 'unsigned long', 'size\\_t' sugar has been lost\n    \n\nClang should \"re-sugar\" the type when performing member access on a class template specialization, based on the type sugar of the accessed specialization. The type of vs.front() should be std::string, not std::basic\\_string<char, \\[...\\]\\>.\n\nSuggested design approach: add a new type node to represent template argument sugar, and implicitly create an instance of this node whenever a member of a class template specialization is accessed. When performing a single-step desugar of this node, lazily create the desugared representation by propagating the sugared template arguments onto inner type nodes (and in particular, replacing Subst\\*Parm nodes with the corresponding sugar). When printing the type for diagnostic purposes, use the annotated type sugar to print the type as originally written.\n\nFor good results, template argument deduction will also need to be able to deduce type sugar (and reconcile cases where the same type is deduced twice with different sugar).\n\n**Expected results:** Diagnostics preserve type sugar even when accessing members of a template specialization. T<unsigned long\\> and T<size\\_t\\> are still the same type and the same template instantiation, but T<unsigned long\\>::type single-step desugars to 'unsigned long' and T<size\\_t\\>::type single-step desugars to 'size\\_t'.\n\n**Confirmed Mentor:** [Vassil Vassilev](https://github.com/vgvassilev), [Richard Smith](https://github.com/zygoloid)\n\n**Desirable skills:** Good knowledge of clang API, clang's AST, intermediate knowledge of C++.\n\n**Project type:** Large\n\n**Discourse** [URL](https://discourse.llvm.org/t/clang-extend-clang-ast-to-provide-information-for-the-type-as-written-in-template-instantiations)\n\n**Description of the project:** Even though a lot of new C++ features are supported by the static analyzer automatically by the virtue of clang AST doing all the work under the hood, the C++17 \"structured binding\" syntax\n\n    auto \\[x, y\\] = ...;\n\nrequires some extra work on the Static Analyzer side. The analyzer's transfer functions need to be taught about the new AST nodes, [BindingDecl](https://clang.llvm.org/doxygen/classclang_1_1BindingDecl.html) and [DecompositionDecl](https://clang.llvm.org/doxygen/classclang_1_1DecompositionDecl.html), to work correctly in all [three interpretations](https://en.cppreference.com/w/cpp/language/structured_binding) described by the Standard.\n\nIncomplete support for structured bindings is a common source of false positives in the uninitialized variable checker on modern C++ code, such as [#42387](https://github.com/llvm/llvm-project/issues/42387).\n\nIt is likely that the Clang CFG also needs to be updated. Such changes in the CFG may improve quality of clang warnings outside of the Static Analyzer.\n\n**Expected results:** The Static Analyzer correctly models structured binding and decomposition declarations. In particular, binding variables no longer appear uninitialized to the Static Analyzer's uninitialized variable checker.\n\n**Confirmed Mentor:** [Artem Dergachev](https://github.com/haoNoQ), [Rashmi Mudduluru](https://github.com/t-rasmud), [Gábor Horváth](https://github.com/xazax-hun), [Kristóf Umann](https://github.com/Szelethus)\n\n**Desirable skills:** Intermediate knowledge of C++. Some familiarity with Clang AST and/or some static analysis background.\n\n**Project size:** 350 hr\n\n**Difficulty:** Medium/Hard\n\n**Discourse** [URL](https://discourse.llvm.org/t/implement-support-for-c-17-structured-bindings-in-the-clang-static-analyzer/60588)\n\n**Description:** Clang Diagnostics, which issues Warnings and Errors to the programmer, are a critical feature of the compiler. Great diagnostics can have a significant impact on the user experience of the compiler and increase their productivity.\n\nRecent improvements in GCC [\\[1\\]](https://developers.redhat.com/blog/2018/03/15/gcc-8-usability-improvements) [\\[2\\]](https://developers.redhat.com/blog/2019/03/08/usability-improvements-in-gcc-9/) shows that there is significant headroom to improve diagnostics (and user interactions in general). It would be a very impactful project to survey and identify all the possible improvements to clang on this topic and start redesigning the next generation of our diagnostics.\n\nIn addition, we will also make conclusions on issues reported on the LLVM Github Issue page labeled with [clang-diagnostics](https://github.com/llvm/llvm-project/labels/clang%3Adiagnostics) and if they need fixing, we will prepare patches otherwise simply close them.\n\n**Expected outcomes**: Diagnostics will be improved:\n\n*   Improve diagnostic aesthetics\n*   Cover missing diagnostics\n*   Reduce false positive rate\n*   Reword diagnostics\n\n**Confirmed Mentor:** [Aaron Ballman](https://github.com/AaronBallman), [Erich Keane](https://github.com/erichkeane), [Shivam Gupta](https://github.com/xgupta)\n\n**Desirable skills:** C++ coding experience\n\n**Project type:** Large/350 hr\n\n**Discourse** [URL](https://discourse.llvm.org/t/improve-clang-diagnostics/61521)\n\n**Description of the Project:** While the standard Polly-enabled -O1/-O2/-O3 optimization pass pipelines work fine with the [New Pass Manager](https://blog.llvm.org/posts/2021-03-26-the-new-pass-manager/) (NPM), some parts of Polly still only works with the legacy pass manager. This includes some passes such as -polly-export-jscop/-polly-export-jscop, regression testing, Polly-ACC, command line options such as -polly-show, the PassInstrumentation mechanism used by e.g. -print-after-all. LLVM (and Clang) have moved to NPM being the default and support for the legacy pass manager is deprecated, slowly degenerates and features getting removed. That is, all of Polly's functionality should eventually work with the NPM as well, and be prepared for the complete removal of the legacy pass manager. More details about the two pass managers found [here](https://github.com/banach-space/llvm-tutor#about-pass-managers-in-llvm).\n\n**Expected results:** The goal is to make Polly more usable with using only the NPM. Milestones, not necessarily all to be reached in this GSoC, are:  \n1\\. Make all of Polly's functionality available in the NPM (or decide to deprecate/remove it)  \n2\\. Better integration into the NPM (such as supporting PassInstrumentation); If the NPM turns out to be inadequate, use only a monolothic function pass.  \n3\\. Replace the legacy pass manager in regression tests.  \n4\\. Be ready for complete removal of the legacy pass manager in LLVM.\n\n**Confirmed mentor:** [Michael Kruse](https://github.com/Meinersbur)\n\n**Desirable skills:** Understanding of the C++ template pattern used by the new pass manager ([CRTP](https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern), [Mixins](https://en.wikipedia.org/wiki/Mixin), etc). Familarity with how LLVM can be [linked](https://www.lurklurk.org/linkers/linkers.html) (static, BUILD\\_SHARED\\_LIBS, and SHLIB/DYLIB) and its [plugin loading machanisms](https://www.llvm.org/docs/WritingAnLLVMPass.html#building-pass-plugins) (static, -load and -load-pass-plugin). Ideally, already worked with LLVM's new pass manager.\n\n**Project size:** Medium\n\n**Difficulty:** Medium/Hard\n\n**Discourse** [URL](https://discourse.llvm.org/t/61174)\n\n**Description of the project:** Enzyme performs automatic differentiation (in the calculus sense) of LLVM programs. This enables users to use Enzyme to perform various algorithms such as back-propagation in ML or scientific simulation on existing code for any language that lowers to LLVM. The support for an increasing number of LLVM Versions (7-main), AD modes (Reverse, Forward, Forward-Vector, Reverse-Vector, Jacobian), and libraries (BLAS, OpenMP, MPI, CUDA, ROCm, ...) leads to a steadily increasing code base. In order to limit complexity and help new contributors we would like to express our core logic using LLVM Tablegen. The applicant is free to decide how to best map the program transformation abstractions within Enzyme to Tablegen.\n\n**Expected results:** 1. A working tablegen rule generation system within Enzyme  \n2\\. Moving several existing rules to the new autogenerated system (e.g. LLVM instructions, LLVM intrinsics, BLAS calls, MPI calls, ...\n\n**Confirmed mentor:** [William Moses](mailto:wmoses@mit.edu), Valentin Churavy\n\n**Desirable skills:** Good knowledge of C++, calculus, and LLVM and/or Clang, and/or MLIR internals. Experience with Tablegen, Enzyme or automatic differentiation would be nice, but can also be learned in the project.\n\n**Project size:** Large\n\n**Difficulty:** Medium\n\n**Discourse** [URL](https://discourse.llvm.org/t/enzyme-moving-instruction-rules-to-tablegen/61176)\n\n**Description of the project:** Enzyme performs automatic differentiation (in the calculus sense) of LLVM programs. This enables users to use Enzyme to perform various algorithms such as back-propagation in ML or scientific simulation on existing code for any language that lowers to LLVM. Enzyme already implements forward and reverse mode automatic differentiation. Enzyme also implements vector forward mode automatic differentiation, which allows Enzyme to batch the derivative computation of several objects in a single call. The goal of this project is too extend this capability in order to perform vector reverse mode. In doing so, multiple sweeps of reverse mode automatic differentiation can be performed at the same time, reducing memory, time, and otherwise generally enabling further optimization.\n\n**Expected results:** Vectorized version of reverse mode automatic differentiation\n\n**Confirmed mentor:** [William Moses](mailto:wmoses@mit.edu), Tim Gymnich\n\n**Desirable skills:** Good knowledge of C++ and some experience with LLVM API's. Experience with Enzyme or automatic differentiation would be nice, but can also be learned in the project.\n\n**Project size:** Medium\n\n**Difficulty:** Medium\n\n**Discourse** [URL](https://discourse.llvm.org/t/enzyme-vector-reverse-mode-automatic-differentiation/61177)\n\n**Description of the project:** Enzyme is a compiler plugin for LLVM that performs automatic differentiation (in the calculus sense) of LLVM programs. This enables users to use Enzyme to perform various algorithms such as back-propagation in ML or scientific simulation on existing code for any language that lowers to LLVM.  \nEnzyme integrates into frontends through the use of an LLVM plugin that can be loaded into Clang, LLVM (opt), the linker (lld), libraries (HIPRtc), directly loaded (Julia), among others (Flang, Rust, etc).  \nWhile using various pieces of machinery from the new pass manager internally, Enzyme does not currently automatically register its transformation passes when using the new pass manager. This creates problems for users on LLVM 13 or above, where the new pass manager is run by default and may not understand why they get linker errors from their code not being differentiated (currently they must add a flag to specify the old pass manager).  \nThe goal of this project is to enable Enzyme to be called by the new pass manager in LLVM and generally create a coherent user experience.\n\n**Expected results:** 1. Enzyme can be called by the new pass manager  \n2\\. \\[Optional\\] Additional syntactic sugar that makes it easier to use Enzyme.\n\n**Confirmed mentor:** [William Moses](mailto:wmoses@mit.edu), Valentin Churavy\n\n**Desirable skills:** Good knowledge of C++, and LLVM. Experience with Enzyme would be nice, but can also be learned in the project.\n\n**Project size:** Small\n\n**Difficulty:** Medium\n\n**Discourse** [URL](https://discourse.llvm.org/t/enzyme-enable-the-new-pass-manager/61178)\n\nWelcome prospective Google Summer of Code 2021 Students! This document is your starting point to finding interesting and important projects for LLVM, Clang, and other related sub-projects. This list of projects is not only developed for Google Summer of Code, but open projects that really need developers to work on and are very beneficial for the LLVM community.\n\nWe encourage you to look through this list and see which projects excite you and match well with your skill set. We also invite proposals not on this list. You must propose your idea to the LLVM community through our developers' mailing list (llvm-dev@lists.llvm.org or specific subproject mailing list). Feedback from the community is a requirement for your proposal to be considered and hopefully accepted.\n\nThe LLVM project has participated in Google Summer of Code for several years and has had some very successful projects. We hope that this year is no different and look forward to hearing your proposals. For information on how to submit a proposal, please visit the Google Summer of Code main [website.](https://developers.google.com/open-source/gsoc/)\n\n**Description of the project:** The LLVM lit test suites consist of thousands of small independent tests. Due to the number of tests, it can take a long time to run the full suite, even on a high-spec computer. Builds are already distributable across multiple computers available on the same network, using software such as distcc or icecream, so running tests on a single machine becomes a potential bottleneck. One way to speed up running of the tests could be to distribute test execution across many computers too. Lit provides a test sharding mechanism, which allows multiple computers to run parts of the same testsuite in tandem, but this currently assumes access to a single common filesystem, which may not be possible in all cases and a knowledge of which machines the suite can currently be run on. This project’s goal is to update the existing lit harness (or write a wrapper around it) to allow distribution of the tests in this way, with the idea that developers can write their own interface between the harness and the distribution system of their choice. This harness may need to be able to identify test dependencies such as input files and executables, send the tests to the distribution system (possibly in batches), and receive, collate and report the results to the user, in a similar manner to how lit already does.\n\n**Expected results:** An easy to use harness as described above. Some evidence that given a distributed system, a user can expect to see test suite execution to speed up if they are using that harness.\n\n**Confirmed mentor:** James Henderson\n\n**Desirable skills:** Good knowledge of Python. Familiarity with LLVM lit testing. Some knowledge of distribution systems would also be beneficial.\n\n**Description of the project:** This is a short description, please reach out to Johannes (jdoerfert on IRC) and Mircea Trofin if it sounds interesting. We successfully introduced an ML framework for inliner decisions, now we want to expand the scope. In this project we will look at loop transformation heuristics, such as the unroll factor. As a motivational example we can look at a small trip count [dgemm](https://godbolt.org/z/Eeqcvs) which we optimize pretty poorly. With the nounroll pragmas we do a better job but still not close to gcc. The project is open-ended and we could look at various passes/heuristics concurrently.\n\n**Preparation resources:** The ML inliner framework in the LLVM code base as well as the [paper](https://arxiv.org/abs/2101.04808). LLVM transform passes (that are based on heuristics), e.g., loop unroll.\n\n**Expected results:** Measurable better performance with a learned predictor, potentially a set of \"classical\" heuristics derived from the ML model.\n\n**Confirmed Mentor:** Johannes Doerfert, Mircea Trofin\n\n**Desirable skills:** Intermediate knowledge of ML, C++, self motivation.\n\n**Description of the project:** This is a short description, please reach out to Johannes (jdoerfert on IRC) if it sounds interesting. Fuzzing often reveals a myriad of bugs. CSmith (and others) showed how to do this with C-like languages and we have used [LLVM-IR fuzzing](https://www.youtube.com/watch?v=UBbQ_s6hNgg) in the past successfully. In this project we will apply fuzzing to new passes that are in development, e.g., the Attributor pass. We want to find and fix crashes but also other bugs, including compile time performance problems.\n\n**Preparation resources:** The [LLVM fuzzer infrastructure](https://llvm.org/docs/FuzzingLLVM.html#llvm-opt-fuzzer). LLVM passes that we might want to fuzz, e.g. the Attributor pass. Prior IR-Fuzzing work (https://www.youtube.com/watch?v=UBbQ\\_s6hNgg)\n\n**Expected results:** Crashes, maybe also a way to catch non-crash bugs, including performance problems.\n\n**Confirmed Mentor:** Johannes Doerfert\n\n**Desirable skills:** Intermediate knowledge C++, self motivation.\n\nllvm.assume the missing pieces\n\n**Description of the project:** This is a short description, please reach out to Johannes (jdoerfert on IRC) if it sounds interesting. llvm.assume is a powerful mechanism to retain knowledge. Since it inception it was improved already multiple times but there are major extensions still outstanding which we want to tackled in this project. An incomplete list of topics includes:\n\n*   range-based assumptions, design idea 3) in the [RFC](https://lists.llvm.org/pipermail/llvm-dev/2019-December/137632.html).\n*   outline arbitrary assumption/assertion code, design idea 2) in the [RFC](https://lists.llvm.org/pipermail/llvm-dev/2019-December/137632.html).\n*   side-effect free assumptions, see [this review](https://reviews.llvm.org/D89054).\n*   more knowledge retention usages\n*   less interference with optimizations\n\n**Preparation resources:** The llvm.assumption usage, the assumption cache, the \"enable-knowledge-retention\" option, the [RFC](https://lists.llvm.org/pipermail/llvm-dev/2019-December/137632.html) and [this review](https://reviews.llvm.org/D89054).\n\n**Expected results:** New llvm.assume use cases, improved performance through knowledge retention, optimization based on assertions.\n\n**Confirmed Mentor:** Johannes Doerfert\n\n**Desirable skills:** Intermediate knowledge C++, self motivation.\n\n**Description of the project:** LLVM's IR has fundamental, long-standing issues. Many are related with undefined behaviors. Others are simply a fallout from underspecification and different interpretations by diffferent people. [Alive2](https://github.com/AliveToolkit/alive2) is a tool that detects bugs in LLVM's optimizations automatically. Using Alive2, we track bugs exposed by the unit tests on a [dashboard](https://web.ist.utl.pt/nuno.lopes/alive2/).\n\n**Expected results:** 1) Report and fix bugs detected by Alive2. 2) Pick one fundamental IR issue and make progress towards fixing it, including proposing fixes for the [semantics](https://llvm.org/docs/LangRef.html), testing fixes to the semantics by running Alive2 over the LLVM unit tests and medium-sized programs, test performance of semantic fixes and fix performance regressions.\n\n**Confirmed Mentor:** Nuno Lopes, Juneyoung Lee\n\n**Desirable skills:** Intermediate C++; willingness to learn about LLVM IR semantics; experience reading papers (preferred).\n\n**Description of the project:** The idea of LoopNest pass is recently added, and there are no existing passes utilizing it. Before having LoopNest pass, if you want to write a pass that works on a loop nest, you have to pick from either a function pass or a loop pass. If you chose to write it as a function pass, then you lose the ability to add loops dynamically back to the pipeline. If you decide to write it as a loop pass, then you are wasting compile time to traverse to your pass and return right away when the given loop is not the outermost loop. In this project, we want to utilize the recently introduced LoopNest pass for passes intended for loop nest and have the same ability as the LoopPass to dynamically add loops to the pipeline. In addition, improve the current implementation of LoopNestPass when necessary.\n\n**Expected results (possibilities):** Utilize LoopNest Pass for some existing transformations/analyses.\n\n**Confirmed Mentors:** Whitney Tsang, Ettore Tiotto\n\n**Desirable skills:** Intermediate knowledge of C++, self-motivation.\n\n**Description of the project:** This is a short description, please reach out to Johannes (jdoerfert on IRC) if it sounds interesting. OpenMP GPU kernels are usually lowered to native binaries, e.g., cubin, and embedded into the host object. At runtime, OpenMP \"plugins\" will connect with the device driver, e.g., CUDA, to load and run such embedded binary images. In this project we want to develop a new plugin that takes LLVM-IR code, optimizes the IR with kernel parameters known only at runtime, and then generates the GPU binary for consumption by other plugins. Similar to the [remote offload plugin](https://openmp.llvm.org/docs/design/Runtimes.html#remote-offloading-plugin) we can do this transparently to the user. In addition to the JIT infrastructure setup in the plugin we will need to embed the IR into the host object.\n\n**Preparation resources:**OpenMP target offloading infrastructure, LLVM JIT infrastructure.\n\n**Expected results:** A JIT-capable offload plugin which can achieve superior performance when kernel specialization is enabling optimizations.\n\n**Confirmed Mentor:** Johannes Doerfert\n\n**Desirable skills:** Intermediate knowledge C++, JIT compilation, self motivation.\n\n**Description of the project:** Clacc and Flacc are projects to introduce OpenACC support to Clang and Flang. For that purpose, OpenACC runtime support is being developed on top of LLVM's OpenMP runtime. However, diagnostics emitted by LLVM's OpenMP runtime are expressed in terms of OpenMP concepts, and so those diagnostics are not always meaningful to OpenACC users. This project should address this issue in two steps:\n\n1.  Develop a mechanism that selects OpenACC versions of diagnostics that are emitted as a result of OpenACC-related calls into the runtime. This mechanism should be general enough that it could be used for programming languages besides OpenMP and OpenACC. One possible approach is to extend internationalization mechanisms already present in some components of the OpenMP runtime.\n2.  Provide OpenACC translations for existing OpenMP diagnostics. This step requires an understanding of the relationship between OpenACC and OpenMP as implemented in Clacc and Flacc.\n\nMany components of OpenACC support that will depend upon this project have not yet been upstreamed and are under development. A high-level understanding of those efforts is helpful for this project and can be provided by the mentors. Nevertheless, this project can be completed in upstream LLVM's OpenMP runtime now independently of those efforts.\n\n**Expected results:** A version of upstream LLVM's OpenMP runtime that can emit OpenACC diagnostics as needed.\n\n**Confirmed Mentors:** Valentin Clement, Joel E. Denny\n\n**Desirable skills:** Intermediate C++; Experience with OpenACC or OpenMP\n\n**Description of the project:** Polly use algorithms from the [Integer Set Library (isl)](http://isl.gforge.inria.fr/), which is a library written in C. It uses reference-counting for memory management. Getting reference counting correct is much easier in C++ using RAII, therefore we created a C++ binding for isl: [isl-noexceptions.h](https://github.com/llvm/llvm-project/blob/main/polly/lib/External/isl/include/isl/isl-noexceptions.h). Since then, isl also gained two official C++ bindings, [cpp.h](https://github.com/llvm/llvm-project/blob/main/polly/lib/External/isl/include/isl/cpp.h) and [cpp-checked.h](https://github.com/llvm/llvm-project/blob/main/polly/lib/External/isl/include/isl/cpp-checked.h). We would like to replace the Polly-maintained C++ bindings with the upstream bindings. Unfortunately, this is not an in-place replacement. Differences include how errors are checked, method names, which functions are considered as operator/constructor overloads and the set of exported functions. This will require changing Polly's uses of the C++ bindings and submitting patches to isl to export additional functionality needed by Polly.\n\n**Expected results:** Reduce the differences between the Polly-maintained isl-noexceptions.h bindings and one of the two C++ bindings that isl supports. Due to isl-noexceptions.h exporting more functions and classes than the upstream bindings do, a complete replacement will probably be out of reach, but even reducing the differences will reduce the maintenance cost of Polly's isl-noexceptions.h.\n\n**Confirmed mentor:** Michael Kruse\n\n**Desirable skills:** Deep knowledge of C++, in particular RAII and move-semantics. Interest in API design. Ideally, you already wrote some library's header file. Experience with the isl library would be nice, but can also be learned in the project.\n\n**Description of the project:** [Enzyme](https://enzyme.mit.edu/) performs automatic differentiation (in the calculus sense) of LLVM programs. This enables users to use Enzyme to perform various algorithms such as back-propagation in ML or scientific simulation on existing code for any language that lowers to LLVM. Enzyme does so by applying the chain rule to every instruction in every function called by the original function to be differentiated. While functional, this is not necessarily optimal for high-level matrix operations which may have algebraic properties for faster derivative computation. Enzyme also has a mechanism for specifying a custom gradient for a given function. If a custom derivative is available, Enzyme will use that rather than fallback to implementing its own. Many programs use BLAS libraries to efficiently compute matrix and tensor operations. This project would enable high-performance automatic differentiation of BLAS and similar libraries (such as Eigen) by specifying custom derivative rules for their operations.\n\n**Expected results:** Efficient differentiation of BLAS and Eigen codes by writing custom derivative rules for matrix and tensor operations.\n\n**Confirmed mentor:** [William Moses](mailto:wmoses@mit.edu), Johannes Doerfert\n\n**Desirable skills:** Good knowledge of C++, calculus, and linear algebra. Experience with BLAS, Eigen, or Enzyme would be nice, but can also be learned in the project.\n\n**Description of the project:** [Enzyme](https://enzyme.mit.edu/) performs automatic differentiation (in the calculus sense) of LLVM programs. This enables users to use Enzyme to perform various algorithms such as back-propagation in ML or scientific simulation on existing code for any language that lowers to LLVM. While this functions for any frontend that emits LLVM IR, it may be desirable to have closer integration between Enzyme and the frontend for the sake of passing additional information and creating a better user experience. Swift provides automatic differentiation through the use of specifying custom derivative rules in the front-end. Enzyme could be integrated directly with Swift, differentiating the eventual LLVM, but it would lose out on all this additional information about custom derivatives. Moreover, calling into Enzyme naiively would be without Type checking, fine AD-specific debug information, or various other nice tools that Swift provides users of AD. This project would seek to integrate Enzyme and the Swift front end to provide both a nice user-experience for swift programmers who want to use Enzyme to enable high-performance automatic differentiation, and also to allow Enzyme to take advantage of derivative-specific metadata already available in swift.\n\n**Expected results:** Creation of a custom type-checked linguistic construct in Swift for calling Enzyme. Mechanisms for passing Swift's differentiation-specific metadata for use by Enzyme.\n\n**Confirmed mentor:** [William Moses](mailto:wmoses@mit.edu), Vassil Vassilev\n\n**Desirable skills:** Good knowledge of C++ and Swift. Experience with Enzyme or automatic differentiation would be nice, but can also be learned in the project.\n\n**Description of the project:** [Enzyme](https://enzyme.mit.edu/) performs automatic differentiation (in the calculus sense) of LLVM programs. This enables users to use Enzyme to perform various algorithms such as back-propagation in ML or scientific simulation on existing code for any language that lowers to LLVM. In a variety of fields, it is desirable to compute on fixed-point values (e.g. integers) rather than floating point values. This avoid certain truncation errors that may be critical to a given application. Moreover, particular pieces of hardware may simply be more efficient on fixed point rather than floating point values. This project would seek to extend Enzyme to support differentiation of not only floating point base values, but also fixed point base values..\n\n**Expected results:** Implementation of adjoints for LLVM fixed point intrinsics, requisite type analysis rules, and integration into a front-end for an end-to-end test.\n\n**Confirmed mentor:** [William Moses](mailto:wmoses@mit.edu)\n\n**Desirable skills:** Good knowledge of C++, caclulus, and LLVM internals. Experience with Enzyme or automatic differentiation would be nice, but can also be learned in the project.\n\n**Description of the project:** [Enzyme](https://enzyme.mit.edu/) performs automatic differentiation (in the calculus sense) of LLVM programs. This enables users to use Enzyme to perform various algorithms such as back-propagation in ML or scientific simulation on existing code for any language that lowers to LLVM. While this functions for any frontend that emits LLVM IR, it may be desirable to have closer integration between Enzyme and the frontend for the sake of passing additional information and creating a better user experience. This project would seek to integrate Enzyme and the Rust front end to provide a nice user-experience for Rust programmers who want to use Enzyme to enable high-performance automatic differentiation. This also potentially involves integration of LLVM plugin support/custom codegen into rustc.\n\n**Expected results:** Creation of a custom type-checked linguistic construct in Rust for calling Enzyme. Mechanisms for parsing Rust's Type information (represented as debug LLVM debug info) directly into type analysis.\n\n**Confirmed mentor:** [William Moses](mailto:wmoses@mit.edu)\n\n**Desirable skills:** Good knowledge of C++ and Rust. Experience with Enzyme or automatic differentiation would be nice, but can also be learned in the project.\n\n**Description of the project:**\n\n*   Chart how much time is spent in transfer functions – including (but not limited to!) checker callbacks.\n*   Add llvm Statistics and Timers for quickly obtaining precise and concise dumps without external profilers. Statistics on state splits might be particularly interesting!\n*   Measure time spent analyzing specific stack frames. Say, how much time do we spend inlining std::string methods? This time could be saved if we add custom models for these methods instead.\n\n**Confirmed mentor:** Artem Dergachev\n\n**Description of the project:** CSA has a small in-house constraint solver, it is pretty trivial, but super fast. The goal is to support range-based logic for some of the symbolic operators, while keeping it linear. Additionally, a unit-test framework can be designed specifically for testing constraint solvers (right now it’s tested rather awkwardly). This project has a couple of interesting properties. It can be segmented into small chunks, and each of these chunks has a non-trivial solution. It might introduce you to a world of solvers (it is a good idea to check your ideas with some heavy-weight solver such as z3). And because the existing solver is simple, there is a myriad of possible extensions to try.\n\n**Confirmed mentor:** Valeriy Savchenko\n\n**Description of the project:**\n\n*   Design and integrate a new diagnostic abstraction (similar to clang::Diagnostic) to report errors, warnings and notes in a structured way.\n*   Allow us to differentiate between bugs (unexpected errors) and things the debugger simply doesn’t know (expected errors). Be smart about printing global errors only once. Have the ability of being verbose and have additional metadata (source location, DWARF unit, object file, etc, depending on the type of error and where it originated).\n*   Should be compatible and tightly integrated with the existing classes, such as the Status and CommandReturnObject.\n\n**Confirmed mentor:** [Jonas Devlieghere and Raphael Isemann](mailto:teemperor@gmail.com,jonas@devlieghere.com?subject=[GSoC]%20LLDB%20Diagnostics)\n\nLLVM participation in Google Summer of Code 2020 was very successful and resulted in many interesting projects contributed to LLVM. For the list of accepted and completed projects, please take a look into Google Summer of Code [website.](https://summerofcode.withgoogle.com/archive/2020/organizations/5902726635978752/)\n\n**Description of the project:** This is a short description, please reach out to Johannes (jdoerfert on IRC) if it sounds interesting. During the GSoC'19 we build the Attributor framework to improve the inter-procedural capabilities of LLVM. This is useful on its own but especially in situations where inlining is impossible or undesirable. In this GSoC project we will look at capabilities not yet available in the Attributor and for the potential to connect the Attributor with existing intra- and inter-procedural optimizations. In this project there is a lot of freedom to determine the actual tasks but we will provide a pool of smaller and medium sized tasks that can be chosen from as well.\n\n**Preparation resources:** The Attributor YouTube videos from the LLVM Developers Meeting 2019 and the recording of the IPO panel from the same meeting. The Attributor framework as well as other existing inter-procedural analyses and optimizations in LLVM.\n\n**Expected results:** Measurable better IPO, especially visible in cases where inlining is not an option or undesirable.\n\n**Confirmed Mentor:** Johannes Doerfert\n\n**Desirable skills:** Intermediate knowledge of C++, self motivation.\n\n**Description of the project:** This is a short description, please reach out to Johannes (jdoerfert on IRC) if it sounds interesting. With the OpenMPOpt pass ([under review](https://reviews.llvm.org/D69930)) we started to teach the LLVM optimization pipeline about OpenMP parallelism encoded as OpenMP runtime calls. In this GSoC project we will look at capabilities not yet available in the OpenMPOpt pass and for the potential to connect existing intra- and inter-procedural optimizations, e.g. the Attributor. In this project there is a lot of freedom to determine the actual tasks but we will provide a pool of smaller and medium sized tasks that can be chosen from as well.\n\n**Preparation resources:** The \"Optimizing Indirections, using abstractions without remorse\" video on YouTube from the LLVM Developers Meeting 2018. The paper \"Compiler Optimizations for OpenMP\" and \"Compiler Optimizations For Parallel Programs\" both by J. Doerfert and H. Finkel (the slides for these are potentially even more useful).\n\n**Expected results:** Measurable better performance or program analysis results for parallel programs with a focus on OpenMP.\n\n**Confirmed Mentor:** Johannes Doerfert\n\n**Desirable skills:** Intermediate knowledge of C++, self motivation.\n\n**Description of the project:** Generating debug information is one of the fundamental tasks a compiler typically fulfills. It is clear that executable generated code should not depend on the presence of debug information.\n\nUnfortunately there are known cases in LLVM were code generation differs depending on whether debug information is enabled (\\`-g\\`) or not. These kind of bugs can lead to bad debug experience ranging from unexpected execution behaviour to the point of programs running fine in debug mode while crashing without debug information.\n\nThe issue has likely not a single cause but is triggered during different passes on different architectures. One such reason is the insertion of Call Frame Information (CFI) in the compiler backend during frame lowering and other later passes. The presence of CFI instructions seems to change instruction scheduling which therefore leads to different generated code.\n\n**Preparation resources:**\n\n*   [PR37728](https://llvm.org/PR37728) is a meta-bug that collects several related issues of differing codegen.\n*   [PR37240](https://llvm.org/PR37240) is a bug discussing the CFI issue mentioned above.\n*   The following [RFC](http://lists.llvm.org/pipermail/llvm-dev/2019-September/135433.html) discusses some possible mitigation strategies and gives some background information on the CFI issue.\n\n**Expected results:**\n\n*   Write some tooling based on existing scripts to automatically generate examples of differing codegen. This is intended as a starting task to get to know the existing LLVM tools, learn to read LLVM's internal outputs etc.\n*   Choose one or more (depending on the difficulty) bugs that cause codegen differences and try to provide patches to fix them. We would be particularly interested in the mentioned CFI issue but working on some of the other related bugs is also absolutely fine.\n\n**Confirmed Mentors:** Paul Robinson and David Tellenbach\n\n**Desirable skills:** Intermediate knowledge of C++, some familarity with general computer architecture, some familarity with the x86 or Arm/AArch64 instruction set.\n\n**Description of the project:** MergeSimilarFunctions pass is able to merge not just identical functions, but also functions with small differences in their instructions to reduce code size. It does this by inserting control flow and an additional argument in the merged function to account for the differences. This work was presented at the [LLVM Dev Meeting in 2013](http://llvm.org/devmtg/2013-11/#talk3) A more detailed description was published in a paper at [LCTES 2014](http://dl.acm.org/citation.cfm?id=2597811). The code was released to the community at the time. Meanwhile, the pass has been in production use at QuIC for the past few years and has been actively maintained internally. In order to magnify the impact of MergeSimilarFunctions, it has been ported to ThinLTO and the patches have been upstreamed (see stack of 5 patches mentioned below). But instead of replacing the existing MergeFunctions pass in LLVM-upstream the community suggested we improve the existing one with the ideas from MergeSimilarFunctions. And then leverage the ThinLTO on top of that. The MergeSimilarFunction used in ThinLTO gives impressive code size reduction across a wide range of workloads and the work was presented at [LLVM-dev 2018](https://llvm.org/devmtg/2018-10/talk-abstracts.html#talk2). The LLVM project would greatly benefit from this code size optimization as most embedded systems (think SmartPhones) applications are constrained on code-size.\n\n**Preparation resources:**\n\n*   Stack of patches:\n    *   [MergeSimilarFunctions 1/n: a code size pass to merge functions with small differences](https://reviews.llvm.org/D52896)\n    *   [\\[Porting MergeSimilarFunctions 2/n\\] Changes to DataLayout](https://reviews.llvm.org/D52898)\n    *   [\\[Merge SImilar Function ThinLTO 3/n\\] Add hash code to function summary](https://reviews.llvm.org/D52966)\n    *   [\\[Merge SImilar Function ThinLTO 4/n\\] Make merge function decisions before the thin-lto stage](https://reviews.llvm.org/D53253)\n    *   [\\[Merge SImilar Function ThinLTO 5/n\\] Set up similar function to be imported](https://reviews.llvm.org/D53254)The paches can be easily applied to LLVM-trunk and would give a developer a decent head start ;).\n*   List of llvm-dev mailing list posts on previous discussions around Merge Functions\n    \n    *   [Link1](http://lists.llvm.org/pipermail/llvm-dev/2019-January/129835.html)\n    [](http://lists.llvm.org/pipermail/llvm-dev/2019-January/129835.html)*   [](http://lists.llvm.org/pipermail/llvm-dev/2019-January/129835.html)[Link2](http://lists.llvm.org/pipermail/llvm-dev/2019-March/131066.html)\n    [](http://lists.llvm.org/pipermail/llvm-dev/2019-March/131066.html)*   [](http://lists.llvm.org/pipermail/llvm-dev/2019-March/131066.html)[Link3](http://lists.llvm.org/pipermail/llvm-dev/2019-February/129863.html)\n    [](http://lists.llvm.org/pipermail/llvm-dev/2019-February/129863.html)*   [](http://lists.llvm.org/pipermail/llvm-dev/2019-February/129863.html)[Link4](http://lists.llvm.org/pipermail/llvm-dev/2019-January/129832.html)\n    [](http://lists.llvm.org/pipermail/llvm-dev/2019-January/129832.html)\n    \n    [](http://lists.llvm.org/pipermail/llvm-dev/2019-January/129832.html)\n[](http://lists.llvm.org/pipermail/llvm-dev/2019-January/129832.html)*   [](http://lists.llvm.org/pipermail/llvm-dev/2019-January/129832.html)[The original paper: LCTES 2014](http://dl.acm.org/citation.cfm?id=2597811)\n*   [Video and slides of the presentation](https://llvm.org/devmtg/2018-10/talk-abstracts.html#talk2)\n\n**Expected results:**\n\n*   Improve MergeFunctions to have feature parity with MergeSimilarFunctions.\n*   Enable MergeFunctions to ThinLTO.\n\n**Confirmed Mentors:**Aditya Kumar (hiraditya on IRC and phabricator), JF Bastien (jfb on phabricator)\n\n**Desirable skills:** Course on compiler design, SSA Representation, Intermediate knowledge of C++, Familiarity with LLVM Core.\n\n**Description of the project:** LLVM provides a tool called yaml2obj which coverts a YAML document into an object file, for various different file formats such as ELF, COFF and Mach-O, along with obj2yaml which does the inverse. The tool is commonly used to test parts of LLVM, as YAML is often easier to use to describe an object file than raw assembly and more maintainable than a pre-built binary. DWARF is a debugging file format commonly used by LLVM. Many of the tests for LLVM’s DWARF emission are written in assembly, but it would be nicer to write them in YAML. However, yaml2obj does not properly support emission of DWARF sections. This project is to add functionality to yaml2obj to make writing test inputs for DWARF tests simpler, particularly for ELF objects.\n\n**Preparation resources:** Reading up on the DWARF file format will be useful, in particular the standards available at http://dwarfstd.org/Download.php. Also, familiarising yourself with the basics of the ELF file format, as described here https://www.sco.com/developers/gabi/latest/contents.html, may be beneficial.\n\n**Expected results:** The ability to use yaml2obj to generate DWARF sections for object files. Particularly important is ensuring the input YAML can be more easily understood than the equivalent assembly.\n\n**Confirmed Mentors:** James Henderson\n\n**Desirable skills:** Intermediate knowledge of C++.\n\n**Description of the project:** Hot Cold Splitting in LLVM is an IR level function splitting transformation. The goal of hot/cold splitting is to improve the memory locality of code and helps reduce startup working set. The splitting pass does this by identifying cold blocks and moving them into separate functions. Because it is implemented at the IR level all the back end target benefit from it. It is a relatively new optimization and it was recently presented at the [LLVM Dev Meeting in 2019](https://llvm.org/devmtg/2019-10/talk-abstracts.html#tech8) and the slides are [here](https://llvm.org/devmtg/2019-10/slides/Kumar-HotColdSplitting.pdf) Because most of the benefit comes from outlining small blocks e.g., \\_\\_assert\\_rtn. The goal of this project is to identify potential blocks via static analysis e.g., exception handling code, optimizing personality functions. Use cost-model to ensure outlining reduces the code size of the caller, use tail call whenever appropriate to save instructions.\n\n**Preparation resources:**\n\n*   [Update on hot cold splitting](http://lists.llvm.org/pipermail/llvm-dev/2019-January/129606.html)\n*   The following two papers provide earlier work on hot cold splitting. While these papers are a good start, LLVM's HCS has completely different implementation in two aspects a) It is implemented at IR level and outlines basic blocks as function rather than naked branches. b) It is based on regions and outlines a set of basic blocks.\n    *   [Original paper on hot cold splitting by Pettis and Hansen.](http://pages.cs.wisc.edu/~fischer/cs701.f05/code.positioning.pdf)Section 5 on procedure splitting is interesting one. It has nice examples ;) to help understand why HCS works.\n    *   [Paper on hot cold splitting](https://www.cs.cmu.edu/afs/cs/academic/class/15745-s07/www/papers/p80-cohn.pdf) The paper provides some details on one approach to split functions. This is helpful to get a different perspective and may help get new ideas.\n*   [Video and slides of the presentation](https://llvm.org/devmtg/2019-10/talk-abstracts.html#tech8)\n\n**Expected results:**\n\n*   Improve Hot Cold Splitting to detect and outline cold blocks from program via static analysis or profile information. Use appropriate cost model to weigh benefit of HCS. In case compile time overhead becomes quadratic, come up with a cost model to detect when quadratic behavior gets triggered and bail out based on a compiler flag.\n\n**Confirmed Mentors:**Aditya Kumar (hiraditya on IRC and phabricator)\n\n**Desirable skills:** Course on compiler design, SSA Representation, Intermediate knowledge of C++, Familiarity with LLVM Core.\n\n**Description of the project:** Selecting optimization passes for given application is very important but non-trivial problem because of the huge size of the compiler transformation space (incl. pass ordering). While the existing heuristics can provide high performance code for certain applications, they cannot easily benefit a wide range of application codes. The goal of the project is to learn the interplay between LLVM transformation passes and code structures, then improve the existing heuristics (or replace the heuristics with machine learning-based models) so that the LLVM compiler can provide a superior order of the passes customized per application.\n\n**Expected results (possibilities):**\n\n*   Insights about (implicit) dependences between existing passes.\n*   New pass pipelines (think -O3a, -O3b, ...) selectable by the user that tend to perform substantially better on certain kinds of programs.\n*   An improved LLVM pass heuristic or new machine learning-based models that can select the best order for LLVM transformation passes based on code structures.\n\n**Preparation resources:**\n\n*   HERCULES: Strong Patterns towards More Intelligent Predictive Modeling, Eunjung Park; Christos Kartsaklis; John Cavazos, IEEE ICPP’14 https://ieeexplore.ieee.org/abstract/document/6957226\n*   Predictive Modeling in a Polyhedral Optimization Space, Eunjung Park, John Cavazos, Louis-Noël Pouchet, Cédric Bastoul, Albert Cohen & P. Sadayappan, IJPP’13 https://link.springer.com/article/10.1007/s10766-013-0241-1\n*   Machine Learning in Compiler Optimization, Zheng Wang and Michael O’Boyle, IEEE Magazine 2018. https://ieeexplore.ieee.org/document/8357388\n\n**Confirmed Mentors:**EJ Park, Giorgis Georgakoudis, Johannes Doerfert\n\n**Desirable skills:** C++, Python, experience with LLVM and learning-based prediction preferable.\n\n**Description of the project:** Current machine learning models for compiler optimization select the best optimization strategies for functions based on isolated per function analysis. In this approach, the constructed models are not aware of any relationships with other functions around it (callers or callees) which can be helpful to decide the best optimization strategies for each function. In this project, we want to explore the SCC (Strongly Connected Components) call graph to add inter-procedural features in constructing machine learning-based models to find the best optimization strategies per function. Moreover, we want to explore the case that it is helpful to group strongly related functions together and optimize them as a group, instead of per function.\n\n**Expected results (possibilities):**\n\n*   Improved heuristics for existing (inter-procedural) passes, e.g. to weight inlining versus function cloning based on code features.\n*   Machine learning models to select the best optimizations using code features and inter-procedural analysis. This model can be used for functions in isolation or groups of functions, e.g., CGSCCs.\n\n**Preparation resources:**\n\n*   HERCULES: Strong Patterns towards More Intelligent Predictive Modeling, Eunjung Park; Christos Kartsaklis; John Cavazos, IEEE ICPP’14 https://ieeexplore.ieee.org/abstract/document/6957226\n*   Predictive Modeling in a Polyhedral Optimization Space, Eunjung Park, John Cavazos, Louis-Noël Pouchet, Cédric Bastoul, Albert Cohen & P. Sadayappan, IJPP’13 https://link.springer.com/article/10.1007/s10766-013-0241-1\n*   Machine Learning in Compiler Optimization, Zheng Wang and Michael O’Boyle, IEEE Magazine 2018. https://ieeexplore.ieee.org/document/8357388\n\n**Confirmed Mentors:**EJ Park, Giorgis Georgakoudis, Johannes Doerfert\n\n**Desirable skills:** C++, Python, experience with LLVM and learning-based prediction preferable.\n\n**Description of the project:** There is currently no easy way to use the result of PostDominatorTreeAnalysis in a loop pass, as PostDominatorTreeAnalysis is a function analysis, and it is not included in LoopStandardAnalysisResults. If one adds PostDominatorTreeAnalysis in LoopStandardAnalysisResults, then all loop passes need to preserve it, meaning that all loop passes need to make sure the result is up to date. In this project, we want to modify some commonly used utilities to generate a list of updates, which can be consume by different updaters, e.g. DomTreeUpdater to update DominatorTree and PostDominatorTree, and MSSAU to update MemorySSA, etc, instead of only updating the DominatorTree. In additional, we want to change existing loop passes to preserve the PostDominatorTree. Finally, adding PostDominatorTree in LoopStandardAnalysisResults.\n\n**Expected results (possibilities):** PostDominatorTree added in LoopStandardAnalysisResults, and can be used by loop passes. More common utilities change to generate list of updates to be easily obtained by different updaters.\n\n**Confirmed Mentors:** Whitney Tsang, Ettore Tiotto, Bardia Mahjour\n\n**Desirable skills:** Intermediate knowledge of C++, self-motivation.\n\n**Preparation resources:**[](https://reviews.llvm.org/rL336163)[](http://llvm.org/doxygen/classllvm_1_1DomTreeUpdater.html)[](https://llvm.org/doxygen/classllvm_1_1PostDominatorTreeAnalysis.html)[](http://llvm.org/doxygen/structllvm_1_1LoopStandardAnalysisResults.html)\n\n**Description of the project:** Currently if you want to write a pass that works on a loop nest, you have to pick from either a function pass or a loop pass. If you chose to write it as a function pass, then you lose the ability to add loops dynamically back to the pipeline. If you decide to write it as a loop pass, then you are wasting compile time to traverse to your pass and return right away when the given loop is not the outermost loop. In this project, we want to create a LoopNestPass, where transformations intended for loop nest can inherit from it, and have the same ability as the LoopPass to dynamically add loops to the pipeline. In addition, create all the adaptors requires to add loop nest passes at different points of the pass builder.\n\n**Expected results (possibilities):** Transformations/Analyses can be written as LoopNestPass, without compromising compile time or usability.\n\n**Confirmed Mentors:** Whitney Tsang, Ettore Tiotto\n\n**Desirable skills:** Intermediate knowledge of C++, self-motivation.\n\n**Preparation resources:**[](https://reviews.llvm.org/D68789)[](https://llvm.org/doxygen/classllvm_1_1PassBuilder.html)\n\n[](https://llvm.org/doxygen/classllvm_1_1PassBuilder.html)\n\n**Description of the project:** TableGen is flexible and allow the end-user to define and set common properties of records (instructions). Every target has dozens or hundreds of such instruction properties. As target code evolve, the td files become more and more complicated, it become harder to see whether the setting of some properties is necessary, even correct or not. eg: whether hasSideEffects property is correctly set on all instructions? One can manually search through the TableGen-generated files; or write some script to run TableGen and matching the output for some specific properties, but a standalone utility that can dump and check instruction properties systematically (eg: also allow target to define some verification rules) might be better from a build-process-management standpoint. This can help to find quite some hidden bugs and hence improve the overall codegen code quality. In addition, the utility can be used to write regression tests for instruction properties, which will increase the quality and precision of LLVM's regression tests.\n\n**Expected results (possibilities):** A standalone llvm tool or utility that can dump and check instruction properties systematically\n\n**Confirmed Mentors:** Hal Finkel, Jinsong Ji , Qingshan Zhang\n\n**Desirable skills:** Intermediate knowledge of C++, self-motivation.\n\n**Description of the project:** Determining whether it is safe to move code around is implemented in several transformations in LLVM (e.g. canSinkOrHoistInst in LICM, or makeLoopInvariant in Loop). Each of these implementations may return different results for a given query, making code motion safety checks inconsistent and duplicated. On the other hand, the mechanism for doing the actual code motion is also different in each transformation. Code duplication causes maintenance problems and increases the time taken to write new transformation. In this project, we want to first identify all the existing ways in loop transformations (could be function or loop pass) to check if code is safe to move, and to move code, and create a standardize way to do so.\n\n**Expected results (possibilities):** A standardize/superset of all the existing ways in loop transformations of checking if code is safe to be moved and to move\n\n**Confirmed Mentors:** Whitney Tsang, Ettore Tiotto, Bardia Mahjour\n\n**Desirable skills:** Intermediate knowledge of C++, self-motivation.\n\n**Preparation resources:**[](https://github.com/llvm/llvm-project/blob/master/llvm/include/llvm/Transforms/Utils/CodeMoverUtils.h)[](https://llvm.org/doxygen/LICM_8cpp_source.html)[](https://llvm.org/doxygen/classllvm_1_1Loop.html)\n\nAll the items in the list of [open projects](https://mlir.llvm.org/getting_started/openprojects/) are opened to GSOC. Feel free to propose your own ideas as well on [Discourse](https://llvm.discourse.group/c/llvm-project/mlir).\n\n**Description of the project:** The Clang Static Analyzer already knows how to prevent crashes caused by null pointer dereference in arbitrary code, however it often \"gives up\" when the code is too complicated. In particular, implementation details of C++ standard classes, even simple ones such as smart pointers or optionals, may be too convoluted for the Analyzer to fully understand. Moreover, the exact behavior depends on which implementation of the Standard Library is used (e.g., GNU libstdc++ or LLVM's own libc++).\n\nWe can enable the Analyzer to find more bugs in modern C++ code by teaching it explicitly about the behavior of C++ standard classes, and therefore skipping the whole process in which the Analyzer tries to understand all the implementation details on its own. For example, we could teach it that a default-constructed smart pointer is null, and any attempt to dereference it would result in a crash. The project would therefore consist in manually providing implementations for various methods of standard classes.\n\n**Expected results:** We want the Static Analyzer to emit warnings when a null smart pointer dereference would occur in the code. For example:\n\n    #include <memory\\>\n\n    int foo(bool flag) {\n      std::unique\\_ptr<int\\> x;  _// note: Default constructor produces a null unique pointer;_\n\n      if (flag)                _// note: Assuming 'flag' is false;_\n        return 0;              _// note: Taking false branch_\n\n      return \\*x;               _// warning: Dereferenced smart pointer 'x' is null._\n    }\n    \n\nWe should be able to cover at least one class fully, for example,\n\nstd::unique\\_ptr, and then see if we can generalize our results to other classes, such as\n\nstd::shared\\_ptror the C++17\n\nstd::optional.\n\n**Confirmed Mentor:** Artem Dergachev, Gábor Horváth\n\n**Desirable skills:** Intermediate knowledge of C++.\n\n**Description of the project:** LLDB's command line offers several convenience features that are inspired by features of UNIX shells such as tab completions or a command history. One feature that is not implemented yet are 'autosuggestions'. These are suggestions for possible commands that the user might want to type, but unlike tab completions they are displayed directly behind the cursor while the user is typing a command. A good demonstration how this could look like are the autosuggestions implemented in [fish shell](https://fishshell.com/).\n\nThis project is about implementing autosuggestions in LLDB's editline-based command shell.\n\n**Confirmed Mentor:** [Jonas Devlieghere and Raphael Isemann](mailto:teemperor@gmail.com,jonas@devlieghere.com?subject=[GSoC]%20Autosuggestions)\n\n**Desirable skills:** Intermediate knowledge of C++.\n\n**Description of the project:** LLDB's command line offers several convenience features that are inspired by features of UNIX shells such as tab completions for commands. These tab completions are implemented by a completion engine that is not only used by the command line interface of LLDB, but also by graphical interfaces for LLDB such as IDEs. While the tab completions in LLDB are really useful, they are currently not implemented for all commands and their respective arguments. This project is about implementing the remaining completions for the commands in LLDB which will greatly improve the user experience of LLDB. Improving existing completions is also part of the project. Note that the completions are not static list of strings but often require inspecting and understanding the internal state of LLDB. As LLDB commands and their tab completions cover all aspects of LLDB, this project offers a great way to get an overview of all the functionality in LLDB.\n\n**Confirmed Mentor:**[Raphael Isemann](mailto:teemperor@gmail.com?subject=[GSoC]%20Completions)\n\n**Desirable skills:** Intermediate knowledge of C++.\n\n**Description of the project:** Just as LLVM is a library to build compilers, LLDB is a library to build debuggers. LLDB vends a stable, public SB API. Due to historic reasons the LLDB command line interface is currently implemented on top of LLDB's private API and it duplicates a lot of functionality that is already implemented in the public API. Rewriting LLDB's command line interface on top of the public API would simplify the implementation, eliminate duplicate code, and most importantly reduce the testing surface.\n\nThis work will also provide an opportunity to clean up the SB API of commands that have accrued too many overloads over time and convert them to make use of option classes to both gather up all the variants and also future-proof the APIs.\n\n**Confirmed Mentor:**Adrian Prantl and Jim Ingham\n\n**Desirable skills:** Intermediate knowledge of C++.\n\n**Description of the project:** One of the tensions in the testsuite is that spinning up a process and getting it to some point is not a cheap operation, so you'd like to do a bunch of tests when you get there. But the current testsuite bails at the first failure, so you don't want to do many tests since the failure of one fails all the others. On the other hand, there are some individual test assertions where the failure of the assertion _should_ cause the whole test to fail. For example, if you fail to stop at a breakpoint where you want to check some variable values, then the whole test should fail. But if your test then wants to check the value of five independent locals, it should be able to do all five, and then report how many of the five variable assertions failed. We could do this by adding _Start_ and _End_ markers for a batch of tests, do all the tests in the batch without failing the whole test, and then report the error and fail the whole test if appropriate. There might also be a nice way to do this in Python using scoped objects for the test sections.\n\n**Confirmed Mentor:** Jim Ingham\n\n**Desirable skills:** Intermediate knowledge of Python.\n\nGoogle Summer of Code 2019 contributed a lot to the LLVM project. For the list of accepted and completed projects, please take a look into Google Summer of Code [website.](https://summerofcode.withgoogle.com/archive/2019/organizations/5682474363912192/)\n\n**Description of the project:** Adding Debug Info (compiling with \\`clang -g\\`) shouldn't change the generated code at all. Unfortunately we have bugs. These are usually not too hard to fix and a good way to discover new part of the codebase! We suggest building object files both ways and disassembling the text sections, which will give cleaner diffs than comparing .s files.\n\n**Expected results:** Reduced test cases, bug reports with analysis (e.g., which pass is responsible), possibly patches.\n\n**Confirmed Mentor:** Paul Robinson\n\n**Desirable skills:** Intermediate knowledge of C++, some familiarity with x86 or ARM instruction set.\n\n**Description of the project:** Clang contains an ASTImporter which allows moving declarations and statements from one Clang AST to another. This is for example used for static analysis across translation units and in LLDB's expression evaluator.\n\nThe current ASTImporter works as intended when moving simple C code from one AST to another. However, more complicated declarations such as C++'s OOP features and templates are not fully implemented and can cause crashes or invalid AST nodes. The bug reports related to these crashes are often filed against LLDB's expression evaluator and are rarely submited with a minimal reproducer. This makes improving ASTImporter a time-consuming and tedious task.\n\nThis project is about writing a fuzzer to proactively discover these ASTImporter bugs and provide minimal reproducers which make understanding and fixing the underlying bug easier.\n\nA possible implementation of such a fuzzer and driver could look like this:\n\n*   Generate some source code that can be imported (either fully randomly or based on existing source code from a user-given code corpus).\n*   Import randomly a few declarations from this AST. The AST in which they are imported to can already be populated with declarations.\n*   Run Clang's code generator over our imported AST.\n*   If we hit an assert during the import or CodeGen steps we probably found an ASTImporter bug.\n*   The fuzzer driver should now reduce the size of the source code until it is as small as possible and still reproduces the crash (e.g. by running Creduce with an automatically generated test script).\n*   The reproducer should now be stored in a format so that it can just be copied into Clang's regression test suite for the ASTImporter (see the [clang/test/Import/](https://github.com/llvm/llvm-project/tree/master/clang/test/Import) directory). The reproducer must still reproduce the found bug when run as part of the test suite.\n\nThis is just one possible approach and students are welcome to submit their own ideas on how the fuzzer should operate. Approaches that allow to automatically verify more aspects of the imported AST (e.g. the source locations of AST nodes, size of RecordDecls) are encouraged. The fuzzer and driver should be implemented in C++ and/or Python.\n\n**Confirmed Mentor:** Raphael Isemann, Shafik Yaghmour\n\n**Desirable skills:** Intermediate knowledge of C++.\n\n**Description of the project:** Clang has a newly implemented autocompletion feature which details can be found at [LLVM blog](http://blog.llvm.org/2017/09/clang-bash-better-auto-completion-is.html). We would like to improve this by adding more flags to autocompletion, supporting more shells (currently it supports only bash) and exporting this feature to other projects such as llvm-opt. Accepted student will be working on Clang Driver, LLVM Options and shell scripts.\n\n**Expected Results:** Autocompletion working on bash and zsh, support llvm-opt options.\n\n**Confirmed Mentor:** Yuka Takahashi and Vassil Vassilev\n\n**Desirable skills:** Intermediate knowledge of C++ and shell scripting\n\nGoogle Summer of Code 2018 contributed a lot to the LLVM project. For the list of accepted and completed projects, please take a look into Google Summer of Code [website.](https://summerofcode.withgoogle.com/archive/2018/organizations/5263452624912384/)\n\nGoogle Summer of Code 2017 contributed a lot to the LLVM project. For the list of accepted and completed projects, please take a look into Google Summer of Code [website.](https://summerofcode.withgoogle.com/archive/2017/organizations/6215410651234304/)\n\nThis document is meant to be a sort of \"big TODO list\" for LLVM. Each project in this document is something that would be useful for LLVM to have, and would also be a great way to get familiar with the system. Some of these projects are small and self-contained, which may be implemented in a couple of days, others are larger. Several of these projects may lead to interesting research projects in their own right. In any case, we welcome all contributions.\n\nIf you are thinking about tackling one of these projects, please send a mail to the [LLVM Developer's](http://lists.llvm.org/mailman/listinfo/llvm-dev) mailing list, so that we know the project is being worked on. Additionally this is a good way to get more information about a specific project or to suggest other projects to add to this page.\n\nThe projects in this page are open-ended. More specific projects are filed as unassigned enhancements in the [LLVM bug tracker](https://github.com/llvm/llvm-project/issues/). See the [list of currently outstanding issues](https://github.com/llvm/llvm-project/issues?q=is%3Aopen+is%3Aissue+no%3Aassignee) if you wish to help improve LLVM.\n\nIn addition to hacking on the main LLVM project, LLVM has several subprojects, including Clang and others. If you are interested in working on these, please see their \"Open projects\" page:\n\n*   The [Clang Open Projects](http://clang.llvm.org/OpenProjects.html) list.\n*   The [Polly Open Projects](http://polly.llvm.org/projects.html) list.\n*   The [SAFECode Open Projects](http://sva.cs.illinois.edu/projects.html) list.\n\nImprovements to the current infrastructure are always very welcome and tend to be fairly straight-forward to implement. Here are some of the key areas that can use improvement...\n\nCurrently, both Clang and LLVM have a separate target description infrastructure, with some features duplicated, others \"shared\" (in the sense that Clang has to create a full LLVM target description to query specific information).\n\nThis separation has grown in parallel, since in the beginning they were quite different and served disparate purposes. But as the compiler evolved, more and more features had to be shared between the two so that the compiler would behave properly. An example is when targets have default features on speficic configurations that don't have flags for. If the back-end has a different \"default\" behaviour than the front-end and the latter has no way of enforcing behaviour, it won't work.\n\nAn alternative would be to create flags for all little quirks, but first, Clang is not the only front-end or tool that uses LLVM's middle/back ends, and second, that's what \"default behaviour\" is there for, so we'd be missing the point.\n\nSeveral ideas have been floating around to fix the Clang driver WRT recognizing architectures, features and so on (table-gen it, user-specific configuration files, etc) but none of them touch the critical issue: sharing that information with the back-end.\n\nRecently, the idea to factor out the target description infrastructure from both Clang and LLVM into its own library that both use, has been floating around. This would make sure that all defaults, flags and behaviour are shared, but would also reduce the complexity (and thus the cost of maintenance) a lot. That would also allow all tools (lli, llc, lld, lldb, etc) to have the same behaviour across the board.\n\nThe main challenges are:\n\n*   To make sure the transition doesn't destroy the delicate balance on any target, as some defaults are implicit and, some times, unknown.\n*   To be able to migrate one target at a time, one tool at a time and still keep the old infrastructure intact.\n*   To make it easy for detecting target's features for both front-end and back-end features, and to merge both into a coherent set of properties.\n*   To provide a bridge to the new system for tools that haven't migrated, especially the off-the-tree ones, that will need some time (one release, at least) to migrate..\n\nThe [LLVM bug tracker](https://github.com/llvm/llvm-project/issues/) occasionally has [\"code-cleanup\" bugs](https://github.com/llvm/llvm-project/labels/code-cleanup) filed in it. Taking one of these and fixing it is a good way to get your feet wet in the LLVM code and discover how some of its components work. Some of these include some major IR redesign work, which is high-impact because it can simplify a lot of things in the optimizer.\n\nSome specific ones that would be great to have:\n\n*   [Fix the design of GlobalAlias to not require dest type to match source type](https://llvm.org/PR10367)\n*   [Redesign ConstantExpr's](https://llvm.org/PR10368)\n*   [Static constructors should be purged from LLVM](https://llvm.org/PR11944)\n\nAdditionally, there are performance improvements in LLVM that need to get fixed. These are marked with the slow-compile keyword. Use [this LLVM bug tracker query](https://github.com/llvm/llvm-project/issues?q=is%3Aopen+is%3Aissue+label%3Aslow-compile) to find them.\n\nThe [llvm-test](https://llvm.org/docs/TestingGuide.html#wholeprograms) testsuite is a large collection of programs we use for nightly testing of generated code performance, compile times, correctness, etc. Having a large testsuite gives us a lot of coverage of programs and enables us to spot and improve any problem areas in the compiler.\n\nOne extremely useful task, which does not require in-depth knowledge of compilers, would be to extend our testsuite to include [new programs and benchmarks](http://nondot.org/sabre/LLVMNotes/#benchmarks). In particular, we are interested in cpu-intensive programs that have few library dependencies, produce some output that can be used for correctness testing, and that are redistributable in source form. Many different programs are suitable, for example, see [this list](http://nondot.org/sabre/LLVMNotes/#benchmarks) for some potential candidates.\n\nWe are always looking for new testcases and benchmarks for use with LLVM. In particular, it is useful to try compiling your favorite C source code with LLVM. If it doesn't compile, try to figure out why or report it to the [llvm-bugs](http://lists.llvm.org/pipermail/llvm-bugs/) list. If you get the program to compile, it would be extremely useful to convert the build system to be compatible with the LLVM Programs testsuite so that we can check it into SVN and the automated tester can use it to track progress of the compiler.\n\nWhen testing a code, try running it with a variety of optimizations, and with all the back-ends: CBE, llc, and lli.\n\nFind benchmarks either using our [test results](https://llvm.org/nightlytest/) or on your own, where LLVM code generators do not produce optimal code or where another compiler produces better code. Try to minimize the test case that demonstrates the issue. Then, either [submit a bug](https://github.com/llvm/llvm-project/issues/) with your testcase and the code that LLVM produces vs. the code that it _should_ produce, or even better, see if you can improve the code generator and submit a patch. The basic idea is that it's generally quite easy for us to fix performance problems if we know about them, but we generally don't have the resources to go finding out why performance is bad.\n\nThe [LNT perf database](http://llvm.org/perf/db_default/v4/nts/recent_activity) has some nice features like detect moving average, standard deviations, variations, etc. But the report page give too much emphasis on the individual variation (where noise can be higher than signal), eg. [this case](http://llvm.org/perf/db_default/v4/nts/graph?plot.0=10.341.3&highlight_run=8943).\n\nThe first part of the project would be to create an analysis tool that would track moving averages and report:\n\n*   If the current result is higher/lower than the previous moving average by more than (configurable) S standard deviations\n*   If the current moving average is more than S standard deviations of the Base run\n*   If the last A moving averages are in constant increase/decrease of more than P percent\n\nThe second part would be to create a web page which would show all related benchmarks (possibly configurable, like a dashboard) and show the basic statistics with red/yellow/green colour codes to show status and links to more detailed analysis of each benchmark.\n\nA possible third part would be to be able to automatically cross reference different builds, so that if you group them by architecture/compiler/number of CPUs, this automated tool would understand that the changes are more common to one particular group.\n\nThe [LLVM Coverage Report](http://llvm.org/reports/coverage/) has a nice interface to show what source lines are covered by the tests, but it doesn't mentions which tests, which revision and what architecture is covered.\n\nA project to renovate LCOV would involve:\n\n*   Making it run on a buildbot, so that we know what commits / architectures are covered\n*   Update the web page to show that information\n*   Develop a system that would report every buildbot build into the web page in a searchable database, like LNT\n\nAnother idea is to enable the test suite to run all built backends, not only the host architecture, so that coverage report can be built in a fast machine and have one report per commit without needing to update the buildbots.\n\n1.  Completely rewrite bugpoint. In addition to being a mess, bugpoint suffers from a number of problems where it will \"lose\" a bug when reducing. It should be rewritten from scratch to solve these and other problems.\n2.  [Add support for transactions to the PassManager](https://llvm.org/PR2116) for improved bugpoint.\n3.  [Improve bugpoint to support running tests in parallel on MP machines](https://llvm.org/PR539).\n4.  Add MC assembler/disassembler and JIT support to the SPARC port.\n5.  Move more optimizations out of the \\-instcombine pass and into InstructionSimplify. The optimizations that should be moved are those that do not create new instructions, for example turning sub i32 %x, 0 into %x. Many passes use InstructionSimplify to clean up code as they go, so making it smarter can result in improvements all over the place.\n\nSometimes creating new things is more fun than improving existing things. These projects tend to be more involved and perhaps require more work, but can also be very rewarding.\n\nWe have a [strong base for development](https://llvm.org/docs/AliasAnalysis.html) of both pointer analysis based optimizations as well as pointer analyses themselves. We want to take advantage of this:\n\n1.  The globals mod/ref pass does an inexpensive bottom-up context sensitive alias analysis. There are some inexpensive things that we could do to better capture the effects of functions that access pointer arguments. This can be really important for C++ methods, which spend lots of time accessing pointers off 'this'.\n2.  The alias analysis API supports the getModRefBehavior method, which allows the implementation to give details analysis of the functions. For example, we could implement [full knowledge of printf/scanf](https://llvm.org/PR1604) side effects, which would be useful. This feature is in place but not being used for anything right now.\n3.  We need some way to reason about errno. Consider a loop like this:\n    \n        for ()\n          x += sqrt(loopinvariant);\n    \n    We'd like to transform this into:\n    \n        t = sqrt(loopinvariant);\n        for ()\n          x += t;\n    \n    This transformation is safe, because the value of errno isn't otherwise changed in the loop and the exit value of errno from the loop is the same. We currently can't do this, because sqrt clobbers errno, so it isn't \"readonly\" or \"readnone\" and we don't have a good way to model this.\n    \n    The important part of this project is figuring out how to describe errno in the optimizer: each libc #defines errno to something different it seems. Maybe the solution is to have a \\_\\_builtin\\_errno\\_addr() or something and change sys headers to use it.\n    \n4.  There are lots of ways to optimize out and [improve handling of memcpy/memset](https://llvm.org/PR452).\n\nWe now have a unified infrastructure for writing profile-guided transformations, which will work either at offline-compile-time or in the JIT, but we don't have many transformations. We would welcome new profile-guided transformations as well as improvements to the current profiling system.\n\nIdeas for profile-guided transformations:\n\n1.  Superblock formation (with many optimizations)\n2.  Loop unrolling/peeling\n3.  Profile directed inlining\n4.  Code layout\n5.  ...\n\nImprovements to the existing support:\n\n1.  The current block and edge profiling code that gets inserted is very simple and inefficient. Through the use of control-dependence information, many fewer counters could be inserted into the code. Also, if the execution count of a loop is known to be a compile-time or runtime constant, all of the counters in the loop could be avoided.\n2.  You could implement one of the \"static profiling\" algorithms which analyze a piece of code an make educated guesses about the relative execution frequencies of various parts of the code.\n3.  You could add path profiling support, or adapt the existing LLVM path profiling code to work with the generic profiling interfaces.\n\nLLVM aggressively optimizes for performance, but does not yet optimize for code size. With a new ARM backend, there is increasing interest in using LLVM for embedded systems where code size is more of an issue.\n\nSomeone interested in working on implementing code compaction in LLVM might want to read [this](http://citeseer.ist.psu.edu/425696.html) article, describing using link-time optimizations for code size optimization.\n\n1.  Implement a Loop Dependence Analysis Infrastructure  \n    \\- Design some way to represent and query dep analysis\n2.  Value range propagation pass\n3.  More fun with loops: [Predictive Commoning](http://www.cs.ualberta.ca/~amaral/cascon/CDP04/tal.html)\n4.  Type inference (aka. devirtualization)\n5.  [Value assertions](http://nondot.org/sabre/LLVMNotes/BuiltinUnreachable.txt) (also [PR810](https://llvm.org/PR810)).\n\n1.  Generalize target-specific backend passes that could be target-independent, by adding necessary target hooks and making sure all IR/MI features (such as register masks and predicated instructions) are properly handled. Enable these for other targets where doing so is demonstrably beneficial. For example:\n    1.  lib/Target/Hexagon/RDF\\*\n    2.  lib/Target/AArch64/AArch64AddressTypePromotion.cpp\n2.  Merge the delay slot filling logic that is duplicated into (at least) the Sparc and Mips backends into a single target independent pass. Likewise, the branch shortening logic in several targets should be merged together into one pass.\n3.  Implement 'stack slot coloring' to allocate two frame indexes to the same stack offset if their live ranges don't overlap. This can reuse a bunch of analysis machinery from LiveIntervals. Making the stack smaller is good for cache use and very important on targets where loads have limited displacement like ppc, thumb, mips, sparc, etc. This should be done as a pass before prolog epilog insertion. This is now done for register allocator temporaries, but not for allocas.\n4.  Implement 'shrink wrapping', which is the intelligent placement of callee saved register save/restores. Right now PrologEpilogInsertion always saves every (modified) callee save reg in the prolog and restores it in the epilog, however, some paths through a function (e.g. an early exit) may not use all regs. Sinking the save down the CFG avoids useless work on these paths. Work has started on this, please inquire on llvm-dev.\n5.  Implement interprocedural register allocation. The CallGraphSCCPass can be used to implement a bottom-up analysis that will determine the \\*actual\\* registers clobbered by a function. Use the pass to fine tune register usage in callers based on \\*actual\\* registers used by the callee.\n6.  Add support for 16-bit x86 assembly and real mode to the assembler and disassembler, for use by BIOS code. This includes both 16-bit instruction encodings as well as privileged instructions (lgdt, lldt, ltr, lmsw, clts, invd, invlpg, wbinvd, hlt, rdmsr, wrmsr, rdpmc, rdtsc) and the control and debug registers.\n\n1.  Port the [Bigloo](http://www-sop.inria.fr/mimosa/fp/Bigloo/) Scheme compiler, from Manuel Serrano at INRIA Sophia-Antipolis, to output LLVM bytecode. It seems that it can already output .NET bytecode, JVM bytecode, and C, so LLVM would ostensibly be another good candidate.\n2.  Write a new frontend for some other language (Java? OCaml? Forth?)\n3.  Random test vector generator: Use a C grammar to generate random C code, e.g., [quest](http://code.google.com/p/quest-tester/); run it through llvm-gcc, then run a random set of passes on it using opt. Try to crash [opt](https://llvm.org/docs/CommandGuide/html/opt.html). When opt crashes, use [bugpoint](https://llvm.org/docs/CommandGuide/html/bugpoint.html) to reduce the test case and post it to a website or mailing list. Repeat ad infinitum.\n4.  Add sandbox features to the Interpreter: catch invalid memory accesses, potentially unsafe operations (access via arbitrary memory pointer) etc.\n5.  Port [Valgrind](http://valgrind.org/) to use LLVM code generation and optimization passes instead of its own.\n6.  Write LLVM IR level debugger (extend Interpreter?)\n7.  Write an LLVM Superoptimizer. It would be interesting to take ideas from this superoptimizer for x86: [paper #1](http://theory.stanford.edu/~aiken/publications/papers/asplos06.pdf) and [paper #2](http://theory.stanford.edu/~sbansal/superoptimizer.html) and adapt them to run on LLVM code.It would seem that operating on LLVM code would save a lot of time because its semantics are much simpler than x86. The cost of operating on LLVM is that target-specific tricks would be missed.\n    \n    The outcome would be a new LLVM pass that subsumes at least the instruction combiner, and probably a few other passes as well. Benefits would include not missing cases missed by the current combiner and also more easily adapting to changes in the LLVM IR.\n    \n    All previous superoptimizers have worked on linear sequences of code. It would seem much better to operate on small subgraphs of the program dependency graph.\n    \n\nIn addition to projects that enhance the existing LLVM infrastructure, there are projects that improve software that uses, but is not included with, the LLVM compiler infrastructure. These projects include open-source software projects and research projects that use LLVM. Like projects that enhance the core LLVM infrastructure, these projects are often challenging and rewarding.\n\nAt least one project (and probably more) needs to use analysis information (such as call graph analysis) from within a MachineFunctionPass, however, most analysis passes operate at the LLVM IR level. In some cases, a value (e.g., a function pointer) cannot be mapped from the MachineInstr level back to the LLVM IR level reliably, making the use of existing LLVM analysis passes from within a MachineFunctionPass impossible (or at least brittle).\n\nThis project is to encode analysis information from the LLVM IR level into the MachineInstr IR when it is generated so that it is available to a MachineFunctionPass. The exemplar is call graph analysis (useful for control-flow integrity instrumentation, analysis of code reuse defenses, and gadget compilers); however, other LLVM analyses may be useful.\n\nImplement an on-demand function relocator in the LLVM JIT. This can help improve code locality using runtime profiling information. The idea is to use a relocation table for every function. The relocation entries need to be updated upon every function relocation (take a look at [this article](https://people.cs.umass.edu/~emery/pubs/stabilizer-asplos13.pdf)). A (per-function) basic block reordering would be a useful extension.\n\nThe goal of this project is to implement better data layout optimizations using the model of reference affinity. This [paper](http://www.cs.rochester.edu/~cding/Documents/Publications/pldi04.pdf) provides some background information.\n\nSlimmer is a prototype tool, built using LLVM, that uses dynamic analysis to find potential performance bugs in programs. Development on Slimmer started during Google Summer of Code in 2015 and resulted in an initial prototype, but evaluation of the prototype and improvements to make it portable and robust are still needed. This project would have a student pick up and finish the Slimmer work. The source code of Slimmer and its current documentation can be found at its [Github](https://github.com/james0zan/Slimmer) web page.\n\n* * *\n\n\n\n\n\n |\n"}