{"name":"FLARE","description":"Industry leading malware analysis","gsoc_url":"https://summerofcode.withgoogle.com/programs/2025/organizations/flare","ideas_url":"https://github.com/mandiant/flare-gsoc/blob/2025/doc/project-ideas.md","logo":"https://summerofcode.withgoogle.com/media/org/flare/6so0wjs76qeewe9v-360.png","technologies":["python","ida-pro","Ghidra"],"topics":["emulation","disassembly","decompilation","malware-analysis","reverse-engineering"],"projects":[{"project_name":"capa: add Binary Ninja Explorer plugin","summary":"Develop a plugin to enhance Binary Ninja with capa functionality for identifying program capabilities in binaries, including a user-friendly display of results and navigation features.","difficulty":"medium"},{"project_name":"capa: add Ghidra Explorer plugin","summary":"Create a capa Explorer plugin for Ghidra to allow seamless integration of capa capabilities into the Ghidra analysis workflow with an interactive results display.","difficulty":"medium"},{"project_name":"capa: add Frida dynamic analysis for Android","summary":"Integrate capa's capabilities with Frida to enable dynamic analysis of Android applications, utilizing Frida's instrumentation to extract relevant capability data during runtime.","difficulty":"hard"},{"project_name":"capa: migrate to PyGhidra","summary":"Migrate the existing capa Ghidra backend to the officially supported PyGhidra bindings for better maintainability and compatibility with future Ghidra releases.","difficulty":"low"},{"project_name":"capa: add ARM support to IDA Pro, Ghidra, and/or Binary Ninja","summary":"Extend capa's feature extraction capabilities to support ARM architecture binaries across popular analysis backends like IDA Pro, Ghidra, and Binary Ninja.","difficulty":"medium"},{"project_name":"FLOSS: extract language specific strings (.NET, Swift, Zig, ...)","summary":"Enhance FLOSS to extract strings specific to various programming languages, improving categorization of output for more efficient analysis by malware analysts.","difficulty":"medium"},{"project_name":"FLOSS: QUANTUMSTRAND","summary":"Integrate QUANTUMSTRAND rendering techniques into FLOSS to augment string outputs with contextual information useful for malware analysis.","difficulty":"medium"},{"project_name":"BinDiff: rearchitect Binary Diff Server and port to PyQt","summary":"Modernize BinDiff by developing a cross-platform diffing service with a unified UI, separating the diffing engine from UI functionalities to improve maintainability.","difficulty":"hard"},{"project_name":"XRefer: Build a Multi-Backend Abstraction Layer with Binary Ninja Support","summary":"Refactor XRefer's analyzer component to support multiple backends, particularly Binary Ninja, enabling easier integration with different reverse-engineering platforms.","difficulty":"medium"},{"project_name":"XRefer: HTML Exporter and Visualizer for XRefer's Cluster Analysis","summary":"Design an HTML export module for XRefer to generate interactive visualizations for cluster analysis results, allowing users to explore and analyze data effectively.","difficulty":"low"},{"project_name":"GoReSym: project in scope","summary":"Develop a Go symbol parser to extract and handle program metadata related to various attributes like CPU architecture and compiler details, assisting reverse-engineering efforts.","difficulty":"medium"}],"jina_response":"Title: flare-gsoc/doc/project-ideas.md at 2025 Â· mandiant/flare-gsoc\n\nURL Source: https://github.com/mandiant/flare-gsoc/blob/2025/doc/project-ideas.md\n\nMarkdown Content:\n_FLARE @ Google Summer of Code 2025_\n\nThis document lists examples of projects that would be great for GSoC 2025 contributors. The list doesn't include everything - feel free to identify your own idea and propose it!\n\nAll of our project ideas revolve around reverse engineering tools. That is, we want to improve the lives of malware analysts through novel techniques and automation. To succeed with any of these examples, you should have a basic familiarity with reverse engineering or a strong desire to learn.\n\nBriefly:\n\n*   [capa](https://github.com/mandiant/capa) identifies the capabilities in executable files, such as \"installs a service\" or \"downloads data via HTTP\".\n    *   [add Binary Ninja Explorer plugin](https://github.com/mandiant/flare-gsoc/blob/2025/doc/project-ideas.md#capa-add-binary-ninja-explorer-plugin)\n    *   [add Ghidra Explorer plugin](https://github.com/mandiant/flare-gsoc/blob/2025/doc/project-ideas.md#capa-add-ghidra-explorer-plugin)\n    *   [Frida dynamic analysis for Android](https://github.com/mandiant/flare-gsoc/blob/2025/doc/project-ideas.md#capa-add-frida-dynamic-analysis-for-android)\n    *   [migrate to PyGhidra](https://github.com/mandiant/flare-gsoc/blob/2025/doc/project-ideas.md#capa-migrate-to-pyghidra)\n    *   [add ARM support to IDA Pro, Ghidra, and/or Binary Ninja backends](https://github.com/mandiant/flare-gsoc/blob/2025/doc/project-ideas.md#capa-add-arm-support-to-ida-pro-ghidra-andor-binary-ninja-backends)\n*   [FLOSS](https://github.com/mandiant/flare-floss) automatically deobfuscated protected strings in malware.\n    *   [extract language specific strings (.NET, Swift, Zig, ...)](https://github.com/mandiant/flare-gsoc/blob/2025/doc/project-ideas.md#floss-extract-language-specific-strings-net-swift-zig-)\n    *   [QUANTUMSTRAND](https://github.com/mandiant/flare-gsoc/blob/2025/doc/project-ideas.md#floss-quantumstrand)\n*   [BinDiff](https://github.com/google/bindiff) is an open-source comparison tool for binary files that assists vulnerability researchers and engineers to quickly find differences and similarities in disassembled code.\n    *   [rearchitect Binary Diff Server and port to PyQt](https://github.com/mandiant/flare-gsoc/blob/2025/doc/project-ideas.md#bindiff-rearchitect-binary-diff-server-and-port-to-pyqt)\n*   [XRefer](https://github.com/mandiant/xrefer) is an IDA plugin offering a custom navigation interface to examine execution paths, highlight downstream behaviors, cluster related functions, and generate Gemini-based insights into the malware's anatomy.\n    *   [Build a Multi-Backend Abstraction Layer with Binary Ninja Support](https://github.com/mandiant/flare-gsoc/blob/2025/doc/project-ideas.md#xrefer-build-a-multi-backend-abstraction-layer-with-binary-ninja-support)\n    *   [HTML Exporter and Visualizer for XRefer's Cluster Analysis](https://github.com/mandiant/flare-gsoc/blob/2025/doc/project-ideas.md#xrefer-html-exporter-and-visualizer-for-xrefers-cluster-analysis)\n*   [GoReSym](https://github.com/mandiant/GoReSym) is a Go symbol parser that extracts program metadata (such as CPU architecture, OS, endianness, compiler version, etc), function metadata, filename and line number metadata, and embedded structures and types.\n\nThese tools are used by thousands of analysts to identify, describe, and stop malware.\n\ncapa: add Binary Ninja Explorer plugin\n--------------------------------------\n\n[](https://github.com/mandiant/flare-gsoc/blob/2025/doc/project-ideas.md#capa-add-binary-ninja-explorer-plugin)\n\n_size_: medium, estimated 175 hours\n\n_difficulty_: medium\n\n_mentors_: [@williballenthin](https://github.com/williballenthin)\n\n_link_: [mandiant/capa#169](https://github.com/mandiant/capa/issues/169)\n\ncapa is the FLARE team's open-source tool to identify program capabilities using an extensible rule set.\n\nBinary Ninja (Binja) is a modern disassembler and reverse engineering tool with a robust Python API that facilitates plugin development. A capa Explorer plugin for Binary Ninja would significantly enhance the workflow of reverse engineers who use Binja, allowing them to seamlessly identify and analyze program capabilities within their preferred environment. This project would not only benefit Binja users but also expand the reach and adoption of capa within the reverse engineering community.\n\nThe core functionality of the plugin would be to:\n\n1.  **Use capa's existing Binary Ninja backend to find capabilities in the currently open binary**.\n2.  **Display the capa results in a user-friendly manner within Binary Ninja**. This includes displaying matching rules, the locations of matched features, and potentially the associated source code (if debug information is available).\n3.  **Allow users to navigate from the capa results to the corresponding locations in the disassembly view**. This is crucial for efficient analysis, enabling users to quickly jump to the code responsible for a detected capability.\n\n**Deliverables**:\n\n*   **Results Display**:\n    *   Implement a custom dock widget (view) in Binary Ninja to display the capa results.\n    *   Display a hierarchical tree view of matching rules, grouped by namespace (e.g., \"anti-analysis\", \"communication\").\n    *   Show the rule name, description (short summary), and match status.\n    *   Display the locations (addresses) of matched features within each rule.\n    *   Implement filtering and searching capabilities within the results view. Allow users to filter rules by namespace, ATT&CK technique, or keyword.\n    *   Highlight matched features directly in the disassembly view using Binary Ninja's highlighting API.\n*   **Navigation**:\n    *   Enable double-clicking on a rule or feature location in the results view to navigate to the corresponding address in the Binary Ninja disassembly view. Highlight the relevant instruction(s).\n    *   Add tags/bookmarks for the matches.\n*   **Rule Selection**:\n    *   Basic UI for user to select a file path that contains the rulesets they'd like to use.\n*   **Testing and Documentation**:\n    *   Write basic unit tests for the plugin's core functionality.\n    *   Create user documentation explaining how to install and use the plugin.\n*   **Blog Post**:\n    *   Document the development process and findings in a blog post suitable for publication on the Mandiant blog or a similar platform.\n\n**Required Skills**:\n\n*   Solid knowledge of Python 3.\n*   Experience with Binary Ninja's API (or strong willingness to learn).\n*   Basic understanding of reverse engineering concepts (disassembly, assembly language, executable file formats).\n*   Experience with Git and GitHub.\n\n**Potential Challenges and Mitigation Strategies**:\n\n*   **Binary Ninja API Learning Curve**: Binary Ninja's API is extensive, but well-documented. The contributor should allocate time for learning the API and exploring existing plugins. The mentors can provide guidance and point to relevant examples.\n*   **Performance Optimization**: Running capa on large binaries can be time-consuming. The plugin should be designed to handle large analysis results efficiently and provide progress feedback to the user. Asynchronous execution and caching strategies can be employed.\n*   **UI Design**: Provide the user an intuitive way to interact with the plugin.\n\ncapa: add Ghidra Explorer plugin\n--------------------------------\n\n[](https://github.com/mandiant/flare-gsoc/blob/2025/doc/project-ideas.md#capa-add-ghidra-explorer-plugin)\n\n_size_: medium, estimated 175 hours\n\n_difficulty_: medium\n\n_mentors_: [@mike-hunhoff](https://github.com/mike-hunhoff)\n\n_link_: [mandiant/capa#1980](https://github.com/mandiant/capa/issues/1980)\n\ncapa is the FLARE team's open-source tool to identify program capabilities using an extensible rule set. Currently, analysts often invoke capa as a command-line tool or via the capa Explorer plugin for IDA Pro. This project aims to bring the interactive rule exploration experience of capa Explorer to Ghidra, a powerful and extensible reverse engineering platform developed by the NSA.\n\nGhidra is a free and open-source software reverse engineering (SRE) framework. It includes a suite of tools for analyzing compiled code on a variety of platforms. Ghidra's extensibility is a key feature, and recently, the PyGhidra project has provided Python bindings for the Ghidra API, enabling plugin development in Python. A capa Explorer plugin for Ghidra would greatly enhance the workflow of reverse engineers who rely on Ghidra, allowing them to seamlessly integrate capa's capability detection into their analysis process. This project would benefit both Ghidra users and expand the user base of capa.\n\nThe core functionality of the plugin would be to:\n\n1.  **Use capa's existing Ghidra backend to find capabilities in the currently open binary**.\n2.  **Display the capa results in a user-friendly manner within Ghidra**. This includes showing matching rules, the locations of matched features (addresses, function names, etc.), and potentially linking to the relevant decompiler output.\n3.  **Allow users to navigate from the capa results to the corresponding locations in the Ghidra disassembly listing and decompiler views**. This is critical for efficient analysis, enabling users to quickly jump to the code associated with a detected capability.\n\n**Deliverables**:\n\n*   **Results Display**:\n    *   Implement a custom Ghidra Tool window or panel to display the capa results.\n    *   Display a hierarchical tree view of matching rules, grouped by namespace (e.g., \"anti-analysis\", \"communication\").\n    *   Show the rule name, description, and match status.\n    *   Display the locations of matched features within each rule.\n    *   Implement filtering and searching capabilities within the results view. Allow users to filter rules by namespace, ATT&CK technique, or keyword.\n    *   Highlight matched features directly in the Ghidra listing view using Ghidra's highlighting API.\n*   **Navigation**:\n    *   Enable double-clicking on a rule or feature location in the results view to navigate to the corresponding address in the Ghidra disassembly listing view.\n    *   Highlight the relevant instructions.\n*   **Rule Selection**:\n    *   Provide a basic UI for the user to select the file path containing the desired rulesets.\n*   **Testing and Documentation**:\n    *   Write basic unit tests for the plugin's core functionality.\n    *   Create user documentation explaining how to install and use the plugin.\n*   **Blog Post**:\n    *   Document the development process, challenges and finding in a blog post.\n\n**Required Skills**:\n\n*   Solid knowledge of Python 3.\n*   Experience with Ghidra and PyGhidra (or strong willingness to learn). Familiarity with Java is a plus, but not strictly required due to PyGhidra.\n*   Basic understanding of reverse engineering concepts (disassembly, assembly language, executable file formats).\n*   Experience with Git and GitHub.\n\n**Potential Challenges and Mitigation Strategies**:\n\n*   **PyGhidra Learning Curve**: While PyGhidra simplifies Ghidra plugin development, the student will still need to learn the PyGhidra API and how it interacts with Ghidra's underlying Java API. The mentors can provide guidance and point to relevant examples.\n*   **Performance Optimization**: Running capa on large binaries can be time-consuming. The plugin should handle large results efficiently and provide feedback to the user. Asynchronous execution and caching can help.\n*   **UI Design**: Design the user interface to be intuitive within the Ghidra environment.\n\ncapa: add Frida dynamic analysis for Android\n--------------------------------------------\n\n[](https://github.com/mandiant/flare-gsoc/blob/2025/doc/project-ideas.md#capa-add-frida-dynamic-analysis-for-android)\n\n_size_: large, estimated 350 hours\n\n_difficulty_: hard\n\n_mentors_: [@larchchen](https://github.com/larchchen)\n\ncapa is the FLARE team's open-source tool to identify program capabilities using an extensible rule set.\n\n[Frida](https://github.com/frida/frida) is a popular dynamic instrumentation toolkit for developers, reverse-engineers, and security researchers, allowing custom scripts injected into black box processes thus monitoring program behaviors. Frida is a particularly preferred option to analyze Android Apps by launching Apps in Android Emulator and intercepting certain function calls.\n\nIn addition to the capa's dependencies on CAPE sandbox during dynamic capabilities detection, Frida is a more friendly alternative for mobile App analysis. With the possibilities of using existing Frida scripts and/or developing new Frida scripts, extending capa's dynamic detection upon logs generated from Frida logs would be a good start. Integrating capa rule matching engine with Frida scripts could be another bonus approach. The goal of this project is to support capa rule matching capabilities in Android via Frida instrumentation framework.\n\n**Deliverables**\n\n*   Research\n    *   Review capa's existing support of dynamic capabilities detection\n    *   Review Frida's instrumentation framework\n*   Identify Additions, Changes, and Improvements\n    *   Suggest technical roadmaps to support Frida-capa detection\n    *   Discuss ideas with mentors and capa user community\n*   Implementation\n    *   Implement ideas aligned with finalized roadmaps\n*   Evaluation and Knowledge Sharing\n    *   Test deliverables and gather feedback from users\n    *   Write blog post about experience and project achievements\n\n**Required Skills**\n\n*   Solid knowledge of Python 3\n*   Solid knowledge of one of JavaScript/C/Go\n*   Basic understanding of reverse engineering / malware analysis\n*   Basic understanding of Git\n*   Basic understanding of Android App analysis using Android Emulator\n*   Basic understanding of Frida\n\ncapa: migrate to PyGhidra\n-------------------------\n\n[](https://github.com/mandiant/flare-gsoc/blob/2025/doc/project-ideas.md#capa-migrate-to-pyghidra)\n\n_size_: small, estimated 90 hours\n\n_difficulty_: low\n\n_mentors_: [@mike-hunhoff](https://github.com/mike-hunhoff)\n\n_link_: [mandiant/capa#2600](https://github.com/mandiant/capa/issues/2600)\n\nThis project aims to modernize the existing capa Ghidra backend by migrating it from the third-party Ghidrathon Python bindings to the officially supported PyGhidra bindings, [released with Ghidra 11.3](https://github.com/NationalSecurityAgency/ghidra/blob/Ghidra_11.3_build/Ghidra/Configurations/Public_Release/src/global/docs/WhatsNew.md#pyghidra). Since PyGhidra is distributed with Ghidra, we expect this to have better long term support and be easier for users to access. This migration will ensure the long-term maintainability and compatibility of the capa plugin with future Ghidra releases.\n\n**Deliverables**:\n\n*   **Port Existing Functionality**: Migrate the existing capa Ghidra backend's code to use the PyGhidra API. This primarily involves updating API calls and adapting to any differences in how PyGhidra interacts with Ghidra.\n*   **Testing**: Thoroughly test the migrated plugin to ensure that all existing features function correctly with PyGhidra.\n*   **Documentation Updates**: Update the plugin's documentation to reflect the change to PyGhidra and provide installation instructions for users.\n\n**Required Skills**:\n\n*   Basic Python programming skills.\n*   Familiarity with Ghidra and its scripting capabilities, or willingness to learn.\n*   Experience with Git and GitHub.\n*   Understanding of capa is a plus, but not required for this project.\n\ncapa: add ARM support to IDA Pro, Ghidra, and/or Binary Ninja backends\n----------------------------------------------------------------------\n\n[](https://github.com/mandiant/flare-gsoc/blob/2025/doc/project-ideas.md#capa-add-arm-support-to-ida-pro-ghidra-andor-binary-ninja-backends)\n\n_size_: small to large\n\n_difficulty_: medium\n\n_mentors_: [@mr-tz](https://github.com/mr-tz)\n\n_link_: [mandiant/capa#1774](https://github.com/mandiant/capa/issues/1774)\n\nThis project aims to extend capa's support for analyzing programs targeting the ARM architecture across its major analysis backends: IDA Pro, Ghidra, and Binary Ninja. While capa's core analysis engine (via the BinExport2 backend) already supports ARM, the backends for these popular disassemblers currently lack direct feature extraction for this architecture. This project will bridge that gap, enabling users to analyze ARM binaries seamlessly within their preferred reverse engineering environments.\n\nThe core task involves extending the existing backends to extract relevant features (instructions, API calls, constants, etc.) from ARM binaries loaded in IDA Pro, Ghidra, and Binary Ninja. This will leverage the respective disassembler APIs to access the disassembled code and program information. The extracted features will then be formatted and passed to capa's core analysis engine.\n\n**Deliverables**:\n\n*   **update capa IDA Pro backend (optional, pick 1-3)**\n*   **update capa Ghidra backend (optional, pick 1-3)**\n*   **update capa Binary Ninja backend (optional, pick 1-3)**\n*   **Testing**: Develop test cases (ARM binaries with known capabilities) and verify that capa correctly identifies capabilities in these binaries through each of the extended plugins.\n*   **Documentation**: Update the documentation for each plugin to reflect the added ARM support.\n\n**Required Skills**:\n\n*   Solid Python programming skills.\n*   Familiarity with at least one of: IDA Pro, Ghidra, or Binary Ninja, and their respective plugin APIs (or willingness to learn quickly).\n*   Basic understanding of the ARM architecture and assembly language.\n*   Experience with Git and GitHub.\n\nFLOSS: extract language specific strings (.NET, Swift, Zig, ...)\n----------------------------------------------------------------\n\n[](https://github.com/mandiant/flare-gsoc/blob/2025/doc/project-ideas.md#floss-extract-language-specific-strings-net-swift-zig-)\n\n_size_: large, estimated 350 hours\n\n_difficulty_: medium\n\n_mentors_: [@mr-tz](https://github.com/mr-tz)\n\n_link_: [mandiant/flare-floss#718](https://github.com/mandiant/flare-floss/issues/718)\n\nVarious programming languages embed the constant data, like strings, used within executables in different ways. Most tools, like strings.exe, just look for printable character sequences. This doesn't work well for files compiled from Go or Rust.\n\nHere we propose to extend FLOSS to include a framework to extract language specific strings from executables. After identifying the language, a specific extractor can use specialized logic to pull out the strings embedded into a program by the author. When possible, the extractor should indicate library and runtime-related strings. For example, the extractor may parse debug information to recognize popular third party libraries and annotate the related strings appropriately.\n\nToday, FLOSS automatically deobfuscates protected strings found in malware. Better categorization of its output would make its users more efficient. Extracting language-specific strings would make FLOSS more useful and manifest success as the default tool used by security analysts.\n\n**Deliverables**\n\n*   Develop language identification module\n    *   Initial focus on .NET\n    *   Consider also Swift, Zig, â¦\n*   Research language string embeddings and create extractor code\n    *   We can share existing knowledge and code to bootstrap this\n*   Identify strings related to runtime and library code for targeted programming languages\n*   Extend standard output format and render results\n\n**Required Skills**\n\n*   Medium knowledge of Python 3\n*   Basic understanding of reverse engineering (focus: Windows PE files)\n*   Experience with .NET or Swift (internals) is a plus, but not required\n*   Interest in malware analysis with focus on static analysis\n*   Basic understanding of Git\n\nFLOSS: QUANTUMSTRAND\n--------------------\n\n[](https://github.com/mandiant/flare-gsoc/blob/2025/doc/project-ideas.md#floss-quantumstrand)\n\n_size_: large, estimated 350 hours\n\n_difficulty_: medium\n\n_mentors_: [@williballenthin](https://github.com/williballenthin)\n\n_link_: [mandiant/flare-floss#943](https://github.com/mandiant/flare-floss/issues/943)\n\nExtend FLOSS to use the rendering techniques pioneered by QUANTUMSTRAND.\n\nQUANTUMSTRAND is an experiment that augments traditional strings.exe output with context to aid in malware analysis and reverse engineering. For example, we show the structure of a file alongside its strings and mute/highlight entries based on their global prevalence, library association, expert rules, and more.\n\nFLOSS is a tool that automatically extracts obfuscated strings from malware, rendering the human-readable data in a way that enables rapid reverse engineering.\n\nWe propose to extend FLOSS to use the techniques pioneered by QUANTUMSTRAND to highlight important information while muting common and/or analytically irrelevant noise. The project will provide an opportunity to dig into the PE, ELF, and/or Mach-O file formats, finding ways to make technical details digestible. If successful, FLOSS will continue to be the tool that malware analysts turn to when triaging unknown files.\n\n**Deliverables**\n\nBrand new output format released as part of FLOSS v4 in late 2025.\n\n*   Research\n    *   Review Quantumstrand functionality\n    *   Evaluate most useful features for integration into FLOSS\n*   Identify and Propose Improvements\n    *   Suggest improvements for the user interface and experience\n    *   Discuss ideas with mentors and FLOSS user community\n*   Implementation\n    *   Implement improved functionality\n    *   \\[stretch goal\\]: Work on a GUI to interactively display FLOSS results\n*   Evaluation and Knowledge Sharing\n    *   Test improvements and gather feedback from users\n    *   Write blog post about experience and project achievements\n\n**Required Skills**\n\n*   Solid knowledge of Python 3\n*   Basic understanding of reverse engineering / malware analysis\n*   Basic understanding of Git\n*   Experience or interest with file formats such as PE, ELF, and/or Mach-O\n*   Experience or interest in user interface and/or user experience design\n\nBinDiff: rearchitect Binary Diff Server and port to PyQt\n--------------------------------------------------------\n\n[](https://github.com/mandiant/flare-gsoc/blob/2025/doc/project-ideas.md#bindiff-rearchitect-binary-diff-server-and-port-to-pyqt)\n\n_size_: large, estimated 350 hours\n\n_difficulty_: hard\n\n_mentors_: [@cblichmann](https://github.com/cblichmann)\n\n_link_: [google/bindiff#17](https://github.com/google/bindiff/issues/17)\n\nThis project aims to modernize BinDiff by re-architecting it as a cross-platform \"diffing service\" with a unified UI layer. The core idea is to separate the diffing engine from the user interface. A \"diff server,\" implemented (likely in C++ or Rust for performance), will handle the core diffing logic. This server will load BinExport files and perform the diffing computations. It will communicate with client plugins via a protocol like gRPC.\n\nClient plugins will be developed for IDA Pro and Binary Ninja, using a shared Python codebase and PyQt for the UI. Each disassembler will have a small, platform-specific module to handle tasks like symbol porting. This architecture promotes code reuse and simplifies maintenance. Keeping the diff server running in the background allows for dynamic re-diffing as binaries are modified, and opens up possibilities for improved flow graph visualization by combining data from multiple functions.\n\nThe project scope is intentionally flexible, allowing the student and mentors to collaboratively define the specific features and implementation details. The focus will be on establishing a solid foundation for the new architecture and demonstrating its feasibility.\n\n**Deliverables (Flexible, to be refined during the project)**:\n\n*   **Diff Server Prototype**:\n    *   Design and implement a basic \"diff server\" that can load BinExport files and perform a simple diffing algorithm.\n    *   Implement a communication protocol (e.g., gRPC) for interaction with client plugins.\n*   **Shared UI Library (Python/PyQt)**:\n    *   Develop a shared Python library using PyQt that provides the core UI components for displaying diffing results. This includes views for function lists, matched/unmatched functions, and potentially basic flow graph comparisons.\n*   **IDA Pro and Binary Ninja Plugins**:\n    *   Create basic plugins for IDA Pro and Binary Ninja that utilize the shared UI library and communicate with the diff server.\n    *   Implement symbol porting.\n    *   Demonstrate basic diffing functionality within each disassembler.\n*   **Proof of Concept**:\n    *   Demonstrate the ability to load two BinExport files, perform a diff, and display the results in both IDA Pro and Binary Ninja.\n*   **Documentation**:\n    *   Document the design, architecture, and API of the diff server and client plugins.\n\n**Required Skills**:\n\n*   Solid knowledge of Python 3 and C++ and/or Rust.\n*   Experience with or willingness to learn PyQt.\n*   Experience with or willingness to learn gRPC.\n*   Basic understanding of binary diffing concepts.\n*   Familiarity with IDA Pro and Binary Ninja APIs (or strong willingness to learn).\n*   Experience with Git and GitHub.\n\n**Potential Challenges**:\n\n*   **Defining the Scope**: The open-ended nature of the project requires careful planning and communication between the student and mentors to define achievable goals.\n*   **Inter-process Communication**: Choosing and implementing an efficient and reliable communication protocol between the diff server and client plugins will be crucial.\n\n### XRefer: Build a Multi-Backend Abstraction Layer with Binary Ninja Support\n\n[](https://github.com/mandiant/flare-gsoc/blob/2025/doc/project-ideas.md#xrefer-build-a-multi-backend-abstraction-layer-with-binary-ninja-support)\n\n_size_: large, estimated 360 hours\n\n_difficulty_: medium\n\n_mentors_: [@m-umairx](https://github.com/m-umairx)\n\nXRefer is tightly coupled with IDA Pro, making it challenging to adapt for use with other popular reverse-engineering platforms like Ghidra or Binary Ninja. This project aims to refactor XRefer's core **analyzer** component, creating a new backend abstraction layer that standardizes how different platforms interact with the plugin's logic. Additionally, the project aims to aid support for Binary Ninja by implementing a new PoC backend.\n\n_**Note**: This project focuses on creating and demonstrating an abstraction layer for XRefer's underlying analysis engine only. The user interface is not included in the project scope_.\n\n**Deliverables**:\n\n*   **Code Review**\n    *   Identify and document all places where IDA-specific APIs or data structures are used within the **analyzer** and **lang** components.\n    *   Assess the feasibility and scope of decoupling those calls into a new abstraction layer.\n*   **Design a Backend Interface**\n    *   Specify the APIs needed for core tasks (e.g., disassembly, cross-references, function discovery, flow analysis) that different backends must implement.\n    *   Draft an interface or set of classes that each supported platform (IDA, Ghidra, Binary Ninja, etc.) can plug into with minimal friction.\n*   **Refactor XRefer**\n    *   Migrate IDA-specific logic into a separate module or wrapper.\n    *   Adapt XRefer's main codebase to use the newly created backend interface rather than direct IDA calls.\n*   **Proof-of-Concept for Additional Backends**\n    *   Implement a PoC backend using Binary Ninja's API.\n    *   Demonstrate how XRefer can run independently of IDA using the newly defined backend interface to generate a .**xrefer** analysis file.\n    *   Outline best practices for future contributors to add and maintain backends.\n\n**Required Skills**\n\n*   Proficiency in Python programming language.\n*   Experience with (or strong willingness to learn) IDA's Python API.\n*   Experience with (or strong willingness to learn) Binary Ninja's API.\n*   Basic understanding of reverse engineering and underlying concepts (disassembly, functions, cross-references) and executable file formats.\n*   Basic knowledge of Git/Github.\n\nXRefer: HTML Exporter and Visualizer for XRefer's Cluster Analysis\n------------------------------------------------------------------\n\n[](https://github.com/mandiant/flare-gsoc/blob/2025/doc/project-ideas.md#xrefer-html-exporter-and-visualizer-for-xrefers-cluster-analysis)\n\n_size_: medium, estimated 160 hours\n\n_difficulty_: low\n\n_mentors_: [@m-umairx](https://github.com/m-umairx)\n\nThe goal of this project is to design and implement an HTML export module for XRefer. The module will convert XRefer's internal cluster analysis data into a dynamic HTML visualization. This interactive output should allow users to:\n\n*   **View Cluster Graphs**: Render detailed graphs illustrating the relationships between clusters.\n*   **Read Semantic Descriptions**: Provide natural language explanations for each cluster and its contained functions.\n*   **Interact with Data**: Offer interactive controls (e.g., zoom, pan, node selection, filtering) to explore and analyze clusters in depth.\n\n**Deliverables**:\n\n*   **Design and Architecture**\n    *   Develop an intuitive UI/UX design that outlines how clusters and their semantic descriptions will be presented. Consider interactive elements such as zoomable graphs, clickable nodes, and filtering options.\n    *   Evaluate and choose suitable front-end libraries or frameworks (e.g., D3.js, Cytoscape.js) for rendering graphs and managing interactivity.\n*   **Develop the HTML Export Module**\n    *   Create a Python module to convert XRefer's cluster analysis data into a format consumable by the front-end (e.g., JSON).\n    *   Develop a responsive HTML template that integrates the chosen visualization libraries. The template should include placeholders for cluster graphs, semantic descriptions, and interactive controls.\n    *   Implement features such as zoom, pan, node highlighting, and tooltips to enhance the user's exploratory experience.\n    *   Integrate the export module into the existing XRefer workflow so that a .html file is generated as part of the analysis process.\n*   **Documentation**\n    *   Document the design decisions, data transformation process, and integration steps to help future contributors extend or maintain the module.\n\n**Required Skills**\n\n*   Proficiency in Python programming language.\n*   Familiarity with HTML, CSS, and JavaScript for building interactive web interfaces.\n*   Experience with visualization libraries (e.g., D3.js, Cytoscape.js) or willingness to learn how to implement interactive graphs.\n*   Ability to conceptualize and design an intuitive user interface that effectively presents complex data.\n*   Basic knowledge of Git/Github.\n\nGoReSym: project in scope\n-------------------------\n\n[](https://github.com/mandiant/flare-gsoc/blob/2025/doc/project-ideas.md#goresym-project-in-scope)\n\n_mentors_: [@stevemk14ebr](https://github.com/stevemk14ebr)\n"}